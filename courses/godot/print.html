<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title></title>
    <meta name="robots" content="noindex">


    <!-- Custom HTML head -->
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="./theme/style.css">
    <link rel="stylesheet" href="./theme/mdbook-admonish.css">

</head>

<body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="GDScript.html">GDScript 开发教程</a></li><li class="chapter-item expanded "><a href="godot3/Start.html"><strong aria-hidden="true">1.</strong> godot3示例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="godot3/将文件拖入窗口并加载文件内容.html"><strong aria-hidden="true">1.1.</strong> 将文件拖入窗口并加载文件内容</a></li><li class="chapter-item expanded "><a href="godot3/教你实现2D游戏中的小地图.html"><strong aria-hidden="true">1.2.</strong> 教你实现2D游戏中的小地图</a></li><li class="chapter-item expanded "><a href="godot3/教你实现简单的传送带效果.html"><strong aria-hidden="true">1.3.</strong> 教你实现简单的传送带效果</a></li><li class="chapter-item expanded "><a href="godot3/教你实现漂浮文本效果.html"><strong aria-hidden="true">1.4.</strong> 教你实现漂浮文本效果</a></li><li class="chapter-item expanded "><a href="godot3/教你实现PC和手机端的虚拟摇杆.html"><strong aria-hidden="true">1.5.</strong> 教你实现PC和手机端的虚拟摇杆</a></li><li class="chapter-item expanded "><a href="godot3/如何实时显示相机内容.html"><strong aria-hidden="true">1.6.</strong> 如何实时显示相机内容</a></li><li class="chapter-item expanded "><a href="godot3/如何实现2D场景的AI寻路.html"><strong aria-hidden="true">1.7.</strong> 如何实现2D场景的AI寻路</a></li><li class="chapter-item expanded "><a href="godot3/实现2D物品的拖拽移动.html"><strong aria-hidden="true">1.8.</strong> 实现2D物品的拖拽移动</a></li><li class="chapter-item expanded "><a href="godot3/实现2D相机的视角控制.html"><strong aria-hidden="true">1.9.</strong> 实现2D相机的视角控制</a></li><li class="chapter-item expanded "><a href="godot3/实现简单的2D灯光和阴影.html"><strong aria-hidden="true">1.10.</strong> 实现简单的2D灯光和阴影</a></li><li class="chapter-item expanded "><a href="godot3/实现物品拖拽与放置的功能.html"><strong aria-hidden="true">1.11.</strong> 实现物品拖拽与放置的功能</a></li><li class="chapter-item expanded "><a href="godot3/实现在2D场景中显示3D物体.html"><strong aria-hidden="true">1.12.</strong> 实现在2D场景中显示3D物体</a></li><li class="chapter-item expanded "><a href="godot3/使用鼠标拖拽来实现列表的滚动效果.html"><strong aria-hidden="true">1.13.</strong> 使用鼠标拖拽来实现列表的滚动效果</a></li><li class="chapter-item expanded "><a href="godot3/使用PinJoint2D实现可中心旋转的物体.html"><strong aria-hidden="true">1.14.</strong> 使用PinJoint2D实现可中心旋转的物体</a></li><li class="chapter-item expanded "><a href="godot3/为2D物体移动添加烟尘效果.html"><strong aria-hidden="true">1.15.</strong> 为2D物体移动添加烟尘效果</a></li><li class="chapter-item expanded "><a href="godot3/为3D物体添加一个跟随的2D物体.html"><strong aria-hidden="true">1.16.</strong> 为3D物体添加一个跟随的2D物体</a></li><li class="chapter-item expanded "><a href="godot3/血条的实现.html"><strong aria-hidden="true">1.17.</strong> 血条的实现</a></li><li class="chapter-item expanded "><a href="godot3/用Light2D实现遮罩动画.html"><strong aria-hidden="true">1.18.</strong> 用Light2D实现遮罩动画</a></li></ol></li><li class="chapter-item expanded "><a href="godot4/Start.html"><strong aria-hidden="true">2.</strong> godot4示例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="godot4/3D场景中如何控制物体的移动.html"><strong aria-hidden="true">2.1.</strong> 3D场景中如何控制物体的移动</a></li><li class="chapter-item expanded "><a href="godot4/3D场景中物体的自动寻路.html"><strong aria-hidden="true">2.2.</strong> 3D场景中物体的自动寻路</a></li><li class="chapter-item expanded "><a href="godot4/3D基础场景的搭建.html"><strong aria-hidden="true">2.3.</strong> 3D基础场景的搭建</a></li><li class="chapter-item expanded "><a href="godot4/如何将godot3项目转为godot4.html"><strong aria-hidden="true">2.4.</strong> 如何将godot3项目转为godot4</a></li><li class="chapter-item expanded "><a href="godot4/使用shader实现屏幕震动效果.html"><strong aria-hidden="true">2.5.</strong> 使用shader实现屏幕震动效果</a></li><li class="chapter-item expanded "><a href="godot4/实现抽奖功能.html"><strong aria-hidden="true">2.6.</strong> 实现抽奖功能</a></li></ol></li><li class="chapter-item expanded "><a href="游戏设计/Start.html"><strong aria-hidden="true">3.</strong> 游戏设计原理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="游戏设计/核心创意三要素.html"><strong aria-hidden="true">3.1.</strong> 核心创意三要素</a></li><li class="chapter-item expanded "><a href="游戏设计/核心创意思路.html"><strong aria-hidden="true">3.2.</strong> 核心创意思路</a></li><li class="chapter-item expanded "><a href="游戏设计/如何考虑游戏节奏.html"><strong aria-hidden="true">3.3.</strong> 如何考虑游戏节奏</a></li><li class="chapter-item expanded "><a href="游戏设计/游戏设计的基本原理.html"><strong aria-hidden="true">3.4.</strong> 游戏设计的基本原理</a></li></ol></li><li class="chapter-item expanded "><a href="shader/Start.html"><strong aria-hidden="true">4.</strong> shader实战</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="shader/核心概念.html"><strong aria-hidden="true">4.1.</strong> 核心概念</a></li><li class="chapter-item expanded "><a href="shader/glsl知识.html"><strong aria-hidden="true">4.2.</strong> glsl知识</a></li><li class="chapter-item expanded "><a href="shader/绑定图像.html"><strong aria-hidden="true">4.3.</strong> 绑定图像</a></li><li class="chapter-item expanded "><a href="shader/采样器.html"><strong aria-hidden="true">4.4.</strong> 采样器</a></li><li class="chapter-item expanded "><a href="shader/采样器.html"><strong aria-hidden="true">4.5.</strong> 采样器</a></li><li class="chapter-item expanded "><a href="shader/绑定缓冲区.html"><strong aria-hidden="true">4.6.</strong> 绑定缓冲区</a></li><li class="chapter-item expanded "><a href="shader/2D闪电特效.html"><strong aria-hidden="true">4.7.</strong> shader实战-2D闪电特效</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function (e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="https://space.bilibili.com/538676331" target="_blank" title="B站" aria-label="B站">
                            B站
                        </a>
                        <a href="/" target="_blank" title="home" aria-label="Git repository">
                            <i id="git-home" class="fa fa-home"></i>
                        </a>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wwqdrh/godot-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gdscript-开发示例"><a class="header" href="#gdscript-开发示例">GDScript 开发示例</a></h1>
<blockquote>
<p>[!tip] Godot 版本</p>
<p>包含部分3.x示例，后续都会以4.x为准。</p>
</blockquote>
<p>Godot 官网：<a href="https://godotengine.org/">https://godotengine.org/</a></p>
<p>Godot 最新正式版下载：<a href="https://godotengine.org/download/windows/">https://godotengine.org/download/windows/</a></p>
<p>所有版本下载：<a href="https://downloads.tuxfamily.org/godotengine/">https://downloads.tuxfamily.org/godotengine/</a></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot3/%E5%B0%86%E6%96%87%E4%BB%B6%E6%8B%96%E5%85%A5%E7%AA%97%E5%8F%A3%E5%B9%B6%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.html#%E5%B0%86%E6%96%87%E4%BB%B6%E6%8B%96%E5%85%A5%E7%AA%97%E5%8F%A3%E5%B9%B6%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">将文件拖入窗口并加载文件内容</a>
<ul>
<li><a href="godot3/%E5%B0%86%E6%96%87%E4%BB%B6%E6%8B%96%E5%85%A5%E7%AA%97%E5%8F%A3%E5%B9%B6%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.html#%E5%88%9B%E5%BB%BA%E5%9C%BA%E6%99%AF">创建场景</a></li>
<li><a href="godot3/%E5%B0%86%E6%96%87%E4%BB%B6%E6%8B%96%E5%85%A5%E7%AA%97%E5%8F%A3%E5%B9%B6%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.html#%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99">脚本编写</a></li>
</ul>
</li>
</ul>
<h1 id="将文件拖入窗口并加载文件内容"><a class="header" href="#将文件拖入窗口并加载文件内容">将文件拖入窗口并加载文件内容</a></h1>
<img data-id="20240608184400" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4xfmyhtj316w0jsaf3.jpg" alt="将文件拖入窗口并加载文件内容效果" />
<h2 id="创建场景"><a class="header" href="#创建场景">创建场景</a></h2>
<p>创建一个简单场景如下</p>
<img data-id="20240608184419" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4xr6h4wj309e03yjrm.jpg" alt="将文件拖入窗口并加载文件内容场景" />
<p>需要监听到文件的拖入事件，并且将文件内容读取写入到RichTextLabel中</p>
<h2 id="脚本编写"><a class="header" href="#脚本编写">脚本编写</a></h2>
<pre><code class="language-godot">extends Control

func _ready():
    get_tree().connect("files_dropped", self, "_on_file_drag")

func _on_file_drap(files, screen):
    for f in files:
        var file = File.new()
        file.open(file, File.READ)
        var content = file.get_as_text()
        $RichTextLabel.text += content
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot3/%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B02D%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9C%B0%E5%9B%BE.html#%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B02d%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9C%B0%E5%9B%BE">教你实现2D游戏中的小地图</a>
<ul>
<li><a href="godot3/%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B02D%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9C%B0%E5%9B%BE.html#%E5%9C%BA%E6%99%AF%E6%90%AD%E5%BB%BA">场景搭建</a></li>
<li><a href="godot3/%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B02D%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9C%B0%E5%9B%BE.html#%E5%88%9B%E5%BB%BA%E5%B0%8F%E5%9C%B0%E5%9B%BE">创建小地图</a></li>
<li><a href="godot3/%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B02D%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9C%B0%E5%9B%BE.html#%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8">人物移动</a></li>
<li><a href="godot3/%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B02D%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%B0%8F%E5%9C%B0%E5%9B%BE.html#%E5%B0%8F%E5%9C%B0%E5%9B%BE%E7%BC%A9%E6%94%BE">小地图缩放</a></li>
</ul>
</li>
</ul>
<h1 id="教你实现2d游戏中的小地图"><a class="header" href="#教你实现2d游戏中的小地图">教你实现2D游戏中的小地图</a></h1>
<img data-id="20240608184458" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4yfdrdbj317c0t27ab.jpg" alt="效果演示" />
<p>场景的移动，旋转，缩放都能够实时显示到小地图上</p>
<h2 id="场景搭建"><a class="header" href="#场景搭建">场景搭建</a></h2>
<img data-id="20240608184520" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4yt4fb2j309k05cjrz.jpg" alt="场景搭建" />
<p>效果如下图</p>
<img data-id="20240608184552" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4zddu7yj312w0loadx.jpg" alt="场景界面" />
<p>并且我们将Camera2D的zoom属性设置为0.3，避免将背景地图全部照上。</p>
<p>勾选current属性，表示游戏窗口为当前的camera</p>
<p>勾选rotate属性，使得相机能够跟随player进行旋转</p>
<h2 id="创建小地图"><a class="header" href="#创建小地图">创建小地图</a></h2>
<img data-id="20240608184609" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4znvli0j308s08swfk.jpg" alt="小地图节点" />
<p><code>viewport</code>: 能够单独映射出一个场景进行渲染，使用它来作为小地图的输出，右键点击<code>viewport</code>，点击<code>Instance Child Scene</code>连接之前创建的game场景</p>
<p><code>viewportContainer</code>: 设置size大小属性，以及勾选<code>Stretch</code>选项，即可在窗口看到效果</p>
<img data-id="20240608184626" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4zymf3dj315i0o8dl0.jpg" alt="viewportcontainer效果" />
<h2 id="人物移动"><a class="header" href="#人物移动">人物移动</a></h2>
<p>为player添加移动的时候就会发现场景在小地图中也同步更新了</p>
<pre><code class="language-godot">extends Sprite

var speed = 300
var rotate_speed = 2

func _process(delta):
    var rotate_dir = 0
    if Input.is_action_pressed("rotate_left"):
        rotate_dir -= 1
    elif Input.is_action_pressed("rotate_right"):
        rotate_dir += 1
    rotation += rotate_speed * rotate_dir * delta

    var velocity = Vector2.ZERO
    if Input.is_action_pressed("ui_right"):
        velocity.x += 1
    if Input.is_action_pressed("ui_left"):
        velocity.x -= 1
    if Input.is_action_pressed("ui_up"):
        velocity.y -= 1
    if Input.is_action_pressed("ui_down"):
        velocity.y += 1
    velocity = velocity.normalized()
    position += velocity * speed * delta
</code></pre>
<h2 id="小地图缩放"><a class="header" href="#小地图缩放">小地图缩放</a></h2>
<p>在场景根节点中创建脚本文件<code>Main.gd</code>, 添加小地图缩放功能，以及替换人物图标</p>
<pre><code class="language-godot">extends Node2D

var defaultMinimapScaleNum = 0.9

onready var minimap_player = $CanvasLayer/Control/ViewportContainer/Viewport/minimap/player
onready var minimap_enemys = $CanvasLayer/Control/ViewportContainer/Viewport/minimap/enemys
onready var minimap_camera = $CanvasLayer/Control/ViewportContainer/Viewport/minimap/player/Camera2D

func _ready():
    setMinimapScale()

    minimap_player.set_texture(load("res://assets/player.png"))
    minimap_player.scale = Vector2(0.3, 0.3)

    for ene in miimap_enemys.get_children():
        ene.set_texture(load("res://assets/enemy.png"))
        ene.scale = Vector2(0.3, 0.3)

func _input(event):
    if event.is_action_pressed("scale_up"):
        if defaultMinimapScaleNum &lt;= 1.8:
            defaultMinimapScaleNum += 0.1
    elif event.is_action_pressed("scale_down"):
        if defaultMinimapScaleNum &gt;= 0.2:
            defaultMinimapScaleNum -= 0.1
    setMinimapScale()

func setMinimapScale():
    minimap_camera.zoom = Vector2(defaultMinimapScaleNum, defaultMinimapScaleNum)
    # 避免小地图的缩放影响到其他元素的大小
    minimap_player.scale = Vector2(defaultMinimapScaleNum * 0.3, defaultMinimapScaleNum * 0.3)
    for ene in miimap_enemys.get_children():
        ene.scale = Vector2(defaultMinimapScaleNum * 0.3, defaultMinimapScaleNum * 0.3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教你实现简单的传送带效果"><a class="header" href="#教你实现简单的传送带效果">教你实现简单的传送带效果</a></h1>
<img data-id="20240608183952" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4t4bas7j30xo0dkdhn.jpg" alt="效果展示" />
<h2 id="场景搭建-1"><a class="header" href="#场景搭建-1">场景搭建</a></h2>
<img data-id="20240608184008" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4teiu7vj30a408e0u2.jpg" alt="效果展示" />
<blockquote>
<p>RigidBody2D是一个自带重力的节点</p>
</blockquote>
<h2 id="传送带样式"><a class="header" href="#传送带样式">传送带样式</a></h2>
<p>根据一张基础图片，进行repeat，生成传送带样式</p>
<p>创建一个Sprite节点，设置texture为AltasTexture类型，并将图片素材拖拽进texture中，选择吸附为<code>Grid snap</code>方便框选</p>
<p>在altasTexture中设置其宽度为图片宽度*10，使图片进行重复</p>
<img data-id="20240608184027" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4tpyhr2j30d20j4q6a.jpg" alt="效果展示" />
<p>这个时候图片只是进行拉伸而不是复制，需要在图片的import面板，设置<code>Flags -&gt; Repeat</code>为Enabled，然后选择Reimport重新导入即可</p>
<blockquote>
<p>可以讲该AltasTexture进行保存为tres文件方便复用</p>
</blockquote>
<h2 id="传送带移动"><a class="header" href="#传送带移动">传送带移动</a></h2>
<p>通过设置texture的<code>region -&gt; position</code>属性来完成传送带移动效果</p>
<pre><code class="language-godot">extends StaticBody2D

var speed = 100

func _ready():
    # 设置该线速度，可以使得靠近该传送带的物体也跟着移动
    const_linear_velocity.x = speed

func _process(delta):
    $Sprite.texture.region.position.x -= speed * delta
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教你实现漂浮文本效果"><a class="header" href="#教你实现漂浮文本效果">教你实现漂浮文本效果</a></h1>
<img data-id="20240608184056" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4u88cw1j30jg0bemxg.jpg" alt="效果展示" />
<h2 id="漂浮文本节点"><a class="header" href="#漂浮文本节点">漂浮文本节点</a></h2>
<img data-id="20240608184114" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4ujio6zj309c052mxe.jpg" alt="效果展示" />
<p>创建控制脚本,实现漂浮效果，在初始创建给一个向上运动然后往下落的效果</p>
<pre><code class="language-godot">extends Position2D

var text setget set_text,get_text

var velocity = Vector2.ZERO
var gravity = Vector2.ZERO
var mass = 100

func _process(delta):
    velocity += gravity * mass * delta
    position += velocity * delta

func set_text(txt):
    $Label.text = str(txt)

func get_text():
    return $Label.text
</code></pre>
<p>接下来我们需要为该节点实现缓慢消失的效果，使用<code>Tween</code>补间动画，控制<code>Position2D</code>节点的<code>Visibility -&gt; Modulate</code>进行控制，并且在补间动画完成后将节点清除</p>
<pre><code class="language-godot">extends Position2D

---
date: '2022-07-31'
tags: ['godot']
draft: false
---

# ....

func _ready():
    # 消失
    $Tween.interpolate_proerty(self, "modulate",
    Color(modulate.r, modulate.g, modulate,b, modulate.a),
    Color(modulate.r, modulate.g, modulate,b, 0),
    0.3, Tween.TRANS_LINEAR, Tween.EASE_OUT, 0.7
    )

    # 放大
    $Tween.interpolate_proerty(self, "scale",
    Vector2(0, 0),
    Vector2(1, 1),
    0.3, Tween.TRANS_LINEAR, Tween.EASE_OUT
    )

    # 缩小
    $Tween.interpolate_proerty(self, "scale",
    Vector2(1, 1),
    Vector2(0.4, 0.4),
    0.3, Tween.TRANS_LINEAR, Tween.EASE_OUT, 0.7
    )

    $Tween.start()

---
date: '2022-07-31'
tags: ['godot']
draft: false
---

# Tween所有动画完成信号
func _on_Tween_tween_all_completed():
    get_tree().queue_delete(self)
</code></pre>
<h2 id="主场景"><a class="header" href="#主场景">主场景</a></h2>
<p>创建主场景，并且创建一个按钮，当点击后新建漂浮文本</p>
<pre><code class="language-godot">extends Node2D

var float_text = preload("res://float.tscn")

func _on_Button_pressed():
    var ft = float_text.instance()
    ft.position = Vector2(200, 300)
    # 控制漂浮文本的数值
    ft.velocity = Vector2(rand_range(-50, 50), -130)
    ft.gravity = Vector2(0, 1.5)
    ft.mass(200)
    # 设置随机颜色
    ft.modulate = Color(rand_range(0.7, 1), rand_range(0.7, 1), rand_range(0.7, 1), 1)

    var num = randi()%10 - 5
    ft.text = num
    if num &gt; 0:
        ft.text = "+" + ft.text

    add_child(ft)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教你实现pc和手机端的虚拟摇杆"><a class="header" href="#教你实现pc和手机端的虚拟摇杆">教你实现PC和手机端的虚拟摇杆</a></h1>
<img data-id="20240608183841" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4rw2wfij30pg0c6mx7.jpg" alt="效果展示" />
<h2 id="场景搭建-2"><a class="header" href="#场景搭建-2">场景搭建</a></h2>
<p>素材本身就是两个大小圆，主要是通过坐标检测是否在摇杆作用范围内，然后根据坐标计算更新中心小圆的位置，并且在松开手后将其归位</p>
<img data-id="20240608183859" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4s737inj308y04q74f.jpg" alt="效果展示" />
<pre><code class="language-godot">extends Sprite

var maxLen = 70
var ondraging = -1 # 用于解决范围内点击然后移动到范围外能够继续滚动

func _input(event):
    if event is InputEventScreenDrag or (event is InputEventScreenTounch and event.is_pressed()):
        var mouse_pos = (event.position - self.global_position).length()

        if mouse_pos &lt;= maxLen or event.get_index() == ondraging:
            ondraging = event.get_index() # 手指点击的索引
            
            $point.set_global_position(event.position)

            if get_point_pos().length() &gt; maxLen:
                $point.set_position(get_point_pos().normalized() * maxLen)
    
    if event is InputEventScreenTounch and !event.is_pressed():
        # 松手
        set_center()
        if event.get_index() == ondraging:
            ondraing = -1

func get_point_pos():
    return $point.position

func set_center():
    # 添加缓动效果
    $Tween.interpolate_property($point, "position", get_point_pos(), Vector2(0, 0), 0.1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT)
    $Tween.start()

func get_now_pos():
    return get_point_pos().normalized()
</code></pre>
<h2 id="移动映射"><a class="header" href="#移动映射">移动映射</a></h2>
<p>获取鼠标在摇杆上的位置，可以将这个位置映射到物体的移动上</p>
<pre><code class="language-godot">extends Node2D

onready var joystick = $joystick

func _process(delta):
    $KinematicBody2D.move_and_slide(joystick.get_now_pos() * 230)

---
date: '2022-07-31'
tags: ['godot']
draft: false
---

# 将摇杆放置在按下的位置，而不是固定位置
func _input(event):
    if event is InputEventScreenTouch and event.is_pressed():
        joystick.visible = true
        joystick.position = event.position
    if event is InputEventScreenTouch and !event.is_pressed():
        joystick.visible = false
</code></pre>
<h2 id="设置"><a class="header" href="#设置">设置</a></h2>
<p>需要注意在桌面环境中需要开启<code>Emulate Touch From Mouse</code>才能够响应<code>InputEventScreenDrag</code>, <code>InputEventScreenTounch</code>触摸事件</p>
<img data-id="20240608183921" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4sll2g6j313c0smagd.jpg" alt="效果展示" /><div style="break-before: page; page-break-before: always;"></div><h1 id="如何将3d相机显示的画面展示到一个平面"><a class="header" href="#如何将3d相机显示的画面展示到一个平面">如何将3D相机显示的画面展示到一个平面</a></h1>
<img alt="显示相机内容示例" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi51mxl7hj30xg0hs0x7.jpg" data-id="20240608184803" />
<h2 id="场景搭建-3"><a class="header" href="#场景搭建-3">场景搭建</a></h2>
<h3 id="创建地板"><a class="header" href="#创建地板">创建地板</a></h3>
<img alt="3D场景创建地板" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi51zlqrcj30yi0s67a7.jpg" data-id="20240608184823" />
<p>创建MeshInstance节点，并且将Mesh属性中选择PlaneMesh，然后在工具栏中使用缩放工具将其进行放大</p>
<p>修改地板颜色，可以在节点中选择Material，创建一个材质，在材质的Albedo属性中修改颜色属性即可</p>
<h3 id="创建其他3d图形"><a class="header" href="#创建其他3d图形">创建其他3D图形</a></h3>
<p>创建MeshInstance节点，并且将Mesh属性中选择CubeMesh，创建一个立方体，然后可以根据喜好自行修改大小</p>
<img alt="3D场景示例" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi53s1vhrj31ck0q41cm.jpg" data-id="20240608185006" />
<h3 id="创建主相机"><a class="header" href="#创建主相机">创建主相机</a></h3>
<p>新建Camera3D节点，调整窗口显示位置后，选中Camera，然后点击窗口左上角的Perspective下拉菜单，选中<code>Align Transform with View</code>以及<code>Align Rotation with View</code>即可将相机固定到当前视窗的视角</p>
<img alt="快速设置相机角度" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi543aiwcj30a80nugor.jpg" data-id="20240608185024" />
<h2 id="创建辅助相机"><a class="header" href="#创建辅助相机">创建辅助相机</a></h2>
<p>将辅助相机的视图作为渲染输出到实时屏幕中，因此我们首先需要先新建一个viewport节点，viewport可以将子节点的内容输出到屏幕中渲染，然后在viewport节点下新建Camera3D节点。viewport的size属性设置为所需的大小，在这个示例中设置的是500</p>
<p>然后再新建一个Sprite3D，作为具体的输出屏幕，在该节点的Texture属性中选择ViewportTexture，将其连接到之前创建的ViewPort中</p>
<img alt="相机视图输出" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi54bqdb0j306w03gt8s.jpg" data-id="20240608185038" />
<img alt="相机视图输出运行效果" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi54lakx4j30ws0kcjvs.jpg" data-id="20240608185053" />
<p>这里可以看到进行了翻转，所以需要在Sprite3D节点中勾选<code>Flip V</code>即可正常显示</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何实现2d场景的ai寻路"><a class="header" href="#如何实现2d场景的ai寻路">如何实现2D场景的AI寻路</a></h1>
<img alt="实现效果" data-id="20240608184220" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4vp68kuj30ym0ieq49.jpg" />
<h2 id="路径绘制"><a class="header" href="#路径绘制">路径绘制</a></h2>
<img alt="路径绘制" data-id="20240608184238" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4vzz78aj309405i74t.jpg" />
<p>点击Polygon2D节点，然后在窗口上方点击添加路径按钮，开始绘制可以活动的范围，效果图如下</p>
<img alt="路径绘制效果" data-id="20240608184255" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4wb0vqdj312s0oedm3.jpg" />
<p>将<code>Polygon2D</code>创建的路径赋值给<code>NavigationPolygon</code>寻路节点, 需要在根节点<code>Navigation2D</code>节点中创建一个脚本</p>
<pre><code class="language-godot">extends Navigation2D

func _ready():
    var polygon = NavigationPolygon.new()
    var outline = $Polygon2D.polygon
    polygon.add_outline(outline)
    polygon.make_polygons_from_outlines()
    $NavigationPolygonInstance.navpoly = polygon
    set_process(false) # 暂停行为逻辑
</code></pre>
<h2 id="寻路逻辑"><a class="header" href="#寻路逻辑">寻路逻辑</a></h2>
<p>场景中的Icon节点就是需要响应鼠标事件，并且使其自动移动到目标地址</p>
<pre><code class="language-godot">extends Navigation2D

var path = []
var speed = 300

func _input(event):
    if event is InputEventMouseButton and event.is_pressed() and event.button_index == BUTTON_LEFT:
        path = get_simple_path($icon.position, get_local_mouse_position(), true) # 计算出来运动路径
        # $Polygon2D.draw_path_line(path) # 绘制出运动轨迹，具体实现看下文
        set_process(true) # 只有在有左键点击事件才恢复渲染

func _process(delta):
    var walk_speed = speed * delta
    move_to_path(walk_speed)

func move_to_path(walk_speed):
    var last_point = $icon.position
    while path.size():
        var distance_between_points = last_point.distance_to(path[0])
        if distance_between_points &gt;= 2:
            $icon.position = last_point.linear_interpolate(path[0], walk_speed/distance_between_points)
            return # 返回，等待_process执行下一次移动
        last_point = path[0]
        path.remove(0)
    # 移动到了目标路径，将最后一点的偏差直接赋值即可
    $icon.position = last_point
    set_process(false)
</code></pre>
<h2 id="绘制运动路径"><a class="header" href="#绘制运动路径">绘制运动路径</a></h2>
<p>通过脚本绘制出物体的运动轨迹</p>
<img alt="路径效果" data-id="20240608184315" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4wn6v9cj31160j2my4.jpg" />
<p>在Polygon2D上创建脚本如下</p>
<pre><code class="language-godot">extends Polygon2D

var path = []

func draw_path_line(path):
    self.path = path
    update()

func _draw():
    if path.size() &gt; 1:
        for i in range(0, path.size() - 1, 1):
            draw_line(path[i], path[i+1])
            update()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现2d物品的拖拽移动"><a class="header" href="#实现2d物品的拖拽移动">实现2D物品的拖拽移动</a></h1>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi552tja0j30mo0fmjs8.jpg" data-id="20240608185121" alt="拖拽物体实现效果" />
<h2 id="创建场景-1"><a class="header" href="#创建场景-1">创建场景</a></h2>
<p>创建Area2D节点，并在该节点下新建Sprite2D作为需要拖动的物品，将图片拖拽至sprite2D的texture中</p>
<p>为该sprite2D创建collisionShape2D节点，在collisionShape2D节点的shape属性中选择形状为方形<code>RectangleShape2D</code>，并调整大小与sprite一致</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi55bfygoj308q03ujrp.jpg" data-id="20240608185135" alt="拖拽物体节点结构" />
<h2 id="脚本编写-1"><a class="header" href="#脚本编写-1">脚本编写</a></h2>
<p>为Area2D创建脚本，脚本功能包括</p>
<ul>
<li>检测鼠标是否点击到了物体</li>
<li>将物品的位置移动到鼠标所在位置</li>
<li>为物品的点击添加偏移，点击哪个地方就以哪个地方作为移动原点</li>
</ul>
<pre><code class="language-godot">extends Area2D

var isDrag = false
var offset = Vector2.ZERO

func _process(delta):
    if isDrag:
        self.position = get_global_mouse_postion() + offset

func _input_event(viewport, event, shape_idx):
    if event is InputEventMouseButton and event.button_index == BUTTON_LEFT:
        if event.is_pressed():
            offset = self.position - get_global_mouse_position()
            isDrag = true
        else:
            isDrag = false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现2d相机的视角控制"><a class="header" href="#实现2d相机的视角控制">实现2D相机的视角控制</a></h1>
<h2 id="脚本编写-2"><a class="header" href="#脚本编写-2">脚本编写</a></h2>
<p>该示例场景比较简单，主要就是脚本对于相机视角的控制，具体代码如下</p>
<pre><code class="language-godot">extends Node2D

onready var camera = $Camera2D
var scaleNum = 2
var isDrag = fasle
var startPos = Vector2.ZERO
var startCamPos = Vector2.ZERO

func _ready():
    camera.zoom = Vector2(scaleNum, scaleNum)

func _input(event):
    if event is InputEventMouseButton:
        # 缩放操作
        if event.button_index == 4:
            startPos = Vector2.ZERO
            if scaleNum &lt;= 0.1:
                return
            elif scaleNum &gt;= 2:
                scaleNum -= 0.3
            else:
                scaleNum -= 0.1
        elif event.button_index == 5:
            startPos = Vector2.ZERO
            if scaleNum &gt;= 10:
                return
            if scaleNum &lt;= 0.3:
                scaleNum += 0.03
            elif scaleNum &gt;= 8:
                scaleNum += 0.6
            else:
                scaleNum += 0.1
        
        # 移动操作
        if event.button_index == 2 or event.button_index == 3:
            if event.is_pressed():
                isDrag = true
                startPos = event.position
                startCamPos = camera.position
            else:
                isDrag = false
                startPos = Vector2.ZERO
    
    if isDrag:
        # 只有当在非缩放才会进行移动，避免边平移边缩放导致的图片跳动
        if startPos != Vector2.ZERO:
            var offset = startPos - event.position
            camera.position = startCamPos + offset * scaleNum

func _process(delta):
    camera.zoom = lerp(camera.zoom, Vector2(scaleNum, scaleNum), 8 * delta)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现简单的2d灯光和阴影"><a class="header" href="#实现简单的2d灯光和阴影">实现简单的2D灯光和阴影</a></h1>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi55uz9v8j30w40qagqw.jpg" data-id="20240608185206" alt="效果展示" />
<h2 id="创建光源"><a class="header" href="#创建光源">创建光源</a></h2>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi564adigj308w06smxl.jpg" data-id="20240608185221" alt="效果展示" />
<p>将光源图片拖入到Light2D的texture中</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi56edc4pj30kw0cy754.jpg" data-id="20240608185238" alt="效果展示" />
<h2 id="创建阴影"><a class="header" href="#创建阴影">创建阴影</a></h2>
<p>创建一个物体, 节点如下，使用<code>LightOccluder2D</code>节点产生阴影</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi56pw061j308q044wen.jpg" data-id="20240608185256" alt="效果展示" />
<p>选择<code>LightOccluder2D</code>节点后点击屏幕，系统会提示创建一个多边形</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi56yltl7j30l20c4wgf.jpg" data-id="20240608185310" alt="效果展示" />
<p>然后选择Light2D节点，选择<code>Shadow &gt; Enabled</code>属性开启阴影效果</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi577glfpj30qw0f440u.jpg" data-id="20240608185324" alt="效果展示" />
<p><code>Light2D</code>的Shadow其他属性</p>
<ul>
<li>filter: 调整阴影边缘模式</li>
<li>filter smooth：调整阴影柔滑程度，向两边延伸的程度</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现物品拖拽与放置的功能"><a class="header" href="#实现物品拖拽与放置的功能">实现物品拖拽与放置的功能</a></h1>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi57n9lrjj30ey098t8w.jpg" data-id="20240608185350" alt="效果图" />
<h2 id="场景搭建-4"><a class="header" href="#场景搭建-4">场景搭建</a></h2>
<p>创建场景，节点如下</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi57wkhjtj308y0dq0v7.jpg" data-id="20240608185404" alt="场景图" />
<h2 id="脚本编写-3"><a class="header" href="#脚本编写-3">脚本编写</a></h2>
<p>godot内置了物品拖拽与放置功能，相关函数列表如下</p>
<blockquote>
<p>需要注意改拖拽方法只适用于继承自Control的节点</p>
</blockquote>
<ul>
<li><code>get_drag_data</code>: 当发生拖拽的时候获取的元素</li>
<li><code>set_drag_preview</code>: 拖拽之后显示的图标</li>
<li><code>can_drop_data</code>: 是否能够放置元素在这</li>
<li><code>drop_data</code>: 当放下元素后执行的操作</li>
</ul>
<p>创建一个脚本，全选PanelContainer并在Script属性栏中将Script设置为当前脚本</p>
<pre><code class="language-godot">extends PanelContainer

func get_drag_data(position):
    if has_node("Sprite"):
        var texture = TextureRect.new()
        texture.texture = $Sprite.texture
        texture.rect_scale = $Sprite.scale
        set_drag_preview(texture)
        return $Sprite
    return false

func can_drop_data(position, data):
    return true

func drop_data(position, data):
    if data and !has_node("Sprite"):
        self.add_child(data.duplicate())
        data.queue_free()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现在2d场景中显示3d物体"><a class="header" href="#实现在2d场景中显示3d物体">实现在2D场景中显示3D物体</a></h1>
<img alt="显示效果" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi58bg46rj30iq0dcdgl.jpg" data-id="20240608185428" />
<h2 id="场景搭建-5"><a class="header" href="#场景搭建-5">场景搭建</a></h2>
<img alt="3D物体" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi58laep0j306k03yaa7.jpg" data-id="20240608185444" />
<blockquote>
<p><code>viewport</code>的属性需要设置大小，以及勾选透明背景<code>Transparent Bg</code>, 选择<code>RenderTarget</code>的垂直翻转属性<code>V Flip</code>这样viewport获得的内容就是正常的</p>
</blockquote>
<p>在2D场景中渲染3D物体核心在于使用viewport，viewport可以创建一个场景的输出映射(3D物体+camera)，然后使用脚本将viewport的内容赋值给sprite即可显示出来。并且3D物体的动画也是能实时渲染到2D场景的</p>
<img alt="3D物体" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi59206ebj30vg0ew49r.jpg" data-id="20240608185509" />
<p>创建脚本设置texture</p>
<pre><code class="language-godot">extends Node2D

func _ready():
    var texture = $viewport.get_texture()
    $Sprite.texture = texture
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用鼠标拖拽来实现列表的滚动效果"><a class="header" href="#使用鼠标拖拽来实现列表的滚动效果">使用鼠标拖拽来实现列表的滚动效果</a></h1>
<img alt="使用鼠标拖拽来实现列表的滚动效果" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi59xshi6j30ng0k475r.jpg" data-id="20240608185602" />
<h2 id="场景搭建-6"><a class="header" href="#场景搭建-6">场景搭建</a></h2>
<img alt="使用鼠标拖拽来实现列表的滚动场景" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5a8nmqbj308e0fmmzp.jpg" data-id="20240608185619" />
<p>scrollContainer作为滚动容器，调整container大小</p>
<p>为scrollContainer创建子节点GridContontainer为表格，设置columns属性为任意数字，这个示例中为3</p>
<p>在GridContainer下设置PanelContainer为每一个单元格，并且设置的宽高属性<code>Min Size</code></p>
<img alt="元素搭建示意图" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5ail8o8j30l20j8dh4.jpg" data-id="20240608185633" />
<h2 id="脚本编写-4"><a class="header" href="#脚本编写-4">脚本编写</a></h2>
<p>为ScrollContainer创建脚本，监听鼠标的点击以及拖拽事件，在信号面板中创建对应的信号<code>gui_input</code></p>
<pre><code class="language-godot">extends ScrollContainer

var isDrag = false
var startPos = 0
var dragDir = 0 # 鼠标滚动方向

func _on_ScrollContainer_gui_input(event):
    if event is InputEventMouseButton and event.is_pressed():
        isDrag = true
        startPos = event.position.y
    
    if event is InputEventMouseButton and event.is_pressed():
        isDrag = false
        startPos = 0
        # 缓动效果
        var tween = Tween.new()
        add_child(tween)
        # 属性，开始值，目标值，时间，运动曲线，缓动效果
        tween.interpolate_method(self, "set_v_scroll", self.get_v_scroll(), self.get_v_scroll() + 15 * dragDir, 0.2, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT)
        # 设置回调销毁
        tween.interpolate_callback(tween, 0.2, "queue_free")
        # 开启缓动
        tween.start()
    
    if isDrag:
        var offset = event.position.y - startPos
        if offset &gt; 0:
            dragDir = -1
        elif offset &lt; 0:
            dragDir = 1
        self.set_v_scroll(self.get_v_scroll() - offset)
        startPos = event.position.y
</code></pre>
<p>现在基本功能已经完成，但是会发现当鼠标点击到GridContainer进行拖动会发现拖动事件不生效，是因为该节点在ScrollContainer的上层，他阻止了鼠标事件，需要在该节点的Mouse属性中将filter设置为Pass，这样PanelContainer以及ScrollContainer都能够监听到鼠标事件了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用pinjoint2d实现可中心旋转的物体"><a class="header" href="#使用pinjoint2d实现可中心旋转的物体">使用PinJoint2D实现可中心旋转的物体</a></h1>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5ayeszmj30sa0ig3zc.jpg" data-id="20240608185700" alt="实现效果" />
<h2 id="场景搭建-7"><a class="header" href="#场景搭建-7">场景搭建</a></h2>
<p>实现可中心旋转的物体需要用到<code>PinJoin2D</code>节点，该节点需要链接两个节点，一个中心点，一个旋转物体</p>
<p>中心点使用<code>StaticBody2D</code>与<code>CollisionShape2D</code>的组合即可</p>
<p>旋转物体可以使用<code>RigidBody2D</code>, 然后创建一个<code>Polygon2D</code>用于绘制一个多边形</p>
<p>RigidBody2D可以设置以下属性</p>
<ul>
<li>Mass: 可以用于控制旋转快慢，值越大转得越慢</li>
<li>Gravity Scale: 用于设置物体的重力</li>
</ul>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5b96e5vj30ou0fs0xm.jpg" data-id="20240608185717" alt="旋转物体" />
<p>创建一个<code>CollisionShape2D</code>为这个多边形添加碰撞体积, 使用脚本赋值</p>
<pre><code class="language-godot">extends RigidBody2D

func _ready():
    $CollisionPolygon2D.polygon = $Polygon2D.polygon
</code></pre>
<p>点击Pinjoin2D分别设置NodeA以及NodeB属性</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5bmvkivj30tw09aabk.jpg" data-id="20240608185739" alt="连接节点" />
<h2 id="创建物体来触发旋转效果"><a class="header" href="#创建物体来触发旋转效果">创建物体来触发旋转效果</a></h2>
<p>随意创建一个物体，让其落到旋转物体上测试旋转效果</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5bwabj6j306m03y74l.jpg" data-id="20240608185754" alt="人物场景" />
<blockquote>
<p>VisibilityNotifier2D可以用于当物体出屏幕外之后对其进行销毁，链接screen_exited信号</p>
</blockquote>
<pre><code class="language-godot">extends RigidBody2D

func _on_visiblityNotifier2D_screen_exited():
    queue_free()
</code></pre>
<p>接下来在主场景中加载上述物体，检测到鼠标按键之后创建一个新的物体落下</p>
<pre><code class="language-godot">extends Node2D

var cube = load("res://cube.tscn")

func _input(event):
    if event is InputEventMouseButton and event.button_index == BUTTON_LEFT and event.is_pressed():
        var c = cube.instance()
        c.position = event.position
        add_child(c)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为2d物体移动添加烟尘效果"><a class="header" href="#为2d物体移动添加烟尘效果">为2D物体移动添加烟尘效果</a></h1>
<img alt="显示效果" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5cdarnfj30he07yt94.jpg" data-id="20240608185822" />
<p>该文章内容主要包括场景的搭建，人物的移动，以及粒子系统实现烟雾效果</p>
<h2 id="场景搭建-8"><a class="header" href="#场景搭建-8">场景搭建</a></h2>
<h3 id="地板创建"><a class="header" href="#地板创建">地板创建</a></h3>
<img alt="地板创建" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5clr6egj306s04y0t2.jpg" data-id="20240608185836" />
<p><code>StaticBody2D</code>是刚体节点，在其下方创建一个<code>Polygon2D</code>拖出一个长方形作为地板，然后创建CollisionShape2D并且大小与<code>Polygon2D</code>一致，为其添加碰撞属性</p>
<h3 id="人物创建"><a class="header" href="#人物创建">人物创建</a></h3>
<img alt="人物创建" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5cz15unj306c03e74f.jpg" data-id="20240608185857" />
<p>人物移动</p>
<pre><code class="language-godot">extends KinematicBody2D

var acc = 1500
var max_speed = 400
var gravity = 800
var jump_force = 300
var fri = 10
var air_fri = 2

var move = Vector2.ZERO
var dir

func _physics_process(delta):
    if Input.is_action_pressed("ui_left"):
        dir = -1
    elfi Input.is_action_pressed("ui_right"):
        dir = 1
    else:
        dir = 0
    
    if dir != 0:
        move.x += dir * acc * delta
        move.x = clamp(move.x, -max_peed, max_speed)
        if is_on_floor():
            # 在移动并且在地面上时触发粒子
            $Particles2D.emitting = true
        else:
            $Particles2D.emitting = false
        
        # 根据移动方向设置粒子的发射角度
        if dir = 0:
            $Particles2D.rotation_degress = -25
        else:
            $Particles2D.rotation_degress = 205
    else:
        if is_on_floor():
            move.x = lerp(move.x, 0, fri*delta)
        else:
            move.x = lerp(move.x, 0, air_fri * delta)
    
    move.y += gravity * delta
    # 可以检测碰撞
    move = move_and_slde(move, Vector2.UP)
</code></pre>
<h3 id="烟雾效果"><a class="header" href="#烟雾效果">烟雾效果</a></h3>
<p>创建一个粒子节点<code>Particles2D</code>，根据下面的属性节点调整粒子的发射</p>
<ul>
<li>创建材质: Material属性，创建了材质之后在窗口就可以发现正在发射粒子</li>
<li>修改重力: Material.Gravity, 重力属性，有x、y、z，设置y为0，就不会粒子往下掉了，y为负数，则会往上发射</li>
<li>修改初速度: <code>Material.Initial Velocity</code>, 设置为一个正数，就会往右边开始发射</li>
<li>修改发射扩张角度: <code>Material.Direction.Spread</code></li>
<li>旋转发射方向: <code>Transform.Rotation Degress</code></li>
<li>图片素材: <code>Texture</code>，设置自定义的图片替换默认粒子样式，如果素材太模糊，点击素材后，选择import，设置<code>Preset</code>值为<code>2D Pixel</code>, 然后选择Reimport重新导入即可</li>
<li>添加渐变效果，在Color属性中选择线性渐变<code>GradientTexture</code>并且设置透明度即可</li>
<li>修改粒子生命周期时间: <code>Time</code>属性为整个存活时间，调整粒子速度: <code>Speed Scale</code>属性</li>
<li>使用全局坐标计算粒子位置: <code>Local Coords</code>属性，点击取消，使用全局坐标计算，移动人物的时候才不会让粒子也跟着移动</li>
<li>默认是否触发粒子: <code>Emitting</code>属性，将它取消勾选，然后在玩家移动时才发生粒子</li>
</ul>
<img alt="粒子效果" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5d9cgabj30ei0d4mxv.jpg" data-id="20240608185913" /><div style="break-before: page; page-break-before: always;"></div><h1 id="为3d物体添加一个跟随的2d物体"><a class="header" href="#为3d物体添加一个跟随的2d物体">为3D物体添加一个跟随的2D物体</a></h1>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5dmu4gjj30tq0hs40n.jpg" data-id="20240608185935" alt="实现效果" />
<h2 id="场景搭建-9"><a class="header" href="#场景搭建-9">场景搭建</a></h2>
<p>如图所示，创建MeshInstance节点并且分别设置一个地板以及球形3D物体</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5ductnuj313i0jg7fe.jpg" data-id="20240608185946" alt="实现效果" />
<p>创建camera3D并设置相机视角</p>
<h2 id="为3d物体加上2d物体"><a class="header" href="#为3d物体加上2d物体">为3D物体加上2D物体</a></h2>
<p>在MeshInstance下新建子节点，在该例子中是创建的TextureRect节点，并设置texture图片属性</p>
<p>当前状态下该2D物品并没有跟随3D物体</p>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5e4vww5j30ru0fs76h.jpg" data-id="20240608190004" alt="未跟随" />
<p>在3D节点下创建脚本来关联节点位置</p>
<pre><code class="language-godot">extends MeshInstance

func _process(delta):
    var pos = get_translation()
    var screen_pos = get_parent().get_node("Camera").unproject_position(pos)
    $TextureRect.set_position(Vector2(screen_pos.x, screen_pos.y - 130))
</code></pre>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5ef6khsj30u20j4go4.jpg" data-id="20240608190020" alt="跟随" />
<div style="break-before: page; page-break-before: always;"></div><h1 id="血条的实现"><a class="header" href="#血条的实现">血条的实现</a></h1>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5ex7m0aj30ja0dy76i.jpg" data-id="20240608190049" alt="效果展示" />
<h2 id="场景搭建-10"><a class="header" href="#场景搭建-10">场景搭建</a></h2>
<img src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5f6o7lsj30yq0ce41p.jpg" data-id="20240608190104" alt="效果展示" />
<p>只需要控制脚本，控制当前血量节点的显示与否即可</p>
<pre><code class="language-godot">extends = HBoxContainer

var heart_full = preload("res://assets/Heart_full.png")
var heart_empty = preload("res://assets/Heart_empty.png")
var heart_half = preload("res://assets/Heart_half.png")

enum TYPES {type1, type2, type3}
export (TYPES) var type = TYPES.type1

func update_heart(value):
    match type:
        TYPES.type1:
            update_type1(value)
        TYPES.type2:
            update_type2(value)
        TYPES.type3:
            update_type3(value)
    
func update_type1(value):
    for i in self.get_child_count():
        if i &lt; value:
            get_child(i).show()
        else:
            get_child(i).hide()

func update_type2(value):
    for i in self.get_child_count():
        if i &lt; value:
            get_child(i).texture = heart_full
        else:
            get_child(i).texture = heart_empty

func update_type3(value):
    for i in self.get_child_count():
        if i * 2 &lt; value - 1:
            get_child(i).texture = heart_full
        elif i * 2 == value - 1:
            get_child(i).texture = heart_half
        else:
            get_child(i).texture = heart_empty
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="用light2d实现遮罩动画"><a class="header" href="#用light2d实现遮罩动画">用Light2D实现遮罩动画</a></h1>
<img alt="实现效果" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5fh6d19j30ko0dk0tb.jpg" data-id="20240608190121" />
<h2 id="场景搭建-11"><a class="header" href="#场景搭建-11">场景搭建</a></h2>
<img alt="场景搭建" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5fpkxonj306q04gaae.jpg" data-id="20240608190134" />
<p>为Light2D添加亮光图片材质</p>
<p>设置<code>Visibility.Light Mask</code>, 将其全部关闭，这样灯光只会出现在logo上</p>
<img alt="场景搭建" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5fx1mwnj30lg0bwgn3.jpg" data-id="20240608190146" />
<p>修改Light2D的模式Mode为Mix</p>
<p>为TextureRect添加材质，选择Material，选择材质CanvasItemMaterial, 并且将Light Mode设置为Light Only，这样设置之后就只有被灯光照到的地方才会显示出来</p>
<img alt="场景搭建" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5g53svcj30hy0c60u0.jpg" data-id="20240608190159" />
<h2 id="创建动画"><a class="header" href="#创建动画">创建动画</a></h2>
<p>创建AnimationPlayer节点，新建动画</p>
<p>为Light2D的缩放大小创建关键帧，从而实现遮罩动画</p>
<img alt="动画" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi5ge8p56j30a204st99.jpg" data-id="20240608190213" /><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E7%9A%84%E7%A7%BB%E5%8A%A8.html#3d%E5%9C%BA%E6%99%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E7%9A%84%E7%A7%BB%E5%8A%A8">3D场景中如何控制物体的移动</a>
<ul>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E7%9A%84%E7%A7%BB%E5%8A%A8.html#%E5%9C%BA%E6%99%AF%E6%90%AD%E5%BB%BA">场景搭建</a>
<ul>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E7%9A%84%E7%A7%BB%E5%8A%A8.html#navigaion%E7%9A%84%E5%88%9B%E5%BB%BA">navigaion的创建</a></li>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E7%9A%84%E7%A7%BB%E5%8A%A8.html#%E6%8E%A7%E5%88%B6%E4%BA%BA%E7%89%A9%E7%9A%84%E7%A7%BB%E5%8A%A8">控制人物的移动</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3d场景中如何控制物体的移动"><a class="header" href="#3d场景中如何控制物体的移动">3D场景中如何控制物体的移动</a></h1>
<img data-id="20240608183323" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4mdyi10j30yc0kith8.jpg" alt="自动寻路" />
<h2 id="场景搭建-12"><a class="header" href="#场景搭建-12">场景搭建</a></h2>
<img data-id="20240608183345" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4mro4icj30gi0eqjtm.jpg" alt="自动寻路" />
<p>基础3D场景的搭建</p>
<h3 id="navigaion的创建"><a class="header" href="#navigaion的创建">navigaion的创建</a></h3>
<p>创建<code>Navigation3D</code>节点，然后将所有的3D场景放在这个节点下，在该节点中创建<code>NavigationMesh</code>，点击烘培导航地图</p>
<p>如果新增了3D物体，则需要重新烘培，会自动创建移动路径。只是需要注意移动的物体以及<code>Navigation3D</code>节点中Agent属性要与移动物体的碰撞体积的设置一致，否则会穿模</p>
<h3 id="控制人物的移动"><a class="header" href="#控制人物的移动">控制人物的移动</a></h3>
<p>脚本如下</p>
<blockquote>
<p>主脚本GameManager.gd，监听鼠标右键事件，然后将Unit移动到目标位置</p>
</blockquote>
<pre><code class="language-gdscript">extends Node3D

const _GROUND_MASK = 2

@onready var _camera: Camera3D = $Camera3D
@onready var _unit_target_location: UnitTargetLocation = $UnitTargetLocation
@onready var _unit: Unit = $Units/Unit

func _input(event):
	if event is InputEventMouseButton and event.pressed and event.button_index == MOUSE_BUTTON_RIGHT:
		var origin = _camera.project_ray_origin(event.position)
		var direction = _camera.project_ray_normal(event.position)
		var end = origin + direction * 1000
		var state = get_world_3d().direct_space_state
		var query_params = PhysicsRayQueryParameters3D.new()
		query_params.from = origin
		query_params.to = end
		query_params.collision_mask = _GROUND_MASK
		var intersection = state.intersect_ray(query_params)
		if intersection.size() &gt; 0:
			# we hit the ground
			var pos = intersection["position"]
			_unit_target_location.click(pos)
			_unit.move_to(pos)
</code></pre>
<blockquote>
<p>物体移动控制脚本Unit.gd</p>
</blockquote>
<pre><code class="language-godot">class_name Unit
extends CharacterBody3D

@onready var _agent: NavigationAgent3D = $NavigationAgent3D

var movement_target: Vector3:
	get:
		return _agent.target_position
	set(value):
		_agent.target_position = value

func _ready():
	# These values need to be adjusted for the actor's speed
	# and the navigation layout.
	_agent.path_desired_distance = 0.5
	_agent.target_desired_distance = 0.5
   
	# Make sure to not await during _ready.
	call_deferred("actor_setup")

func actor_setup() -&gt; void:
	await get_tree().physics_frame
	movement_target = global_position

func move_to(pos: Vector3) -&gt; void:
	movement_target = pos

func _physics_process(delta: float) -&gt; void:
	if _agent.is_navigation_finished():
		return
   
	var current_agent_position = global_position
	var next_path_position = _agent.get_next_path_position()
	var new_velocity = (next_path_position - current_agent_position).normalized()
	new_velocity *= _agent.max_speed
	velocity = new_velocity
	move_and_slide()
   
	if (next_path_position - current_agent_position).length_squared() &gt; 0.01:
		look_at(next_path_position, Vector3.UP)
</code></pre>
<blockquote>
<p>目标点光标控制脚本</p>
</blockquote>
<pre><code class="language-godot">class_name UnitTargetLocation
extends Node3D

@onready var _anim: AnimationPlayer = $AnimationPlayer

func _ready():
   # initialize to transparent colors everywhere
   var m: ShaderMaterial = $Mesh.get_active_material(0)
   m.set_shader_parameter("radius", 0.01)

func click(position: Vector3):
   global_position = position + Vector3.UP * 0.02
   _anim.play("UnitTargetLocation")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%89%A9%E4%BD%93%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF.html#3d%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%89%A9%E4%BD%93%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF">3D场景中物体的自动寻路</a>
<ul>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%89%A9%E4%BD%93%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF.html#%E5%9C%BA%E6%99%AF%E6%90%AD%E5%BB%BA">场景搭建</a></li>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%89%A9%E4%BD%93%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF.html#3d%E8%A7%92%E8%89%B2">3D角色</a>
<ul>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%89%A9%E4%BD%93%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF.html#%E6%9D%90%E8%B4%A8%E7%BC%96%E5%86%99">材质编写</a></li>
<li><a href="godot4/3D%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%89%A9%E4%BD%93%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AF.html#%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6">运动控制</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3d场景中物体的自动寻路"><a class="header" href="#3d场景中物体的自动寻路">3D场景中物体的自动寻路</a></h1>
<img data-id="20240608183410" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4n7h8m8j313g0jigqo.jpg" alt="自动寻路" />
<h2 id="场景搭建-13"><a class="header" href="#场景搭建-13">场景搭建</a></h2>
<img data-id="20240608183428" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4nij3agj30da0diac0.jpg" alt="自动寻路" />
<p>上述BASE节点下分别为相机、灯光、与地板</p>
<p>在地板中添加材质, 设置路径<code>Mesh属性 -&gt; Material</code></p>
<pre><code class="language-godot">[gd_resource type="StandardMaterial3D" load_steps=2 format=2]

[ext_resource path="res://.../grid.png" type="Texture2D" id=1]

[resource]
albedo_texture = ExtResource( 1 )
uv1_scale = Vector3( 10, 10, 1 )

</code></pre>
<p>然后创建<code>Path3D</code>以及<code>PathFollow3D</code>以及角色模型(一个简单的柱体和球体)</p>
<h2 id="3d角色"><a class="header" href="#3d角色">3D角色</a></h2>
<img data-id="20240608183459" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4o2fp6aj316w0fsh4b.jpg" alt="角色模型" />
<h3 id="材质编写"><a class="header" href="#材质编写">材质编写</a></h3>
<p>分别在Body、Head中加入材质，设置Geometry属性，创建tres文件, 这里将物体控制为红色</p>
<pre><code class="language-godot">[gd_resource type="StandardMaterial3D" format=2]

[resource]
albedo_color = Color( 1, 0, 0, 1 )
</code></pre>
<h3 id="运动控制"><a class="header" href="#运动控制">运动控制</a></h3>
<p>在<code>Path3D</code>的属性面板中，新建Curve3D，然后在主窗口上方的菜单栏选择路径节点创建按钮，绘制运动路径</p>
<img data-id="20240608183519" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4oe9dulj30dq03kdgh.jpg" alt="路径创建" />
<p>最后在character上创建运动脚本,根据父节点中的运动路径创建一个位置列表，然后定时的将人物移动到该节点位置</p>
<pre><code class="language-godot">extends Node

@export var waypoint_check_distance: float = 0.1
@export var total_loop_time: float = 5.0

var _path_follow: PathFollow3D
var _waypoint_timer: Timer
var _waypoint_positions: PackedVector3Array
var _current_path_time: float
var _current_waypoint_index: int
var _next_waypoint_index: int
var _moving: bool

func _ready() -&gt; void:
	_path_follow = get_parent() as PathFollow3D
	_waypoint_timer = get_node("WaypointTimer") as Timer
	
	var path_curve: Curve3D = _path_follow.get_parent().curve
	var n_waypoints: int = path_curve.get_point_count()
	_waypoint_positions = PackedVector3Array()
	for i in range(n_waypoints - 1):
		_waypoint_positions.append(path_curve.get_point_position(i))
	
	_current_waypoint_index = 0
	_next_waypoint_index = 1
	_moving = true

func _process(delta: float) -&gt; void:
	if _moving:
		_current_path_time += delta
		_path_follow.progress_ratio = _current_path_time / total_loop_time
		
		var d = (_waypoint_positions[_next_waypoint_index] - _path_follow.position).length()
		if d &lt; waypoint_check_distance:
			_current_waypoint_index = _next_waypoint_index
			_next_waypoint_index = (_current_waypoint_index + 1) % _waypoint_positions.size()
			_waypoint_timer.start()
			_moving = false

func _on_waypoint_timer_timeout() -&gt; void:
	_moving = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot4/3D%E5%9F%BA%E7%A1%80%E5%9C%BA%E6%99%AF%E7%9A%84%E6%90%AD%E5%BB%BA.html#3d%E5%9F%BA%E7%A1%80%E5%9C%BA%E6%99%AF%E7%9A%84%E6%90%AD%E5%BB%BA">3D基础场景的搭建</a>
<ul>
<li><a href="godot4/3D%E5%9F%BA%E7%A1%80%E5%9C%BA%E6%99%AF%E7%9A%84%E6%90%AD%E5%BB%BA.html#%E5%9C%BA%E6%99%AF%E6%90%AD%E5%BB%BA">场景搭建</a>
<ul>
<li><a href="godot4/3D%E5%9F%BA%E7%A1%80%E5%9C%BA%E6%99%AF%E7%9A%84%E6%90%AD%E5%BB%BA.html#%E5%9F%BA%E7%A1%80%E5%9C%BA%E6%99%AF">基础场景</a></li>
<li><a href="godot4/3D%E5%9F%BA%E7%A1%80%E5%9C%BA%E6%99%AF%E7%9A%84%E6%90%AD%E5%BB%BA.html#%E7%90%83%E4%BD%93%E5%88%9B%E5%BB%BA">球体创建</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3d基础场景的搭建"><a class="header" href="#3d基础场景的搭建">3D基础场景的搭建</a></h1>
<img data-id="20240608183544" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4otu5hej311e0iiqru.jpg" alt="3D场景" />
<p>在3D场景中，比较常用到的是<code>RigidBody3D</code>以及<code>CollisionShape3D</code>、<code>Mesh</code>节点，作用如下</p>
<p><code>RigidBody3D节点</code></p>
<ul>
<li>它是一种3D物理体,用于模拟刚体物体在物理世界中的行为。</li>
<li>可以对其应用力、阻力、冲量等,使其受到重力、碰撞等物理效果的影响。</li>
<li>通常用于模拟掉落、弹跳、滚动等情况,为游戏增加真实感。</li>
</ul>
<p><code>StaticBody3D节点</code></p>
<ul>
<li>StaticBody3D可以与其他刚体(RigidBody)或运动体(CharacterBody)进行碰撞检测和响应。</li>
<li>自身不会受到物理作用力的影响,保持静止状态。其他物体在与它碰撞时,会产生相应的物理反应,如弹rebond和滚动等。</li>
<li>通常用于表示地形、建筑物、障碍物等静态元素。</li>
<li>由于StaticBody3D不需要计算运动学方程,所以相比RigidBody更高效,在需要大量静态物体的场景中,使用StaticBody3D可以减少CPU计算开销。</li>
</ul>
<p><code>CollisionShape3D节点</code></p>
<ul>
<li>它定义了一个3D碰撞体的形状,通常附加在RigidBody3D等物理对象上。</li>
<li>可以设置为各种形状,如球体、盒体、胶囊体等,用于检测碰撞。</li>
<li>确保物体在物理模拟中正确地相互作用和响应碰撞。</li>
</ul>
<p><code>Mesh节点</code></p>
<ul>
<li>它用于渲染3D模型网格,决定了3D对象在场景中的可视外观。</li>
<li>可以加载各种3D模型文件(.obj、.fbx等),也可以通过代码程序动态生成。</li>
<li>通过设置材质、纹理等,可以控制Mesh的渲染效果。</li>
</ul>
<h2 id="场景搭建-14"><a class="header" href="#场景搭建-14">场景搭建</a></h2>
<img data-id="20240608183603" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4p5bj3pj30ci0g0go9.jpg" alt="3D场景" />
<h3 id="基础场景"><a class="header" href="#基础场景">基础场景</a></h3>
<p>这里的地板使用的是staticbody3D节点，用于设置与球体的碰撞</p>
<p>在<code>Physics Material Override</code>属性中新建一个tres文件，并且设置弹力为0.7(值越大弹力越大)</p>
<p>创建好地板与灯光，然后创建球体，运行就能发现所有的物理属性都存在了，重力，碰撞，弹力等</p>
<h3 id="球体创建"><a class="header" href="#球体创建">球体创建</a></h3>
<img data-id="20240608183618" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4pf4nqwj30d007eab7.jpg" alt="3D场景" />
<p>设置<code>MeshInstance3D</code>的Mesh属性为sphereshape3D，并且在下方的<code>Surface Material Override</code>中新建<code>StandardMaterial3D</code>tres, 并且在对应的Albedo中设置物体颜色</p>
<p>设置<code>CollisionShape3D</code>的Shape属性，为sphereshape属性，为节点添加碰撞体</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot4/%E5%A6%82%E4%BD%95%E5%B0%86godot3%E9%A1%B9%E7%9B%AE%E8%BD%AC%E4%B8%BAgodot4.html#%E5%A6%82%E4%BD%95%E5%B0%86godot3%E9%A1%B9%E7%9B%AE%E8%BD%AC%E4%B8%BAgodot4">如何将godot3项目转为godot4</a></li>
</ul>
<h1 id="如何将godot3项目转为godot4"><a class="header" href="#如何将godot3项目转为godot4">如何将godot3项目转为godot4</a></h1>
<ul>
<li><code>onready</code>修改为<code>@onready</code></li>
<li><code>export</code>修改为<code>@export</code></li>
</ul>
<pre><code class="language-gdscript"># 如果变量后面是 := 那么就需要定义get或者set，如果是 = 就不需要定义
@export var detail := 0  :
	set = set_tileset
    get = get_tileset
</code></pre>
<ul>
<li>枚举值修改为<code>@export_enum(...) var v: String = ""</code></li>
<li>tween节点使用<code>create_tween()</code>进行创建</li>
<li><code>yield</code>改为<code>await</code></li>
<li>信号的连接改为<code>signala.connect(funca)</code></li>
<li>时间的获取</li>
</ul>
<pre><code class="language-gdscript"># 修改前
var d = OS.get_datetime()
d.erase("dst")
var s = ""

for i in (d.values()):
    s += str(i) + " "

# 修改后
var time = Time.get_datetime_dict_from_system()
time.erase("dst") # 删除夏令时标志

var datetime_string := ""
for value in time.values():
    datetime_string += str(value) + " "

print(datetime_string)
</code></pre>
<ul>
<li>Engine相关</li>
</ul>
<pre><code class="language-gdscript">
# 修改前
func set_iterations(arg := iterations):
	iterations = max(1, arg)
	Engine.iterations_per_second = iterations

func set_target_fps(arg := target_fps):
	target_fps = abs(arg)
	#print("target_fps: ", target_fps)
	Engine.target_fps = target_fps
    
# 修改后
func set_iterations(arg := iterations):
    iterations = max(1, arg)
    ProjectSettings.set_setting("physics/iterations_per_second", iterations)

func set_target_fps(arg := target_fps):
    target_fps = abs(arg)
    ProjectSettings.set_setting("display/window/target_fps", target_fps)
</code></pre>
<ul>
<li><code>MainLoop.NOTIFICATION_WM_QUIT_REQUEST</code>修改为``</li>
<li>文件操作相关, <code>File</code>修改为<code>FileAccess</code>, <code>Dir</code>修改为<code>DirAccess</code></li>
<li><code>PoolVector2Array</code>修改为<code>PackedVector2Array</code></li>
<li><code>update()</code>修改为<code>queue_redraw()</code>方法，重新绘制</li>
<li><code>deg2rad</code>修改为<code>deg_to_rad</code></li>
<li><code>color.white</code>修改修改为<code>color.WHITE</code>，所有颜色名称都变成大写了</li>
<li><code>extends VisibilityNotifier2D</code>修改为<code>extends VisibleOnScreenNotifier2D</code></li>
<li><code>Engine.editor_hint</code>修改为<code>Engine.is_editor_hint()</code></li>
<li><code>KinematicBody2D</code>修改为<code>CharacterBody2D</code></li>
<li><code>Sprite</code>修改为<code>Sprite2D</code></li>
<li><code>stepify</code>修改为<code>snapped</code></li>
<li><code>InputMap.get_action_list</code>修改为<code>InputMap.action_get_events</code></li>
<li><code>set_shader_param</code>修改为<code>set_shader_parameter</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot4/%E4%BD%BF%E7%94%A8shader%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E9%9C%87%E5%8A%A8%E6%95%88%E6%9E%9C.html#%E4%BD%BF%E7%94%A8shader%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E9%9C%87%E5%8A%A8%E6%95%88%E6%9E%9C">使用shader实现屏幕震动效果</a>
<ul>
<li><a href="godot4/%E4%BD%BF%E7%94%A8shader%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E9%9C%87%E5%8A%A8%E6%95%88%E6%9E%9C.html#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3">代码详解</a></li>
</ul>
</li>
</ul>
<h1 id="使用shader实现屏幕震动效果"><a class="header" href="#使用shader实现屏幕震动效果">使用shader实现屏幕震动效果</a></h1>
<img data-id="20240608183709" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4qbh6ncj30vw0hrkbn.jpg" alt="shader屏幕震动效果示例" />
<h2 id="代码详解"><a class="header" href="#代码详解">代码详解</a></h2>
<pre><code class="language-python">shader_type canvas_item; # 着色器类型
uniform float ShakeStrength = 0; # 用于控制抖动强度。初始值为0,即不抖动。
uniform vec2 FactorA  = vec2(100.0,100.0); # 影响抖动的频率
uniform vec2 FactorB  = vec2(1.0,1.0); # 影响抖动的相位
uniform vec2 magnitude = vec2(0.01,0.01); # 用于控制抖动的幅度
uniform sampler2D SCREEN_TEXTURE : hint_screen_texture, filter_linear_mipmap; # 定义了一个统一采样器。hint_screen_texture指定这个纹理是屏幕纹理。

# 像素着色器的主要函数
void fragment() {
    vec2 uv = SCREEN_UV; # 获取当前像素的UV纹理坐标
	uv -= 0.5;
    uv *= 1.0 - 2.0 * magnitude.x;
    uv += 0.5; # 这些操作将UV坐标从[0,1]范围映射到[-magnitude.x, 1+magnitude.x]范围。
	vec2 dt = vec2(0.0, 0.0); # 初始化偏移量向量
	dt.x = sin(TIME * FactorA.x+FactorB.x) * magnitude.x; # 计算X方向的偏移量。
	dt.y = cos(TIME *FactorA.y+ FactorB.y) * magnitude.y; # 计算Y方向的偏移量。
	COLOR = texture(SCREEN_TEXTURE,uv + (dt*ShakeStrength)); # 从屏幕纹理中采样颜色,采样的UV坐标为原始UV坐标加上由抖动偏移量和抖动强度计算得到的偏移。
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="godot4/%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E5%8A%9F%E8%83%BD.html#%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E5%8A%9F%E8%83%BD">实现抽奖功能</a>
<ul>
<li><a href="godot4/%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E5%8A%9F%E8%83%BD.html#ui%E6%8B%86%E8%A7%A3">UI拆解</a></li>
<li><a href="godot4/%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E5%8A%9F%E8%83%BD.html#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">功能实现</a></li>
</ul>
</li>
</ul>
<h1 id="实现抽奖功能"><a class="header" href="#实现抽奖功能">实现抽奖功能</a></h1>
<p><img data-id="yaohu_thumb"
src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hsvfeai0oej30hi0o049g.jpg"/></p>
<h2 id="ui拆解"><a class="header" href="#ui拆解">UI拆解</a></h2>
<p>分为装饰性以及功能性UI两种，都是比较容易绘制的</p>
<p>直接截图并对其进行临摹，这里就不展示具体的绘制过程了，下面主要讲解功能性代码的实现</p>
<h2 id="功能实现"><a class="header" href="#功能实现">功能实现</a></h2>
<p>大概流程如下:</p>
<ul>
<li>
<p>转盘包含8个内容，这种奖励都是固定的，可以直接固定</p>
</li>
<li>
<p>点击开始抽奖按钮</p>
</li>
<li>
<p>播放转盘转动动画</p>
</li>
<li>
<p>使用一个随机函数确定最终奖励位置</p>
</li>
<li>
<p>获得奖励并且提示</p>
</li>
</ul>
<pre><code class="language-godot">extends Node2D

@onready var board: AnimatedSprite2D = $board

var curr_frame = -1

func _ready() -&gt; void:
	pass

func _process(delta: float) -&gt; void:
	if curr_frame == -1 or not board.is_playing():
		return
	
	if board.frame == curr_frame:
		print("抽奖完成")
		curr_frame = -1
		board.pause()


func _on_draw_pressed() -&gt; void:
	board.frame = 0
	board.play("default")
	await get_tree().create_timer(1.5).timeout
	curr_frame = randi_range(0, 7)
</code></pre>
<img data-id="yaohu_redraw_1" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hsvjdj3ms0j30j20qqgqc.jpg"/>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%A0%B8%E5%BF%83%E5%88%9B%E6%84%8F%E4%B8%89%E8%A6%81%E7%B4%A0.html#%E6%A0%B8%E5%BF%83%E5%88%9B%E6%84%8F%E4%B8%89%E8%A6%81%E7%B4%A0">核心创意三要素</a>
<ul>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%A0%B8%E5%BF%83%E5%88%9B%E6%84%8F%E4%B8%89%E8%A6%81%E7%B4%A0.html#%E4%B8%BB%E9%A2%98">主题</a></li>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%A0%B8%E5%BF%83%E5%88%9B%E6%84%8F%E4%B8%89%E8%A6%81%E7%B4%A0.html#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%A0%B8%E5%BF%83%E5%88%9B%E6%84%8F%E4%B8%89%E8%A6%81%E7%B4%A0.html#%E7%B3%BB%E7%BB%9F">系统</a></li>
</ul>
</li>
</ul>
<h1 id="核心创意三要素"><a class="header" href="#核心创意三要素">核心创意三要素</a></h1>
<img data-id="20240608183000" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4ix544aj30te0hs40c.jpg" alt="核心创意三要素" />
<h2 id="主题"><a class="header" href="#主题">主题</a></h2>
<p><strong>以什么题材来做游戏</strong></p>
<p>“比方说“在天上飞让人觉得舒服”，这里“飞行”就是主题。以此为例，请各位通过“飞行”二字进行联想，把联想到的事物尽可能多地罗列出来。喷气机、鸟、热气球、气球、跳伞、魔女的扫帚、直升机、魔毯、天使、苍蝇、飘落的花瓣、蝴蝶……相信各位和我一样，能联想到很多东西，而且不同人想到的东西也不一样。对于“飞行”，人们很难有一个统一的印象。</p>
<p>但是“飞行”一词用作主题太过宽泛，需要进一步缩小范围。缩小范围的方法有很多，可以是“喷气机”“鸟”等具体事物，可以是“滑翔伞”“跳台滑雪”等竞技项目，可以是“连续按键”“触摸手机屏幕”等操作，甚至可以是“拍打翅膀”“飘浮”等动词。</p>
<p>总之，一切事物皆可成为游戏的主题。不过，单有主题并不能构成创意，它还需要另一个要素——概念。”</p>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p><strong>概念是指让玩家玩什么</strong></p>
<p>“概念明确了主题中（或是与主题相关联的元素中）哪一部分是“拿来给玩家玩的”，简而言之就是对“这是一款玩什么的游戏”的一个定义。比如要为玩家提供什么样的体验，带来怎样的游戏感受，产生何种情感共鸣等。”</p>
<p>“现在假设主题为“棒球”。选定概念，就是从棒球的大量趣味元素中选出一部分进行重点渲染。它可以是击球，可以是投球，可以是防守，甚至可以淡化选手这一方面，让玩家当教练坐镇指挥。着眼点不同，概念也会有很大不同。
“挖掘”“吃”等动词类主题也是一样，我们要考虑将该动作的某一阶段拿出来着重刻画。以“挖掘”为例，刻画大刀阔斧穿山钻地的畅快感与刻画危矿中如履薄冰的紧张感就是两种完全不同的概念。”</p>
<p>“还要注意，单有抽象的语言并不能构成概念。就像单凭“飞行”和“让玩家享受在空中自由飞行的感觉”这一对主题与概念无法构成游戏一样。
空中飞行舒服在哪里？“悬空感”“俯瞰风景”“俯冲”“迎合气流而动”“巧妙运用翅膀”“超音速飞行”都是切入点。这些切入点用作创意时一定要足够新颖才行。”</p>
<h2 id="系统"><a class="header" href="#系统">系统</a></h2>
<p><strong>如何频繁呈现出好玩的内容</strong></p>
<p>“一个好的创意，应该让玩家随着一次次“舒服”的体验不断接近游戏目标，所以我们需要在游戏中不断触发这种体验。”</p>
<ul>
<li>什么样的机制或规则能实现这一目的</li>
<li>什么样的操作方式能实现这一目的</li>
<li>什么样的表现手法能实现这一目的</li>
</ul>
<p>“只有能稳定带来概念中所述的体验，且能频繁触发该体验以达到概念所追求之效果的实现手段（机制、操作方式、表现手法等），才称得上合格的系统。”</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%A0%B8%E5%BF%83%E5%88%9B%E6%84%8F%E6%80%9D%E8%B7%AF.html#%E6%A0%B8%E5%BF%83%E5%88%9B%E6%84%8F%E6%80%9D%E8%B7%AF">核心创意思路</a></li>
</ul>
<h1 id="核心创意思路"><a class="header" href="#核心创意思路">核心创意思路</a></h1>
<img data-id="20240608183100" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4k36w89j30t20fy78a.jpg" alt="核心创意的思路" />
<ul>
<li>不以现有游戏为原型</li>
<li>不以类型为出发点</li>
<li>先在脑子里跑跑看</li>
<li>一个创意不要思考太久</li>
<li>创意是否会带来全新体验</li>
<li>逆向思维</li>
<li>有些创意必须有视觉效果支持</li>
</ul>
<p>所有创意都是为了实现概念服务的</p>
<p>开工之前需要考虑单凭手中的创意能够作出一款游戏吗。“一款拿来卖的游戏产品需要更长的游戏寿命。这就要求有更多的创意，也就是要以核心创意为核心，再添加多个扩充核心的创意。”</p>
<p>如果一个创意只能派生出一两个创意，表明它不足以成为核心创意。好的创意能够让听者立刻在脑海中产生画面与节奏，接着大量创意就会如泉涌般随之而来。</p>
<p><strong>核心创意太弱会导致创意内容不足，使得一款游戏存在多个小核心。然后每个小核心又会派生一些创意来扩充它们自己，到头来游戏就会成为一盘散沙</strong></p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E6%B8%B8%E6%88%8F%E8%8A%82%E5%A5%8F.html#%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E6%B8%B8%E6%88%8F%E8%8A%82%E5%A5%8F">如何考虑游戏节奏</a>
<ul>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E6%B8%B8%E6%88%8F%E8%8A%82%E5%A5%8F.html#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
</ul>
<h1 id="如何考虑游戏节奏"><a class="header" href="#如何考虑游戏节奏">如何考虑游戏节奏</a></h1>
<img data-id="20240608183127" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4kkjapuj30z40hwjuq.jpg" alt="核心创意与节奏的关系" />
<ul>
<li>最合适的节奏</li>
<li>节奏的关键元素</li>
<li>操作感与节奏</li>
<li>任何创意都有它的节奏</li>
</ul>
<h2 id="示例"><a class="header" href="#示例">示例</a></h2>
<p>“游戏的主人公只能向上爬一个方块，所以遇到上图的情况时完全无法继续前进，也就是我们俗称的“卡死了”。要知道，这款游戏起初是面向街机开发的，玩家花钱投了币却遇到“卡死”，这对游戏而言是致命的。最终铁块的设计被放弃，取而代之的是×标方块。×标方块需要挖掘 5 次才能打穿。然而问题又来了，对于手速足够快的玩家来说，挖 1 次和挖 5 次在时间上没有太大区别。</p>
<p>于是创作者又给×标方块添加了“挖穿后消耗 20% 氧气”的机制。这让玩家开始衡量挖穿（消耗 20% 氧气）与绕路（被压死）的风险，使得更多人选择绕开×标方块掘进。</p>
<p>该游戏第一个试玩版本只有一个无尽关卡，玩家要用三次机会挑战深度极限。后来创作者发现一直保持紧张感会使游戏变得严肃，中间夹杂些喘息的空间“反而更让人舒服，便在每 100 米设置了一个中断点。</p>
<p>中断点的设计给游戏创造了节奏，使玩的过程有张有弛，还让玩家有了一步步前进的成就感。此外，抵达中断点的瞬间，头顶上所有方块会被一次性消除，所以当玩家面临大量崩落的方块时，只要能在被压死前冲到 100 米处，就能化险为夷。这又一次扩充了游戏的不确定性，使玩家在游戏中产生诸如“最后关头居然挺过来了！”“可惜差那么一点！”的喜怒哀乐。”</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html#%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">游戏设计的基本原理</a>
<ul>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html#%E6%B8%B8%E6%88%8F%E5%88%9B%E6%96%B0%E5%8E%9F%E7%90%86">游戏创新原理</a></li>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html#%E6%B8%B8%E6%88%8F%E5%88%9B%E4%BD%9C%E5%8E%9F%E7%90%86">游戏创作原理</a></li>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html#%E6%B8%B8%E6%88%8F%E5%B9%B3%E8%A1%A1%E5%8E%9F%E7%90%86">游戏平衡原理</a></li>
<li><a href="%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E5%8E%9F%E7%90%86">解决问题原理</a></li>
</ul>
</li>
</ul>
<h1 id="游戏设计的基本原理"><a class="header" href="#游戏设计的基本原理">游戏设计的基本原理</a></h1>
<img data-id="20240608183213" src="https://cdn.ipfsscan.io/weibo/large/005ZoLfCgy1hqi4lcvcf0j30ym0ietf5.jpg" alt="游戏设计基本原理" />
<h2 id="游戏创新原理"><a class="header" href="#游戏创新原理">游戏创新原理</a></h2>
<ul>
<li>游戏的对称性/非对称性和同步性</li>
<li>A最大，鬼万能</li>
<li>巴特尔的玩家分类理论</li>
<li>合作与对抗</li>
<li>公平</li>
<li>反馈循环</li>
<li>加德纳的多元智能理论</li>
<li>霍华德的隐匿性游戏设计法则</li>
<li>信息</li>
<li>科斯特的游戏理论</li>
<li>拉扎罗的四种关键趣味元素</li>
<li>魔法圈</li>
<li>采取行动</li>
<li>MDA：游戏的机制、运行和体验</li>
<li>记忆和技巧</li>
<li>极小极大和极大极小</li>
<li>纳什均衡</li>
<li>帕累托最优</li>
<li>得益</li>
<li>囚徒困境</li>
<li>解谜游戏的设计</li>
<li>石头剪刀布</li>
<li>7种通用情感</li>
<li>斯金纳箱</li>
<li>社会关系</li>
<li>公地悲剧</li>
<li>信息透明</li>
<li>范登伯格的大五人格游戏理论</li>
<li>志愿者困境</li>
</ul>
<h2 id="游戏创作原理"><a class="header" href="#游戏创作原理">游戏创作原理</a></h2>
<ul>
<li>80/20法则</li>
<li>头脑风暴的方法</li>
<li>消费者剩余</li>
<li>核心游戏循环</li>
<li>定义问题</li>
<li>委员会设计</li>
<li>环境叙事</li>
<li>体验设计</li>
<li>心流</li>
<li>4种创意方法</li>
<li>游戏体裁</li>
<li>游戏的核心</li>
<li>游戏中的“约定俗成” 原理43 格式塔</li>
<li>补充规则</li>
<li>迭代</li>
<li>魔杖</li>
<li>超游戏思维</li>
<li>对象，属性，状态</li>
<li>吸引注意力的方法</li>
<li>纸上原型</li>
<li>三选二:快速，便宜，优质 原理52 游戏测试</li>
<li>解决问题的障碍</li>
<li>原型</li>
<li>风险评估</li>
<li>供需关系</li>
<li>协同效应</li>
<li>主题</li>
<li>时间和金钱</li>
<li>以用户为中心的设计 原理61 路径指示</li>
</ul>
<h2 id="游戏平衡原理"><a class="header" href="#游戏平衡原理">游戏平衡原理</a></h2>
<ul>
<li>成瘾途径</li>
<li>注意与感知</li>
<li>平衡和调试</li>
<li>细节</li>
<li>加倍和减半</li>
<li>规模经济</li>
<li>玩家的错误</li>
<li>不被惩罚的错误 原理70 希克定律</li>
<li>兴趣曲线</li>
<li>学习曲线</li>
<li>损失规避</li>
<li>马斯洛需求层次理论 原理75 最小/最大化</li>
<li>惩罚 原理77 沙盒与导轨 原理78 持续注意力 原理79 可变奖励</li>
</ul>
<h2 id="解决问题原理"><a class="header" href="#解决问题原理">解决问题原理</a></h2>
<ul>
<li>先行组织者</li>
<li>功能可见性暗示</li>
<li>巴斯特原则</li>
<li>认知偏差</li>
<li>占优策略</li>
<li>菲兹定律</li>
<li>基本归因错误</li>
<li>黄金比例</li>
<li>破坏者</li>
<li>前期宣传</li>
<li>即时满足与延迟满足</li>
<li>别让我思考——克鲁克的可用性第一定律 原理92 音乐与多巴胺</li>
<li>节奏</li>
<li>解决问题的方法</li>
<li>满意与优化</li>
<li>成就感</li>
<li>空间感知</li>
<li>时间膨胀</li>
<li>工作记忆</li>
<li>零和博弈</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>讲解shader原理，以及shader实战</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>TODO</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./theme/style.js"></script>
        <script src="clarity.js"></script>
        <script src="./theme/highlight.js"></script>

        <script>
            window.addEventListener('load', function () {
                window.setTimeout(window.print, 100);
            });
        </script>

    </div>
</body>

</html>