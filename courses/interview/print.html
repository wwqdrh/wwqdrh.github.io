<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title></title>
    <meta name="robots" content="noindex">


    <!-- Custom HTML head -->
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="./theme/style.css">
    <link rel="stylesheet" href="./theme/mdbook-admonish.css">

</head>

<body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">面试指南</a></li><li class="chapter-item expanded "><a href="数据结构与算法/index.html"><strong aria-hidden="true">1.</strong> 数据结构与算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="数据结构与算法/题库/index.html"><strong aria-hidden="true">1.1.</strong> 题库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="数据结构与算法/题库/剑指offer1.html"><strong aria-hidden="true">1.1.1.</strong> 剑指offer1</a></li><li class="chapter-item expanded "><a href="数据结构与算法/题库/剑指offer2.html"><strong aria-hidden="true">1.1.2.</strong> 剑指offer2</a></li><li class="chapter-item expanded "><a href="数据结构与算法/题库/剑指offer3.html"><strong aria-hidden="true">1.1.3.</strong> 剑指offer3</a></li><li class="chapter-item expanded "><a href="数据结构与算法/题库/剑指offer4.html"><strong aria-hidden="true">1.1.4.</strong> 剑指offer4</a></li></ol></li><li class="chapter-item expanded "><a href="数据结构与算法/短链系统设计.html"><strong aria-hidden="true">1.2.</strong> 短链系统设计</a></li></ol></li><li class="chapter-item expanded "><a href="c++/index.html"><strong aria-hidden="true">2.</strong> c++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c++/引用变量.html"><strong aria-hidden="true">2.1.</strong> 引用变量</a></li><li class="chapter-item expanded "><a href="c++/什么是虚函数.html"><strong aria-hidden="true">2.2.</strong> 什么是虚函数</a></li><li class="chapter-item expanded "><a href="c++/什么是指针.html"><strong aria-hidden="true">2.3.</strong> 什么是指针</a></li><li class="chapter-item expanded "><a href="c++/如何保证并发安全.html"><strong aria-hidden="true">2.4.</strong> 如何保证并发安全</a></li><li class="chapter-item expanded "><a href="c++/常见对象的内存结构.html"><strong aria-hidden="true">2.5.</strong> 常见对象的内存结构</a></li><li class="chapter-item expanded "><a href="c++/stl容器库.html"><strong aria-hidden="true">2.6.</strong> stl容器库</a></li></ol></li><li class="chapter-item expanded "><a href="linux操作系统/index.html"><strong aria-hidden="true">3.</strong> linux操作系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="linux操作系统/资源管理.html"><strong aria-hidden="true">3.1.</strong> 资源管理</a></li><li class="chapter-item expanded "><a href="linux操作系统/网络配置.html"><strong aria-hidden="true">3.2.</strong> 网络配置</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function (e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="https://space.bilibili.com/538676331" target="_blank" title="B站" aria-label="B站">
                            B站
                        </a>
                        <a href="/" target="_blank" title="home" aria-label="Git repository">
                            <i id="git-home" class="fa fa-home"></i>
                        </a>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wwqdrh/interview-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h1 id="interview"><a class="header" href="#interview">interview</a></h1>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h1 id="剑指offer"><a class="header" href="#剑指offer">剑指offer</a></h1>
<blockquote>
<p>题库链接: https://leetcode.cn/problem-list/e8X3pBZi/</p>
</blockquote>
<h2 id="整数除法"><a class="header" href="#整数除法">整数除法</a></h2>
<p><code>剑指 Offer II 001. 整数除法</code></p>
<p>给定整数a、b，求得商的结果</p>
<p>条件:</p>
<p>1、不能使用除法、取余数等运算
2、只能存储32位有符号整数(范围是[-2^31,2^31-1])，如果溢出了就返回<code>2^31-1</code></p>
<p><code>解法</code></p>
<ul>
<li>处理边界条件，当a是最小值，判断b是1或者-1；当b是最小值，a是最小值则为1，其他都为0</li>
<li>使用二分法+快速乘来判断是否满足</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-0', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-0-cpp">cpp</option><option value="code-example-tab-0-go">go</option></select></div>
<div id="code-example-tab-0-cpp" class="code-example-tab-0"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;
<em></em>
using namespace std;
<em></em>
// 快速乘
// x 和 y 是负数，z 是正数
// 判断 z * y &gt;= x 是否成立
bool quickAdd(int y, int z, int x) {
  int result = 0, add = y;
  while (z &gt; 0) { // 不能使用除法
    if (z &amp; 1) {
      // 需要保证 result + add &gt;= x
      if (result &lt; x - add) {
        return false;
      }
      result += add;
    }
    if (z != 1) {
      // 需要保证 add + add &gt;= x
      if (add &lt; x - add) {
        return false;
      }
      add += add;
    }
    z &gt;&gt;= 1;
  }
  return true;
}
<em></em>
int divide(int a, int b) {
  if (a == numeric_limits&lt;int&gt;::min()) { // 考虑被除数为最小值的情况
    if (b == 1) {
      return numeric_limits&lt;int&gt;::min();
    }
    if (b == -1) {
      return numeric_limits&lt;int&gt;::max();
    }
  }
  if (b == numeric_limits&lt;int&gt;::min()) { // 考虑除数为最小值的情况
    if (a == numeric_limits&lt;int&gt;::min()) {
      return 1;
    }
    return 0;
  }
  if (a == 0) { // 考虑被除数为 0 的情况
    return 0;
  }
<em></em>
  // 一般情况，使用二分查找
  // 将所有的正数取相反数，这样就只需要考虑一种情况
  bool rev = false;
  if (a &gt; 0) {
    a = -a;
    rev = !rev;
  }
  if (b &gt; 0) {
    b = -b;
    rev = !rev;
  }
<em></em>
  int ans = 0;
  int left = 1, right = numeric_limits&lt;int&gt;::max();
  while (left &lt;= right) {
    int mid = left + ((right - left) &gt;&gt; 1); // 注意溢出，并且不能使用除法
    if (quickAdd(b, mid, a)) {
      ans = mid;
      if (mid == numeric_limits&lt;int&gt;::max()) { // 注意溢出
        break;
      }
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
<em></em>
  return rev ? -ans : ans;
}
<em></em>
int main() {
  std::cout &lt;&lt; divide(4, 3) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-0-go" class="code-example-tab-0"><pre><code class="language-go">package main
<em></em>
import &quot;math&quot;
<em></em>
// 快速乘
// x 和 y 是负数，z 是正数
// 判断 z * y &gt;= x 是否成立
func QuickAdd(y, z, x int) bool {
	for result, add := 0, y; z &gt; 0; z &gt;&gt;= 1 { // 不能使用除法
		if z&amp;1 &gt; 0 {
			// 需要保证 result + add &gt;= x
			if result &lt; x-add {
				return false
			}
			result += add
		}
		if z != 1 {
			// 需要保证 add + add &gt;= x
			if add &lt; x-add {
				return false
			}
			add += add
		}
	}
	return true
}
<em></em>
func divide(a, b int) int {
	if a == math.MinInt32 { // 考虑被除数为最小值的情况
		if b == 1 {
			return math.MinInt32
		}
		if b == -1 {
			return math.MaxInt32
		}
	}
	if b == math.MinInt32 { // 考虑除数为最小值的情况
		if a == math.MinInt32 {
			return 1
		}
		return 0
	}
	if a == 0 { // 考虑被除数为 0 的情况
		return 0
	}
<em></em>
	// 一般情况，使用二分查找
	// 将所有的正数取相反数，这样就只需要考虑一种情况
	rev := false
	if a &gt; 0 {
		a = -a
		rev = !rev
	}
	if b &gt; 0 {
		b = -b
		rev = !rev
	}
<em></em>
	ans := 0
	left, right := 1, math.MaxInt32
	for left &lt;= right {
		mid := left + (right-left)&gt;&gt;1 // 注意溢出，并且不能使用除法
		if QuickAdd(b, mid, a) {
			ans = mid
			if mid == math.MaxInt32 { // 注意溢出
				break
			}
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	if rev {
		return -ans
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-0", "code-example-tab-0-cpp")})()</script>
<h2 id="2"><a class="header" href="#2">2、</a></h2>
<p><code>剑指 Offer II 002. 二进制加法</code></p>
<p>给定两个01字符串，求得加法字符串</p>
<p><code>解法</code></p>
<ul>
<li>相对应下标(len-i-1)不断相加，计算商继续作为carry、模作为当前下标的值。</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-1', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-1-cpp">cpp</option><option value="code-example-tab-1-go">go</option></select></div>
<div id="code-example-tab-1-cpp" class="code-example-tab-1"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
<em></em>
using namespace std;
<em></em>
// 二进制字符串相加
string addBinary(string a, string b) {
  string ans = &quot;&quot;;
  int carry = 0;
  int lenA = a.size(), lenB = b.size();
  int n = max(lenA, lenB);
<em></em>
  // 从后往前逐位相加
  for (int i = 0; i &lt; n; i++) {
    if (i &lt; lenA) {
      carry += a[lenA - i - 1] - &#39;0&#39;;
    }
    if (i &lt; lenB) {
      carry += b[lenB - i - 1] - &#39;0&#39;;
    }
    ans = char(carry % 2 + &#39;0&#39;) + ans;
    carry /= 2;
  }
<em></em>
  // 如果最后有进位，补上一个1
  if (carry &gt; 0) {
    ans = &#39;1&#39; + ans;
  }
<em></em>
  return ans;
}
<em></em>
int main() {
  std::cout &lt;&lt; addBinary(&quot;11&quot;, &quot;1&quot;) &lt;&lt; std::endl;
  std::cout &lt;&lt; addBinary(&quot;11&quot;, &quot;1001&quot;) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-1-go" class="code-example-tab-1"><pre><code class="language-go">package main
<em></em>
import &quot;strconv&quot;
<em></em>
func AddBinary(a string, b string) string {
	ans := &quot;&quot;
	carry := 0
	lenA, lenB := len(a), len(b)
	n := max(lenA, lenB)
<em></em>
	for i := 0; i &lt; n; i++ {
		if i &lt; lenA {
			carry += int(a[lenA-i-1] - &#39;0&#39;)
		}
		if i &lt; lenB {
			carry += int(b[lenB-i-1] - &#39;0&#39;)
		}
		ans = strconv.Itoa(carry%2) + ans
		carry /= 2
	}
	if carry &gt; 0 {
		ans = &quot;1&quot; + ans
	}
	return ans
}
<em></em>
func max(x, y int) int {
	if x &gt; y {
		return x
	}
	return y
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-1", "code-example-tab-1-cpp")})()</script>
<h2 id="3"><a class="header" href="#3">3、</a></h2>
<p><code>剑指 Offer II 003. 前 n 个数字二进制中 1 的个数</code></p>
<p>给定一个数字n，从[0,n]中计算出二进制表示中1的个数</p>
<p><code>解法</code></p>
<ul>
<li>计算一个数的二进制表示中有多少个1，<code>x&gt;0</code>的循环条件中，能有多少次<code>x&amp;=x-1</code>满足条件</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-2', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-2-cpp">cpp</option><option value="code-example-tab-2-go">go</option></select></div>
<div id="code-example-tab-2-cpp" class="code-example-tab-2"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
<em></em>
// 计算一个整数的二进制表示中1的个数
int onesCount(int x) {
  int ones = 0;
  while (x &gt; 0) {
    x &amp;= (x - 1); // 消除最低位的1
    ones++;
  }
  return ones;
}
<em></em>
// 返回从0到n的每个整数的二进制表示中1的个数
vector&lt;int&gt; countBits(int n) {
  vector&lt;int&gt; bits(n + 1);
  for (int i = 0; i &lt;= n; ++i) {
    bits[i] = onesCount(i);
  }
  return bits;
}
<em></em>
int main() {
  vector&lt;int&gt; bits = countBits(5);
  for (int i = 0; i &lt; bits.size(); ++i) {
    cout &lt;&lt; bits[i] &lt;&lt; &quot; &quot;;
  }
  cout &lt;&lt; endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-2-go" class="code-example-tab-2"><pre><code class="language-go">package main
<em></em>
func onesCount(x int) (ones int) {
	for ; x &gt; 0; x &amp;= x - 1 {
		ones++
	}
	return
}
<em></em>
func CountBits(n int) []int {
	bits := make([]int, n+1)
	for i := range bits {
		bits[i] = onesCount(i)
	}
	return bits
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-2", "code-example-tab-2-cpp")})()</script>
<h2 id="4"><a class="header" href="#4">4、</a></h2>
<p><code>剑指 Offer II 004. 只出现一次的数字</code></p>
<p>给定一个整数数组，其中一个元素出现了一次，其他元素出现了三次，找到那个只出现了一次的元素</p>
<p>要求: <code>O(n)</code>时间复杂度, <code>O(1)</code>空间复杂度</p>
<p><code>解法</code></p>
<ul>
<li>将数组中的数字看成二进制格式，对于出现了三次的数字，他们对应的比特位数字和为0或者3，对于出现一次的数字，对应的比特位数字和为1或者4，将每一位的和取余所得到的余数就是结果对应的元素对应的位置。</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-3', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-3-cpp">cpp</option><option value="code-example-tab-3-go">go</option></select></div>
<div id="code-example-tab-3-cpp" class="code-example-tab-3"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
<em></em>
int singleNumber(const vector&lt;int&gt;&amp; nums) {
    int ans = 0;  // 32位整数，保存结果
    for (int i = 0; i &lt; 32; ++i) {
        int total = 0;  // 记录第i位的1的个数
        for (int num : nums) {
            total += (num &gt;&gt; i) &amp; 1;  // 取出num的第i位并累加
        }
        if (total % 3 &gt; 0) {  // 如果该位上的1的个数不是3的倍数
            ans |= (1 &lt;&lt; i);  // 将该位设置为1
        }
    }
    return ans;
}
<em></em>
int main() {
    vector&lt;int&gt; nums = { 1,1,1,2,2,2,3,3,3,4 };
    int ans = singleNumber(nums);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre></div><div id="code-example-tab-3-go" class="code-example-tab-3"><pre><code class="language-go">package main
<em></em>
func SingleNumber(nums []int) int {
	ans := int32(0)
	for i := 0; i &lt; 32; i++ {
		total := int32(0)
		for _, num := range nums {
			total += int32(num) &gt;&gt; i &amp; 1
		}
		if total%3 &gt; 0 {
			ans |= 1 &lt;&lt; i
		}
	}
	return int(ans)
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-3", "code-example-tab-3-cpp")})()</script>
<h2 id="5"><a class="header" href="#5">5、</a></h2>
<p><code>剑指 Offer II 005. 单词长度的最大乘积</code></p>
<p>一个字符串数组，寻找满足 不包含相同字符 的两个字符串的长度乘积，找到满足条件的最大长度</p>
<p><code>解法</code></p>
<ul>
<li>将字符串转为int类型mask来表示哪些字母是出现了的</li>
<li>使用位运算来判断是否存在相同的字符</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-4', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-4-cpp">cpp</option><option value="code-example-tab-4-go">go</option></select></div>
<div id="code-example-tab-4-cpp" class="code-example-tab-4"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;
<em></em>
int maxProduct(const vector&lt;string&gt; &amp;words) {
  int ans = 0;
  int n = words.size();
  vector&lt;int&gt; masks(n, 0); // 用于存储每个单词的掩码
<em></em>
  // 计算每个单词的字母掩码
  for (int i = 0; i &lt; n; ++i) {
    for (char ch : words[i]) {
      masks[i] |= (1 &lt;&lt; (ch - &#39;a&#39;)); // 将字母对应的位标记为1
    }
  }
<em></em>
  // 两两比较掩码，找出没有公共字母的单词组合，并计算其乘积
  for (int i = 0; i &lt; n; ++i) {
    for (int j = 0; j &lt; i; ++j) {
      if ((masks[i] &amp; masks[j]) == 0) { // 判断是否没有公共字母
        int product = words[i].size() * words[j].size();
        if (product &gt; ans) {
          ans = product;
        }
      }
    }
  }
<em></em>
  return ans;
}
<em></em>
int main() {
  vector&lt;string&gt; words = {&quot;abcw&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;xtfn&quot;, &quot;abcdef&quot;};
  int ans = maxProduct(words);
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-4-go" class="code-example-tab-4"><pre><code class="language-go">package main
<em></em>
func MaxProduct(words []string) (ans int) {
	masks := make([]int, len(words))
	for i, word := range words {
		for _, ch := range word {
			masks[i] |= 1 &lt;&lt; (ch - &#39;a&#39;)
		}
	}
<em></em>
	for i, x := range masks {
		for j, y := range masks[:i] {
			if x&amp;y == 0 &amp;&amp; len(words[i])*len(words[j]) &gt; ans {
				ans = len(words[i]) * len(words[j])
			}
		}
	}
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-4", "code-example-tab-4-cpp")})()</script>
<h2 id="6"><a class="header" href="#6">6、</a></h2>
<p><code>剑指 Offer II 006. 排序数组中两个数字之和</code></p>
<p>一个升序数组，找到其中的两个元素和为目标值，返回其目标下标。同一个数字不能使用两次，并且题目要求一定会存在满足条件的答案。</p>
<div><select onchange="changeCodeExample('code-example-tab-5', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-5-cpp">cpp</option><option value="code-example-tab-5-go">go</option></select></div>
<div id="code-example-tab-5-cpp" class="code-example-tab-5"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
std::vector&lt;int&gt; TwoSum(const std::vector&lt;int&gt; &amp;numbers, int target) {
  int low = 0, high = numbers.size() - 1;
  while (low &lt; high) {
    int sum = numbers[low] + numbers[high];
    if (sum == target) {
      return {low, high};
    } else if (sum &lt; target) {
      ++low;
    } else {
      --high;
    }
  }
  return {-1, -1};
}
</code></pre></div><div id="code-example-tab-5-go" class="code-example-tab-5"><pre><code class="language-go">package main
<em></em>
func TwoSum(numbers []int, target int) []int {
	low, high := 0, len(numbers)-1
	for low &lt; high {
		sum := numbers[low] + numbers[high]
		if sum == target {
			return []int{low, high}
		} else if sum &lt; target {
			low++
		} else {
			high--
		}
	}
	return []int{-1, -1}
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-5", "code-example-tab-5-cpp")})()</script>
<h2 id="7"><a class="header" href="#7">7、</a></h2>
<p><code>剑指 Offer II 007. 数组中和为 0 的三个数</code></p>
<p>给定一个整数数组，返回其中和为0的三元组，并且需要答案不能重复</p>
<p><code>解法</code></p>
<ul>
<li>先进行排序，优化搜索条件</li>
<li>记得跳过相同的值，即相同的一段，只计算第一个进行剪枝。</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-6', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-6-cpp">cpp</option><option value="code-example-tab-6-go">go</option></select></div>
<div id="code-example-tab-6-cpp" class="code-example-tab-6"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
std::vector&lt;std::vector&lt;int&gt;&gt; ThreeSum(std::vector&lt;int&gt; &amp;nums) {
  std::vector&lt;std::vector&lt;int&gt;&gt; ans;
  std::sort(nums.begin(), nums.end());
  int n = nums.size();
<em></em>
  for (int first = 0; first &lt; n; ++first) {
    if (first &gt; 0 &amp;&amp; nums[first] == nums[first - 1]) {
      continue;
    }
    int third = n - 1;
    int target = -nums[first];
    for (int second = first + 1; second &lt; n; ++second) {
      if (second &gt; first + 1 &amp;&amp; nums[second] == nums[second - 1]) {
        continue;
      }
      while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) {
        --third;
      }
      if (second == third) {
        break;
      }
      if (nums[second] + nums[third] == target) {
        ans.push_back({nums[first], nums[second], nums[third]});
      }
    }
  }
  return ans;
}
</code></pre></div><div id="code-example-tab-6-go" class="code-example-tab-6"><pre><code class="language-go">package main
<em></em>
import &quot;sort&quot;
<em></em>
func ThreeSum(nums []int) [][]int {
	n := len(nums)
	sort.Ints(nums)
	ans := make([][]int, 0)
<em></em>
	// 枚举 a
	for first := 0; first &lt; n; first++ {
		// 需要和上一次枚举的数不相同
		if first &gt; 0 &amp;&amp; nums[first] == nums[first-1] {
			continue
		}
		// c 对应的指针初始指向数组的最右端
		third := n - 1
		target := -1 * nums[first]
		// 枚举 b
		for second := first + 1; second &lt; n; second++ {
			// 需要和上一次枚举的数不相同
			if second &gt; first+1 &amp;&amp; nums[second] == nums[second-1] {
				continue
			}
			// 需要保证 b 的指针在 c 的指针的左侧
			for second &lt; third &amp;&amp; nums[second]+nums[third] &gt; target {
				third--
			}
			// 如果指针重合，随着 b 后续的增加
			// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环
			if second == third {
				break
			}
			if nums[second]+nums[third] == target {
				ans = append(ans, []int{nums[first], nums[second], nums[third]})
			}
		}
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-6", "code-example-tab-6-cpp")})()</script>
<h2 id="8"><a class="header" href="#8">8、</a></h2>
<p><code>剑指 Offer II 008. 和大于等于 target 的最短子数组</code></p>
<p>给定一个整数数组，寻找满足数组和大于target的一个最短连续子数组</p>
<p><code>解法</code></p>
<ul>
<li>滑动窗口: 计算满足和大于目标值的最短子数组长度</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-7', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-7-cpp">cpp</option><option value="code-example-tab-7-go">go</option></select></div>
<div id="code-example-tab-7-cpp" class="code-example-tab-7"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;vector&gt;
<em></em>
int minSubArrayLen(int s, const std::vector&lt;int&gt; &amp;nums) {
  int n = nums.size();
  if (n == 0) {
    return 0;
  }
  int ans = INT_MAX;
  int start = 0, end = 0, sum = 0;
  while (end &lt; n) {
    sum += nums[end];
    while (sum &gt;= s) {
      ans = std::min(ans, end - start + 1);
      sum -= nums[start];
      ++start;
    }
    ++end;
  }
  return (ans == INT_MAX) ? 0 : ans;
}
</code></pre></div><div id="code-example-tab-7-go" class="code-example-tab-7"><pre><code class="language-go">package main
<em></em>
import &quot;math&quot;
<em></em>
func MinSubArrayLen(s int, nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	ans := math.MaxInt32
	start, end := 0, 0
	sum := 0
	for end &lt; n {
		sum += nums[end]
		for sum &gt;= s {
			ans = min(ans, end-start+1)
			sum -= nums[start]
			start++
		}
		end++
	}
	if ans == math.MaxInt32 {
		return 0
	}
	return ans
}
<em></em>
func min(x, y int) int {
	if x &lt; y {
		return x
	}
	return y
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-7", "code-example-tab-7-cpp")})()</script>
<h2 id="9"><a class="header" href="#9">9、</a></h2>
<p><code>剑指 Offer II 009. 乘积小于 K 的子数组</code></p>
<p>给定一个数组，寻找其中满足数组乘积小于k的子数组的个数</p>
<div><select onchange="changeCodeExample('code-example-tab-8', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-8-cpp">cpp</option><option value="code-example-tab-8-go">go</option></select></div>
<div id="code-example-tab-8-cpp" class="code-example-tab-8"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
int numSubarrayProductLessThanK(const std::vector&lt;int&gt; &amp;nums, int k) {
  if (k &lt;= 1)
    return 0;
  int prod = 1, ans = 0, i = 0;
  for (int j = 0; j &lt; nums.size(); ++j) {
    prod *= nums[j];
    while (prod &gt;= k) {
      prod /= nums[i++];
    }
    ans += j - i + 1;
  }
  return ans;
}
</code></pre></div><div id="code-example-tab-8-go" class="code-example-tab-8"><pre><code class="language-go">package main
<em></em>
func numSubarrayProductLessThanK(nums []int, k int) (ans int) {
	prod, i := 1, 0
	for j, num := range nums {
		prod *= num
		for ; i &lt;= j &amp;&amp; prod &gt;= k; i++ {
			prod /= nums[i]
		}
		ans += j - i + 1
	}
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-8", "code-example-tab-8-cpp")})()</script>
<h2 id="10"><a class="header" href="#10">10、</a></h2>
<p><code>剑指 Offer II 010. 和为 k 的子数组</code></p>
<p>给定一个数组，寻找其中满足数组和为k的子数组的个数</p>
<p><code>解法</code></p>
<ul>
<li>数组和在计算过程中需要记录下来，并且同时计算该数组和对应的个数</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-9', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-9-cpp">cpp</option><option value="code-example-tab-9-go">go</option></select></div>
<div id="code-example-tab-9-cpp" class="code-example-tab-9"><pre><code class="language-cpp">#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
int subarraySum(const std::vector&lt;int&gt; &amp;nums, int k) {
  int count = 0, pre = 0;
  std::unordered_map&lt;int, int&gt; m;
  m[0] = 1;
  for (int i = 0; i &lt; nums.size(); ++i) {
    pre += nums[i];
    if (m.find(pre - k) != m.end()) {
      count += m[pre - k];
    }
    m[pre]++;
  }
  return count;
}
</code></pre></div><div id="code-example-tab-9-go" class="code-example-tab-9"><pre><code class="language-go">package main
<em></em>
func subarraySum(nums []int, k int) int {
	count, pre := 0, 0
	m := map[int]int{}
	m[0] = 1
	for i := 0; i &lt; len(nums); i++ {
		pre += nums[i]
		if _, ok := m[pre-k]; ok {
			count += m[pre-k]
		}
		m[pre] += 1
	}
	return count
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-9", "code-example-tab-9-cpp")})()</script>
<h2 id="11"><a class="header" href="#11">11、</a></h2>
<p><code>剑指 Offer II 011. 0 和 1 个数相同的子数组</code></p>
<p>给定一个只包含0和1的数组，找到其中含有相同<code>0和1</code>数量的最大长度的子数组</p>
<p><code>解法</code></p>
<ul>
<li>使用map记录某个前缀和最左边的下标是多少</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-10', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-10-cpp">cpp</option><option value="code-example-tab-10-go">go</option></select></div>
<div id="code-example-tab-10-cpp" class="code-example-tab-10"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
int FindMaxLength(const std::vector&lt;int&gt; &amp;nums) {
  std::unordered_map&lt;int, int&gt; mp = {{0, -1}};
  int maxLength = 0, counter = 0;
  for (int i = 0; i &lt; nums.size(); ++i) {
    counter += (nums[i] == 1) ? 1 : -1;
    if (mp.find(counter) != mp.end()) {
      maxLength = std::max(maxLength, i - mp[counter]);
    } else {
      mp[counter] = i;
    }
  }
  return maxLength;
}
</code></pre></div><div id="code-example-tab-10-go" class="code-example-tab-10"><pre><code class="language-go">package main
<em></em>
func FindMaxLength(nums []int) (maxLength int) {
	mp := map[int]int{0: -1}
	counter := 0
	for i, num := range nums {
		if num == 1 {
			counter++
		} else {
			counter--
		}
		if prevIndex, has := mp[counter]; has {
			maxLength = max(maxLength, i-prevIndex)
		} else {
			mp[counter] = i
		}
	}
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-10", "code-example-tab-10-cpp")})()</script>
<h2 id="12"><a class="header" href="#12">12、</a></h2>
<p><code>剑指 Offer II 012. 左右两边子数组的和相等</code></p>
<p>找到数组的最左边的中心下标，中心下标是指以该下标为分界，左右数组元素和相同的下标</p>
<p><code>解法</code></p>
<ul>
<li>判断<code>2 * 前缀和 + 当前值</code>是否等于数组总和</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-11', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-11-cpp">cpp</option><option value="code-example-tab-11-go">go</option></select></div>
<div id="code-example-tab-11-cpp" class="code-example-tab-11"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
int pivotIndex(const std::vector&lt;int&gt; &amp;nums) {
  int total = 0;
  for (int v : nums) {
    total += v;
  }
  int sum = 0;
  for (int i = 0; i &lt; nums.size(); ++i) {
    if (2 * sum + nums[i] == total) {
      return i;
    }
    sum += nums[i];
  }
  return -1;
}
</code></pre></div><div id="code-example-tab-11-go" class="code-example-tab-11"><pre><code class="language-go">package main
<em></em>
func pivotIndex(nums []int) int {
	total := 0
	for _, v := range nums {
		total += v
	}
	sum := 0
	for i, v := range nums {
		if 2*sum+v == total {
			return i
		}
		sum += v
	}
	return -1
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-11", "code-example-tab-11-cpp")})()</script>
<h2 id="13"><a class="header" href="#13">13、</a></h2>
<p><code>剑指 Offer II 013. 二维子矩阵的和</code></p>
<p>给定一个二维矩阵，提供多次查询，计算子矩阵的和</p>
<p><code>解法</code></p>
<ul>
<li>预处理(0,0)到(i,j)的子数组的和</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-12', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-12-cpp">cpp</option><option value="code-example-tab-12-go">go</option></select></div>
<div id="code-example-tab-12-cpp" class="code-example-tab-12"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
class NumMatrix {
public:
  NumMatrix(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;matrix) {
    int m = matrix.size();
    if (m == 0)
      return;
    int n = matrix[0].size();
    sums.resize(m + 1, std::vector&lt;int&gt;(n + 1, 0));
    for (int i = 0; i &lt; m; ++i) {
      for (int j = 0; j &lt; n; ++j) {
        sums[i + 1][j + 1] =
            sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + matrix[i][j];
      }
    }
  }
<em></em>
  int SumRegion(int row1, int col1, int row2, int col2) {
    return sums[row2 + 1][col2 + 1] - sums[row1][col2 + 1] -
           sums[row2 + 1][col1] + sums[row1][col1];
  }
<em></em>
private:
  std::vector&lt;std::vector&lt;int&gt;&gt; sums;
};
</code></pre></div><div id="code-example-tab-12-go" class="code-example-tab-12"><pre><code class="language-go">package main
<em></em>
type NumMatrix struct {
	sums [][]int
}
<em></em>
func Constructor(matrix [][]int) NumMatrix {
	m := len(matrix)
	if m == 0 {
		return NumMatrix{}
	}
	n := len(matrix[0])
	sums := make([][]int, m+1)
	sums[0] = make([]int, n+1)
	for i, row := range matrix {
		sums[i+1] = make([]int, n+1)
		for j, v := range row {
			sums[i+1][j+1] = sums[i+1][j] + sums[i][j+1] - sums[i][j] + v
		}
	}
	return NumMatrix{sums}
}
<em></em>
func (nm *NumMatrix) SumRegion(row1, col1, row2, col2 int) int {
	return nm.sums[row2+1][col2+1] - nm.sums[row1][col2+1] - nm.sums[row2+1][col1] + nm.sums[row1][col1]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-12", "code-example-tab-12-cpp")})()</script>
<h2 id="14"><a class="header" href="#14">14、</a></h2>
<p><code>剑指 Offer II 014. 字符串中的变位词</code></p>
<p>给定两个字符串，判断字符串的排列之一是否是另一个字符串的子串</p>
<p><code>解法</code></p>
<ul>
<li>使用26长度的数组来保存字符情况</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-13', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-13-cpp">cpp</option><option value="code-example-tab-13-go">go</option></select></div>
<div id="code-example-tab-13-cpp" class="code-example-tab-13"><pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
bool checkInclusion(const std::string &amp;s1, const std::string &amp;s2) {
  int n = s1.size(), m = s2.size();
  if (n &gt; m)
    return false;
<em></em>
  std::vector&lt;int&gt; cnt(26, 0);
  for (char ch : s1) {
    cnt[ch - &#39;a&#39;]--;
  }
<em></em>
  int left = 0;
  for (int right = 0; right &lt; m; ++right) {
    int x = s2[right] - &#39;a&#39;;
    cnt[x]++;
    while (cnt[x] &gt; 0) {
      cnt[s2[left] - &#39;a&#39;]--;
      left++;
    }
    if (right - left + 1 == n) {
      return true;
    }
  }
  return false;
}
</code></pre></div><div id="code-example-tab-13-go" class="code-example-tab-13"><pre><code class="language-go">package main
<em></em>
func checkInclusion(s1, s2 string) bool {
	n, m := len(s1), len(s2)
	if n &gt; m {
		return false
	}
	cnt := [26]int{}
	for _, ch := range s1 {
		cnt[ch-&#39;a&#39;]--
	}
	left := 0
	for right, ch := range s2 {
		x := ch - &#39;a&#39;
		cnt[x]++
		for cnt[x] &gt; 0 {
			cnt[s2[left]-&#39;a&#39;]--
			left++
		}
		if right-left+1 == n {
			return true
		}
	}
	return false
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-13", "code-example-tab-13-cpp")})()</script>
<h2 id="15"><a class="header" href="#15">15、</a></h2>
<p><code>剑指 Offer II 015. 字符串中的所有变位词</code></p>
<p>给定两个字符串，返回一个子串的所有变位形式判断在另一个字符串中是子串的话，就返回其起始下标</p>
<p><code>解法</code></p>
<ul>
<li>26位长度数组</li>
<li>滑动窗口</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-14', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-14-cpp">cpp</option><option value="code-example-tab-14-go">go</option></select></div>
<div id="code-example-tab-14-cpp" class="code-example-tab-14"><pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
std::vector&lt;int&gt; findAnagrams(const std::string &amp;s, const std::string &amp;p) {
  std::vector&lt;int&gt; ans;
  int sLen = s.size(), pLen = p.size();
  if (sLen &lt; pLen)
    return ans;
<em></em>
  std::vector&lt;int&gt; sCount(26, 0), pCount(26, 0);
  for (int i = 0; i &lt; pLen; ++i) {
    sCount[s[i] - &#39;a&#39;]++;
    pCount[p[i] - &#39;a&#39;]++;
  }
  if (sCount == pCount) {
    ans.push_back(0);
  }
<em></em>
  for (int i = 0; i &lt; sLen - pLen; ++i) {
    sCount[s[i] - &#39;a&#39;]--;
    sCount[s[i + pLen] - &#39;a&#39;]++;
    if (sCount == pCount) {
      ans.push_back(i + 1);
    }
  }
  return ans;
}
</code></pre></div><div id="code-example-tab-14-go" class="code-example-tab-14"><pre><code class="language-go">package main
<em></em>
func findAnagrams(s, p string) (ans []int) {
	sLen, pLen := len(s), len(p)
	if sLen &lt; pLen {
		return
	}
<em></em>
	var sCount, pCount [26]int
	for i, ch := range p {
		sCount[s[i]-&#39;a&#39;]++
		pCount[ch-&#39;a&#39;]++
	}
	if sCount == pCount {
		ans = append(ans, 0)
	}
<em></em>
	for i, ch := range s[:sLen-pLen] {
		sCount[ch-&#39;a&#39;]--
		sCount[s[i+pLen]-&#39;a&#39;]++
		if sCount == pCount {
			ans = append(ans, i+1)
		}
	}
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-14", "code-example-tab-14-cpp")})()</script>
<h2 id="16"><a class="header" href="#16">16、</a></h2>
<p><code>剑指 Offer II 016. 不含重复字符的最长子字符串</code></p>
<p>给定一个字符串，返回不包含重复字符的最长子字符串长度</p>
<p><code>解法</code></p>
<ul>
<li>滑动窗口，记录在窗口中字符的个数</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-15', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-15-cpp">cpp</option><option value="code-example-tab-15-go">go</option></select></div>
<div id="code-example-tab-15-cpp" class="code-example-tab-15"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
<em></em>
int lengthOfLongestSubstring(const std::string &amp;s) {
  std::unordered_map&lt;char, int&gt; m;
  int n = s.length();
  int rk = -1, ans = 0;
<em></em>
  for (int i = 0; i &lt; n; ++i) {
    if (i != 0) {
      m.erase(s[i - 1]);
    }
    while (rk + 1 &lt; n &amp;&amp; m[s[rk + 1]] == 0) {
      m[s[++rk]]++;
    }
    ans = std::max(ans, rk - i + 1);
  }
<em></em>
  return ans;
}
</code></pre></div><div id="code-example-tab-15-go" class="code-example-tab-15"><pre><code class="language-go">package main
<em></em>
func lengthOfLongestSubstring(s string) int {
	// 哈希集合，记录每个字符是否出现过
	m := map[byte]int{}
	n := len(s)
	// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
	rk, ans := -1, 0
	for i := 0; i &lt; n; i++ {
		if i != 0 {
			// 左指针向右移动一格，移除一个字符
			delete(m, s[i-1])
		}
		for rk+1 &lt; n &amp;&amp; m[s[rk+1]] == 0 {
			// 不断地移动右指针
			m[s[rk+1]]++
			rk++
		}
		// 第 i 到 rk 个字符是一个极长的无重复字符子串
		ans = max(ans, rk-i+1)
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-15", "code-example-tab-15-cpp")})()</script>
<h2 id="17"><a class="header" href="#17">17、</a></h2>
<p><code>剑指 Offer II 017. 含有所有字符的最短字符串</code></p>
<p>给定两个字符串s和t，找到s中的一个最短字符串，包含t的所有字符，如果不存在这样的子字符串，则返回空字符串</p>
<div><select onchange="changeCodeExample('code-example-tab-16', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-16-cpp">cpp</option><option value="code-example-tab-16-go">go</option></select></div>
<div id="code-example-tab-16-cpp" class="code-example-tab-16"><pre><code class="language-cpp">#include &lt;climits&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
<em></em>
std::string minWindow(const std::string &amp;s, const std::string &amp;t) {
  std::unordered_map&lt;char, int&gt; ori, cnt;
  for (char c : t) {
    ori[c]++;
  }
<em></em>
  int sLen = s.length();
  int minLen = INT_MAX;
  int ansL = -1, ansR = -1;
<em></em>
  auto check = [&amp;]() -&gt; bool {
    for (const auto &amp;[k, v] : ori) {
      if (cnt[k] &lt; v) {
        return false;
      }
    }
    return true;
  };
<em></em>
  for (int l = 0, r = 0; r &lt; sLen; ++r) {
    if (ori.find(s[r]) != ori.end()) {
      cnt[s[r]]++;
    }
    while (check() &amp;&amp; l &lt;= r) {
      if (r - l + 1 &lt; minLen) {
        minLen = r - l + 1;
        ansL = l;
        ansR = l + minLen;
      }
      if (ori.find(s[l]) != ori.end()) {
        cnt[s[l]]--;
      }
      ++l;
    }
  }
<em></em>
  if (ansL == -1) {
    return &quot;&quot;;
  }
  return s.substr(ansL, ansR - ansL);
}
</code></pre></div><div id="code-example-tab-16-go" class="code-example-tab-16"><pre><code class="language-go">package main
<em></em>
import &quot;math&quot;
<em></em>
func minWindow(s string, t string) string {
	ori, cnt := map[byte]int{}, map[byte]int{}
	for i := 0; i &lt; len(t); i++ {
		ori[t[i]]++
	}
<em></em>
	sLen := len(s)
	len := math.MaxInt32
	ansL, ansR := -1, -1
<em></em>
	check := func() bool {
		for k, v := range ori {
			if cnt[k] &lt; v {
				return false
			}
		}
		return true
	}
	for l, r := 0, 0; r &lt; sLen; r++ {
		if r &lt; sLen &amp;&amp; ori[s[r]] &gt; 0 {
			cnt[s[r]]++
		}
		for check() &amp;&amp; l &lt;= r {
			if r-l+1 &lt; len {
				len = r - l + 1
				ansL, ansR = l, l+len
			}
			if _, ok := ori[s[l]]; ok {
				cnt[s[l]] -= 1
			}
			l++
		}
	}
	if ansL == -1 {
		return &quot;&quot;
	}
	return s[ansL:ansR]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-16", "code-example-tab-16-cpp")})()</script>
<h2 id="18"><a class="header" href="#18">18、</a></h2>
<p><code>剑指 Offer II 018. 有效的回文</code></p>
<p>给定一个字符串，验证是否是回文字符串, 只考虑字母和数字字符，可以忽略字母的大小写。</p>
<div><select onchange="changeCodeExample('code-example-tab-17', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-17-cpp">cpp</option><option value="code-example-tab-17-go">go</option></select></div>
<div id="code-example-tab-17-cpp" class="code-example-tab-17"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;string&gt;
<em></em>
bool isalnum(char ch) {
  return (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) || (ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
         (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);
}
<em></em>
bool isPalindrome(const std::string &amp;s) {
  std::string sgood;
  for (char ch : s) {
    if (isalnum(ch)) {
      sgood += std::tolower(ch);
    }
  }
<em></em>
  int n = sgood.length();
  for (int i = 0; i &lt; n / 2; ++i) {
    if (sgood[i] != sgood[n - 1 - i]) {
      return false;
    }
  }
  return true;
}
</code></pre></div><div id="code-example-tab-17-go" class="code-example-tab-17"><pre><code class="language-go">package main
<em></em>
import &quot;strings&quot;
<em></em>
func isPalindrome(s string) bool {
	var sgood string
	for i := 0; i &lt; len(s); i++ {
		if isalnum(s[i]) {
			sgood += string(s[i])
		}
	}
<em></em>
	n := len(sgood)
	sgood = strings.ToLower(sgood)
	for i := 0; i &lt; n/2; i++ {
		if sgood[i] != sgood[n-1-i] {
			return false
		}
	}
	return true
}
<em></em>
func isalnum(ch byte) bool {
	return (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) || (ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) || (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-17", "code-example-tab-17-cpp")})()</script>
<h2 id="19"><a class="header" href="#19">19、</a></h2>
<p><code>剑指 Offer II 019. 最多删除一个字符得到回文</code></p>
<p>给定一个字符串，删除其中一个字符判断是否是回文</p>
<div><select onchange="changeCodeExample('code-example-tab-18', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-18-cpp">cpp</option><option value="code-example-tab-18-go">go</option></select></div>
<div id="code-example-tab-18-cpp" class="code-example-tab-18"><pre><code class="language-cpp">#include &lt;string&gt;
<em></em>
bool validPalindrome(const std::string &amp;s) {
  int low = 0, high = s.length() - 1;
  while (low &lt; high) {
    if (s[low] == s[high]) {
      ++low;
      --high;
    } else {
      bool flag1 = true, flag2 = true;
      for (int i = low, j = high - 1; i &lt; j; ++i, --j) {
        if (s[i] != s[j]) {
          flag1 = false;
          break;
        }
      }
      for (int i = low + 1, j = high; i &lt; j; ++i, --j) {
        if (s[i] != s[j]) {
          flag2 = false;
          break;
        }
      }
      return flag1 || flag2;
    }
  }
  return true;
}
</code></pre></div><div id="code-example-tab-18-go" class="code-example-tab-18"><pre><code class="language-go">package main
<em></em>
func validPalindrome(s string) bool {
	low, high := 0, len(s)-1
	for low &lt; high {
		if s[low] == s[high] {
			low++
			high--
		} else {
			flag1, flag2 := true, true
			for i, j := low, high-1; i &lt; j; i, j = i+1, j-1 {
				if s[i] != s[j] {
					flag1 = false
					break
				}
			}
			for i, j := low+1, high; i &lt; j; i, j = i+1, j-1 {
				if s[i] != s[j] {
					flag2 = false
					break
				}
			}
			return flag1 || flag2
		}
	}
	return true
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-18", "code-example-tab-18-cpp")})()</script>
<h2 id="20"><a class="header" href="#20">20、</a></h2>
<p><code>剑指 Offer II 020. 回文子字符串的个数</code></p>
<p>计算一个字符串中有多少个回文子字符串</p>
<div><select onchange="changeCodeExample('code-example-tab-19', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-19-cpp">cpp</option><option value="code-example-tab-19-go">go</option></select></div>
<div id="code-example-tab-19-cpp" class="code-example-tab-19"><pre><code class="language-cpp">#include &lt;string&gt;
<em></em>
int countSubstrings(const std::string &amp;s) {
  int n = s.length();
  int ans = 0;
  for (int i = 0; i &lt; 2 * n - 1; ++i) {
    int l = i / 2;
    int r = i / 2 + i % 2;
    while (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) {
      --l;
      ++r;
      ++ans;
    }
  }
  return ans;
}
</code></pre></div><div id="code-example-tab-19-go" class="code-example-tab-19"><pre><code class="language-go">package main
<em></em>
func countSubstrings(s string) int {
	n := len(s)
	ans := 0
	for i := 0; i &lt; 2*n-1; i++ {
		l, r := i/2, i/2+i%2
		for l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r] {
			l--
			r++
			ans++
		}
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-19", "code-example-tab-19-cpp")})()</script>
<h2 id="21"><a class="header" href="#21">21、</a></h2>
<p><code>剑指 Offer II 021. 删除链表的倒数第 n 个结点</code></p>
<p>给定一个链表，删除链表的倒数第n个节点，并且返回头节点</p>
<p><code>解法</code></p>
<ul>
<li>快慢指针</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-20', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-20-cpp">cpp</option><option value="code-example-tab-20-go">go</option></select></div>
<div id="code-example-tab-20-cpp" class="code-example-tab-20"><pre><code class="language-cpp">struct ListNode {
  int Val;
  ListNode *Next;
  ListNode(int x) : Val(x), Next(nullptr) {}
};
<em></em>
ListNode *removeNthFromEnd(ListNode *head, int n) {
  ListNode *dummy = new ListNode(0);
  dummy-&gt;Next = head;
  ListNode *first = head;
  ListNode *second = dummy;
<em></em>
  for (int i = 0; i &lt; n; ++i) {
    first = first-&gt;Next;
  }
<em></em>
  while (first != nullptr) {
    first = first-&gt;Next;
    second = second-&gt;Next;
  }
<em></em>
  second-&gt;Next = second-&gt;Next-&gt;Next;
  ListNode *newHead = dummy-&gt;Next;
  delete dummy; // Free the allocated memory for dummy node
  return newHead;
}
</code></pre></div><div id="code-example-tab-20-go" class="code-example-tab-20"><pre><code class="language-go">package main
<em></em>
type ListNode struct {
	Val  int
	Next *ListNode
}
<em></em>
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &amp;ListNode{0, head}
	first, second := head, dummy
	for i := 0; i &lt; n; i++ {
		first = first.Next
	}
	for ; first != nil; first = first.Next {
		second = second.Next
	}
	second.Next = second.Next.Next
	return dummy.Next
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-20", "code-example-tab-20-cpp")})()</script>
<h2 id="22"><a class="header" href="#22">22、</a></h2>
<p><code>剑指 Offer II 022. 链表中环的入口节点</code></p>
<p>给定一个数组形式的链表，数组中每个元素对应着下一个节点的下标，如果该链表没有环，就返回-1，如果有环，则返回环入口的下标</p>
<p><code>解法</code></p>
<ul>
<li>快慢指针，当相遇了之后从当前以及初始位置以相同速度前进，当再次相遇就是环的入口</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-21', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-21-cpp">cpp</option><option value="code-example-tab-21-go">go</option></select></div>
<div id="code-example-tab-21-cpp" class="code-example-tab-21"><pre><code class="language-cpp">struct ListNode {
  int Val;
  ListNode *Next;
  ListNode(int x) : Val(x), Next(nullptr) {}
};
<em></em>
ListNode *detectCycle(ListNode *head) {
  if (!head)
    return nullptr;
<em></em>
  ListNode *slow = head;
  ListNode *fast = head;
<em></em>
  while (fast != nullptr &amp;&amp; fast-&gt;Next != nullptr) {
    slow = slow-&gt;Next;
    fast = fast-&gt;Next-&gt;Next;
<em></em>
    if (slow == fast) {
      ListNode *p = head;
      while (p != slow) {
        p = p-&gt;Next;
        slow = slow-&gt;Next;
      }
      return p;
    }
  }
<em></em>
  return nullptr;
}
</code></pre></div><div id="code-example-tab-21-go" class="code-example-tab-21"><pre><code class="language-go">package main
<em></em>
func detectCycle(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast != nil {
		slow = slow.Next
		if fast.Next == nil {
			return nil
		}
		fast = fast.Next.Next
		if fast == slow {
			p := head
			for p != slow {
				p = p.Next
				slow = slow.Next
			}
			return p
		}
	}
	return nil
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-21", "code-example-tab-21-cpp")})()</script>
<h2 id="23"><a class="header" href="#23">23、</a></h2>
<p><code>剑指 Offer II 023. 两个链表的第一个重合节点</code></p>
<p>给定两个链表，题目保证该链式结构没有环，找到该两个链表的相交节点，如果不存在相交节点，就返回空</p>
<p><code>解法</code></p>
<ul>
<li>链表走完了之后到另外一个上，这样到达相交节点的节点数相同，是会相遇的</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-22', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-22-cpp">cpp</option><option value="code-example-tab-22-go">go</option></select></div>
<div id="code-example-tab-22-cpp" class="code-example-tab-22"><pre><code class="language-cpp">struct ListNode {
  int Val;
  ListNode *Next;
  ListNode(int x) : Val(x), Next(nullptr) {}
};
<em></em>
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
  if (headA == nullptr || headB == nullptr) {
    return nullptr;
  }
<em></em>
  ListNode *pa = headA;
  ListNode *pb = headB;
<em></em>
  while (pa != pb) {
    pa = (pa == nullptr) ? headB : pa-&gt;Next;
    pb = (pb == nullptr) ? headA : pb-&gt;Next;
  }
<em></em>
  return pa;
}
</code></pre></div><div id="code-example-tab-22-go" class="code-example-tab-22"><pre><code class="language-go">package main
<em></em>
func getIntersectionNode(headA, headB *ListNode) *ListNode {
	if headA == nil || headB == nil {
		return nil
	}
	pa, pb := headA, headB
	for pa != pb {
		if pa == nil {
			pa = headB
		} else {
			pa = pa.Next
		}
		if pb == nil {
			pb = headA
		} else {
			pb = pb.Next
		}
	}
	return pa
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-22", "code-example-tab-22-cpp")})()</script>
<h2 id="24"><a class="header" href="#24">24、</a></h2>
<p><code>剑指 Offer II 024. 反转链表</code></p>
<p>给定一个链式结构，反转后返回其头节点</p>
<div><select onchange="changeCodeExample('code-example-tab-23', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-23-cpp">cpp</option><option value="code-example-tab-23-go">go</option></select></div>
<div id="code-example-tab-23-cpp" class="code-example-tab-23"><pre><code class="language-cpp">struct ListNode {
  int Val;
  ListNode *Next;
  ListNode(int x) : Val(x), Next(nullptr) {}
};
<em></em>
ListNode *reverseList(ListNode *head) {
  if (head == nullptr || head-&gt;Next == nullptr) {
    return head;
  }
  ListNode *newHead = reverseList(head-&gt;Next);
  head-&gt;Next-&gt;Next = head;
  head-&gt;Next = nullptr;
  return newHead;
}
</code></pre></div><div id="code-example-tab-23-go" class="code-example-tab-23"><pre><code class="language-go">package main
<em></em>
func reverseList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	newHead := reverseList(head.Next)
	head.Next.Next = head
	head.Next = nil
	return newHead
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-23", "code-example-tab-23-cpp")})()</script>
<h2 id="25"><a class="header" href="#25">25、</a></h2>
<p><code>剑指 Offer II 025. 链表中的两数相加</code></p>
<p>使用两个链表表示非负整数，尾节点为个位数，返回两个链表的相加结果，并以链表形式返回</p>
<p><code>解法</code></p>
<ul>
<li>将链表转为数组，然后计算完后进行重新构造成链表</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-24', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-24-cpp">cpp</option><option value="code-example-tab-24-go">go</option></select></div>
<div id="code-example-tab-24-cpp" class="code-example-tab-24"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
struct ListNode {
  int Val;
  ListNode *Next;
  ListNode(int x) : Val(x), Next(nullptr) {}
};
<em></em>
ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
  std::vector&lt;int&gt; s1, s2;
  while (l1 != nullptr) {
    s1.push_back(l1-&gt;Val);
    l1 = l1-&gt;Next;
  }
  while (l2 != nullptr) {
    s2.push_back(l2-&gt;Val);
    l2 = l2-&gt;Next;
  }
<em></em>
  int carry = 0;
  ListNode *head = nullptr;
  while (!s1.empty() || !s2.empty() || carry != 0) {
    int sum = 0;
    if (!s1.empty()) {
      sum += s1.back();
      s1.pop_back();
    }
    if (!s2.empty()) {
      sum += s2.back();
      s2.pop_back();
    }
    sum += carry;
    ListNode *node = new ListNode(sum % 10);
    node-&gt;Next = head;
    head = node;
    carry = sum / 10;
  }
<em></em>
  return head;
}
</code></pre></div><div id="code-example-tab-24-go" class="code-example-tab-24"><pre><code class="language-go">package main
<em></em>
func addTwoNumbers(l1 *ListNode, l2 *ListNode) (head *ListNode) {
	var s1, s2 []int
	for l1 != nil {
		s1 = append(s1, l1.Val)
		l1 = l1.Next
	}
	for l2 != nil {
		s2 = append(s2, l2.Val)
		l2 = l2.Next
	}
	carry := 0
	for len(s1) &gt; 0 || len(s2) &gt; 0 || carry &gt; 0 {
		sum := 0
		if len(s1) &gt; 0 {
			sum += s1[len(s1)-1]
			s1 = s1[:len(s1)-1]
		}
		if len(s2) &gt; 0 {
			sum += s2[len(s2)-1]
			s2 = s2[:len(s2)-1]
		}
		sum += carry
		node := &amp;ListNode{Val: sum % 10}
		node.Next = head
		head = node
		carry = sum / 10
	}
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-24", "code-example-tab-24-cpp")})()</script>
<h2 id="26"><a class="header" href="#26">26、</a></h2>
<p><code>剑指 Offer II 026. 重排链表</code></p>
<p>给定一个链表结构，原始为'1 2 3 4 5 6 ... n-1 n' 修改为'1 n 2 n-1 3 n-2 ...'</p>
<div><select onchange="changeCodeExample('code-example-tab-25', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-25-cpp">cpp</option><option value="code-example-tab-25-go">go</option></select></div>
<div id="code-example-tab-25-cpp" class="code-example-tab-25"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
struct ListNode {
  int Val;
  ListNode *Next;
  ListNode(int x) : Val(x), Next(nullptr) {}
};
<em></em>
void reorderList(ListNode *head) {
  if (head == nullptr) {
    return;
  }
<em></em>
  std::vector&lt;ListNode *&gt; nodes;
  for (ListNode *node = head; node != nullptr; node = node-&gt;Next) {
    nodes.push_back(node);
  }
<em></em>
  int i = 0, j = nodes.size() - 1;
  while (i &lt; j) {
    nodes[i]-&gt;Next = nodes[j];
    ++i;
    if (i == j) {
      break;
    }
    nodes[j]-&gt;Next = nodes[i];
    --j;
  }
  nodes[i]-&gt;Next = nullptr;
}
</code></pre></div><div id="code-example-tab-25-go" class="code-example-tab-25"><pre><code class="language-go">package main
<em></em>
func reorderList(head *ListNode) {
	if head == nil {
		return
	}
	nodes := []*ListNode{}
	for node := head; node != nil; node = node.Next {
		nodes = append(nodes, node)
	}
	i, j := 0, len(nodes)-1
	for i &lt; j {
		nodes[i].Next = nodes[j]
		i++
		if i == j {
			break
		}
		nodes[j].Next = nodes[i]
		j--
	}
	nodes[i].Next = nil
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-25", "code-example-tab-25-cpp")})()</script>
<h2 id="27"><a class="header" href="#27">27、</a></h2>
<p><code>剑指 Offer II 027. 回文链表</code></p>
<p>给定一个链表结构，判断该链表是否是回文</p>
<div><select onchange="changeCodeExample('code-example-tab-26', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-26-cpp">cpp</option><option value="code-example-tab-26-go">go</option></select></div>
<div id="code-example-tab-26-cpp" class="code-example-tab-26"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
struct ListNode {
  int Val;
  ListNode *Next;
  ListNode(int x) : Val(x), Next(nullptr) {}
};
<em></em>
bool isLinkListPalindrome(ListNode *head) {
  std::vector&lt;int&gt; vals;
  for (ListNode *node = head; node != nullptr; node = node-&gt;Next) {
    vals.push_back(node-&gt;Val);
  }
<em></em>
  int n = vals.size();
  for (int i = 0; i &lt; n / 2; ++i) {
    if (vals[i] != vals[n - 1 - i]) {
      return false;
    }
  }
  return true;
}
</code></pre></div><div id="code-example-tab-26-go" class="code-example-tab-26"><pre><code class="language-go">package main
<em></em>
func isLinkListPalindrome(head *ListNode) bool {
	vals := []int{}
	for ; head != nil; head = head.Next {
		vals = append(vals, head.Val)
	}
	n := len(vals)
	for i, v := range vals[:n/2] {
		if v != vals[n-1-i] {
			return false
		}
	}
	return true
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-26", "code-example-tab-26-cpp")})()</script>
<h2 id="28"><a class="header" href="#28">28、</a></h2>
<p><code>剑指 Offer II 028. 展平多级双向链表</code></p>
<p>将多级双向链表展平</p>
<p>这里多级双向链表就是包含前后指针，还包含子链表的指针，(其实就相当于链表)</p>
<div><select onchange="changeCodeExample('code-example-tab-27', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-27-cpp">cpp</option><option value="code-example-tab-27-go">go</option></select></div>
<div id="code-example-tab-27-cpp" class="code-example-tab-27"><pre><code class="language-cpp">struct Node {
  int Val;
  Node *Prev;
  Node *Next;
  Node *Child;
  Node(int x) : Val(x), Prev(nullptr), Next(nullptr), Child(nullptr) {}
};
<em></em>
Node *dfs(Node *node) {
  Node *cur = node;
  Node *last = nullptr;
<em></em>
  while (cur != nullptr) {
    Node *next = cur-&gt;Next;
    if (cur-&gt;Child != nullptr) {
      Node *childLast = dfs(cur-&gt;Child);
<em></em>
      cur-&gt;Next = cur-&gt;Child;
      cur-&gt;Child-&gt;Prev = cur;
<em></em>
      if (next != nullptr) {
        childLast-&gt;Next = next;
        next-&gt;Prev = childLast;
      }
<em></em>
      cur-&gt;Child = nullptr;
      last = childLast;
    } else {
      last = cur;
    }
    cur = next;
  }
  return last;
}
<em></em>
Node *flatten(Node *root) {
  dfs(root);
  return root;
}
</code></pre></div><div id="code-example-tab-27-go" class="code-example-tab-27"><pre><code class="language-go">package main
<em></em>
type LinkNode struct {
	Val   int
	Next  *LinkNode
	Prev  *LinkNode
	Child *LinkNode
}
<em></em>
func dfs(node *LinkNode) (last *LinkNode) {
	cur := node
	for cur != nil {
		next := cur.Next
		// 如果有子节点，那么首先处理子节点
		if cur.Child != nil {
			childLast := dfs(cur.Child)
<em></em>
			next = cur.Next
			// 将 node 与 child 相连
			cur.Next = cur.Child
			cur.Child.Prev = cur
<em></em>
			// 如果 next 不为空，就将 last 与 next 相连
			if next != nil {
				childLast.Next = next
				next.Prev = childLast
			}
<em></em>
			// 将 child 置为空
			cur.Child = nil
			last = childLast
		} else {
			last = cur
		}
		cur = next
	}
	return
}
<em></em>
func flatten(root *LinkNode) *LinkNode {
	dfs(root)
	return root
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-27", "code-example-tab-27-cpp")})()</script>
<h2 id="29"><a class="header" href="#29">29、</a></h2>
<p><code>剑指 Offer II 029. 排序的循环链表</code></p>
<p>给定一个循环链表，它的值是单调非递减的，提供一个元素插入的方法，使得元素插入之后值依然是单调非递减的</p>
<p><code>解法</code></p>
<ul>
<li>第一种情况 <code>cur.val &lt;= val &lt;= next.val</code>, 直接插入到这里</li>
<li>第二种情况 <code>cur.val &gt; next.val</code>, 说明是链表遍历完了，break，直接加入到cur的后面</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-28', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-28-cpp">cpp</option><option value="code-example-tab-28-go">go</option></select></div>
<div id="code-example-tab-28-cpp" class="code-example-tab-28"><pre><code class="language-cpp">struct Node {
  int Val;
  Node *Next;
  Node(int x) : Val(x), Next(nullptr) {}
};
<em></em>
Node *insert(Node *head, int insertVal) {
  Node *node = new Node(insertVal);
  if (head == nullptr) {
    node-&gt;Next = node;
    return node;
  }
  if (head-&gt;Next == head) {
    head-&gt;Next = node;
    node-&gt;Next = head;
    return head;
  }
  Node *curr = head;
  Node *next = head-&gt;Next;
  while (next != head) {
    if (insertVal &gt;= curr-&gt;Val &amp;&amp; insertVal &lt;= next-&gt;Val) {
      break;
    }
    if (curr-&gt;Val &gt; next-&gt;Val) {
      if (insertVal &gt; curr-&gt;Val || insertVal &lt; next-&gt;Val) {
        break;
      }
    }
    curr = curr-&gt;Next;
    next = next-&gt;Next;
  }
  curr-&gt;Next = node;
  node-&gt;Next = next;
  return head;
}
</code></pre></div><div id="code-example-tab-28-go" class="code-example-tab-28"><pre><code class="language-go">package main
<em></em>
func insert(head *ListNode, insertVal int) *ListNode {
	node := &amp;ListNode{Val: insertVal}
	if head == nil {
		node.Next = node
		return node
	}
	if head.Next == head {
		head.Next = node
		node.Next = head
		return head
	}
	curr, next := head, head.Next
	for next != head {
		if insertVal &gt;= curr.Val &amp;&amp; insertVal &lt;= next.Val {
			break
		}
		if curr.Val &gt; next.Val {
			if insertVal &gt; curr.Val || insertVal &lt; next.Val {
				break
			}
		}
		curr = curr.Next
		next = next.Next
	}
	curr.Next = node
	node.Next = next
	return head
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-28", "code-example-tab-28-cpp")})()</script>
<h2 id="30"><a class="header" href="#30">30、</a></h2>
<p><code>剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器</code></p>
<p>创造一个数据结构，它的插入、删除、随机访问都是O(1)时间复杂度</p>
<p><code>解法</code></p>
<ul>
<li>由于需要随机访问，所以将数据存储到数组中，通过对下标进行随机来进行访问</li>
<li>插入和删除也需要O(1), 使用map来存储值与下标</li>
<li>当删除的时候，将末尾的一个移动到要删除的位置并且更新下对应下标，然后数组只需要减一个长度即可</li>
</ul>
<div><select onchange="changeCodeExample('code-example-tab-29', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-29-cpp">cpp</option><option value="code-example-tab-29-go">go</option></select></div>
<div id="code-example-tab-29-cpp" class="code-example-tab-29"><pre><code class="language-cpp">#include &lt;cstdlib&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
class RandomizedSet {
public:
  RandomizedSet() {}
<em></em>
  bool insert(int val) {
    if (indices.find(val) != indices.end()) {
      return false;
    }
    indices[val] = nums.size();
    nums.push_back(val);
    return true;
  }
<em></em>
  bool remove(int val) {
    auto it = indices.find(val);
    if (it == indices.end()) {
      return false;
    }
    int last = nums.back();
    nums[it-&gt;second] = last;
    indices[last] = it-&gt;second;
    nums.pop_back();
    indices.erase(val);
    return true;
  }
<em></em>
  int getRandom() {
    int randomIndex = rand() % nums.size();
    return nums[randomIndex];
  }
<em></em>
private:
  std::vector&lt;int&gt; nums;
  std::unordered_map&lt;int, int&gt; indices;
};
</code></pre></div><div id="code-example-tab-29-go" class="code-example-tab-29"><pre><code class="language-go">package main
<em></em>
import &quot;math/rand&quot;
<em></em>
type RandomizedSet struct {
	nums    []int
	indices map[int]int
}
<em></em>
func NewRandomizedSet() RandomizedSet {
	return RandomizedSet{
		[]int{}, map[int]int{},
	}
}
<em></em>
func (rs *RandomizedSet) Insert(val int) bool {
	if _, ok := rs.indices[val]; ok {
		return false
	}
	rs.indices[val] = len(rs.nums)
	rs.nums = append(rs.nums, val)
	return true
}
<em></em>
func (rs *RandomizedSet) Remove(val int) bool {
	id, ok := rs.indices[val]
	if !ok {
		return false
	}
	last := len(rs.nums) - 1
	rs.nums[id] = rs.nums[last]
	rs.indices[rs.nums[id]] = id
	rs.nums = rs.nums[:last]
	delete(rs.indices, val)
	return true
}
<em></em>
func (rs *RandomizedSet) GetRandom() int {
	return rs.nums[rand.Intn(len(rs.nums))]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-29", "code-example-tab-29-cpp")})()</script>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="31"><a class="header" href="#31">31、</a></h2>
<p><code>剑指 Offer II 031. 最近最少使用缓存</code></p>
<p>设计一个最近最少使用的缓存数据结构，提供get和put方法</p>
<pre><code class="language-go">import "container/list"

type LRUCache struct {
    capacity int
    cache    map[int]*list.Element
    list     *list.List
}

type entry struct {
    key   int
    value int
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*list.Element),
        list:     list.New(),
    }
}

func (this *LRUCache) Get(key int) int {
    if elem, ok := this.cache[key]; ok {
        this.list.MoveToFront(elem)
        return elem.Value.(*entry).value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if elem, ok := this.cache[key]; ok {
        elem.Value.(*entry).value = value
        this.list.MoveToFront(elem)
        return
    }
    if this.list.Len() == this.capacity {
        lastElem := this.list.Back()
        delete(this.cache, lastElem.Value.(*entry).key)
        this.list.Remove(lastElem)
    }
    newElem := this.list.PushFront(&amp;entry{key: key, value: value})
    this.cache[key] = newElem
}
</code></pre>
<h2 id="32"><a class="header" href="#32">32、</a></h2>
<p><code>剑指 Offer II 032. 有效的变位词</code></p>
<p>判断字符串s和t是否是一组有效的变位词，即元素相同位置不同</p>
<pre><code class="language-go">func isAnagram(s, t string) bool {
    if s == t {
        return false
    }
    var c1, c2 [26]int
    for _, ch := range s {
        c1[ch-'a']++
    }
    for _, ch := range t {
        c2[ch-'a']++
    }
    return c1 == c2
}
</code></pre>
<h2 id="33"><a class="header" href="#33">33、</a></h2>
<p><code>剑指 Offer II 033. 变位词组</code></p>
<p>给定一个字符串数组，将所有是同一类变位词的组合在一起</p>
<pre><code class="language-go">func groupAnagrams(strs []string) [][]string {
    mp := map[[26]int][]string{}
    for _, str := range strs {
        cnt := [26]int{}
        for _, b := range str {
            cnt[b-'a']++
        }
        mp[cnt] = append(mp[cnt], str)
    }
    ans := make([][]string, 0, len(mp))
    for _, v := range mp {
        ans = append(ans, v)
    }
    return ans
}
</code></pre>
<h2 id="34"><a class="header" href="#34">34、</a></h2>
<p><code>剑指 Offer II 034. 外星语言是否排序</code></p>
<p>给定一种新的order字符顺序，判断一个字符串数组words中的字符串是否是按照字典序进行排列的</p>
<pre><code class="language-go">func isAlienSorted(words []string, order string) bool {
    index := [26]int{}
    for i, c := range order {
        index[c-'a'] = i
    }
next:
    for i := 1; i &lt; len(words); i++ {
        for j := 0; j &lt; len(words[i-1]) &amp;&amp; j &lt; len(words[i]); j++ {
            pre, cur := index[words[i-1][j]-'a'], index[words[i][j]-'a']
            if pre &gt; cur {
                return false
            }
            if pre &lt; cur {
                continue next
            }
        }
        if len(words[i-1]) &gt; len(words[i]) {
            return false
        }
    }
    return true
}
</code></pre>
<h2 id="35"><a class="header" href="#35">35、</a></h2>
<p><code>剑指 Offer II 035. 最小时间差</code></p>
<p>给定一个字符串列表，其中字符串是以"HH:MM"的24小时时间格式进行表示，找到列表中时间差最小值，并以分钟格式进行表示</p>
<pre><code class="language-go">func getMinutes(t string) int {
    return (int(t[0]-'0')*10+int(t[1]-'0'))*60 + int(t[3]-'0')*10 + int(t[4]-'0')
}

func findMinDifference(timePoints []string) int {
    if len(timePoints) &gt; 1440 {
        return 0
    }
    sort.Strings(timePoints)
    ans := math.MaxInt32
    t0Minutes := getMinutes(timePoints[0])
    preMinutes := t0Minutes
    for _, t := range timePoints[1:] {
        minutes := getMinutes(t)
        ans = min(ans, minutes-preMinutes) // 相邻时间的时间差
        preMinutes = minutes
    }
    ans = min(ans, t0Minutes+1440-preMinutes) // 首尾时间的时间差
    return ans
}

func min(a, b int) int {
    if a &gt; b {
        return b
    }
    return a
}
</code></pre>
<h2 id="36"><a class="header" href="#36">36、</a></h2>
<p><code>剑指 Offer II 036. 后缀表达式</code></p>
<p>给定一个token字符串列表，该token列表是逆波兰表达式，用来求该后缀表达式的结果，整数除法只保留整数部分</p>
<pre><code class="language-go">func evalRPN(tokens []string) int {
    stack := make([]int, (len(tokens)+1)/2)
    index := -1
    for _, token := range tokens {
        val, err := strconv.Atoi(token)
        if err == nil {
            index++
            stack[index] = val
        } else {
            index--
            switch token {
            case "+":
                stack[index] += stack[index+1]
            case "-":
                stack[index] -= stack[index+1]
            case "*":
                stack[index] *= stack[index+1]
            default:
                stack[index] /= stack[index+1]
            }
        }
    }
    return stack[0]
}
</code></pre>
<h2 id="37"><a class="header" href="#37">37、</a></h2>
<p><code>剑指 Offer II 037. 小行星碰撞</code></p>
<p>给定一个整数数组用来表示同一行的小行星，绝对值表示大小，正负表示方向，正表示向右移动，负表示向左移动。</p>
<p>当两个行星相遇会进行碰撞，留下大小大的那个，大小相同两个一起爆炸</p>
<p>求解最后的小行星情况</p>
<pre><code class="language-go">func asteroidCollision(asteroids []int) (st []int) {
    for _, aster := range asteroids {
        alive := true
        for alive &amp;&amp; aster &lt; 0 &amp;&amp; len(st) &gt; 0 &amp;&amp; st[len(st)-1] &gt; 0 {
            alive = st[len(st)-1] &lt; -aster // aster 是否存在
            if st[len(st)-1] &lt;= -aster {   // 栈顶小行星爆炸
                st = st[:len(st)-1]
            }
        }
        if alive {
            st = append(st, aster)
        }
    }
    return
}
</code></pre>
<h2 id="38"><a class="header" href="#38">38、</a></h2>
<p><code>剑指 Offer II 038. 每日温度</code></p>
<p>给定一个每天的气温列表，返回最近的一个温度更高的相差的天数</p>
<pre><code class="language-go">func dailyTemperatures(temperatures []int) []int {
    length := len(temperatures)
    ans := make([]int, length)
    stack := []int{}
    for i := 0; i &lt; length; i++ {
        temperature := temperatures[i]
        for len(stack) &gt; 0 &amp;&amp; temperature &gt; temperatures[stack[len(stack)-1]] {
            prevIndex := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            ans[prevIndex] = i - prevIndex
        }
        stack = append(stack, i)
    }
    return ans
}
</code></pre>
<h2 id="39"><a class="header" href="#39">39、</a></h2>
<p><code>剑指 Offer II 039. 直方图最大矩形面积</code></p>
<p>给定一个整数数组，表示一个二维平面，其中每个元素表示其y轴的高度，返回该二维平面中覆盖的最大的矩形面积</p>
<pre><code class="language-go">func largestRectangleArea(heights []int) int {
    n := len(heights)
    left, right := make([]int, n), make([]int, n)
    mono_stack := []int{}
    for i := 0; i &lt; n; i++ {
        for len(mono_stack) &gt; 0 &amp;&amp; heights[mono_stack[len(mono_stack)-1]] &gt;= heights[i] {
            mono_stack = mono_stack[:len(mono_stack)-1]
        }
        if len(mono_stack) == 0 {
            left[i] = -1
        } else {
            left[i] = mono_stack[len(mono_stack)-1]
        }
        mono_stack = append(mono_stack, i)
    }
    mono_stack = []int{}
    for i := n - 1; i &gt;= 0; i-- {
        for len(mono_stack) &gt; 0 &amp;&amp; heights[mono_stack[len(mono_stack)-1]] &gt;= heights[i] {
            mono_stack = mono_stack[:len(mono_stack)-1]
        }
        if len(mono_stack) == 0 {
            right[i] = n
        } else {
            right[i] = mono_stack[len(mono_stack)-1]
        }
        mono_stack = append(mono_stack, i)
    }
    ans := 0
    for i := 0; i &lt; n; i++ {
        ans = max(ans, (right[i] - left[i] - 1) * heights[i])
    }
    return ans
}

func max(x, y int) int {
    if x &gt; y {
        return x
    }
    return y
}
</code></pre>
<h2 id="40"><a class="header" href="#40">40、</a></h2>
<p><code>剑指 Offer II 040. 矩阵中最大的矩形</code></p>
<p>一个只包含0、1元素的矩阵，找到全部为1的元素的最大矩阵的面积</p>
<pre><code class="language-go">func maximalRectangle(matrix []string) (ans int) {
    if len(matrix) == 0 {
        return
    }
    m, n := len(matrix), len(matrix[0])
    left := make([][]int, m)
    for i, row := range matrix {
        left[i] = make([]int, n)
        for j, v := range row {
            if v == '0' {
                continue
            }
            if j == 0 {
                left[i][j] = 1
            } else {
                left[i][j] = left[i][j-1] + 1
            }
        }
    }
    for i, row := range matrix {
        for j, v := range row {
            if v == '0' {
                continue
            }
            width := left[i][j]
            area := width
            for k := i - 1; k &gt;= 0; k-- {
                width = min(width, left[k][j])
                if width == 0 {
                    break
                }
                area = max(area, (i-k+1)*width)
            }
            ans = max(ans, area)
        }
    }
    return
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>
<h2 id="41"><a class="header" href="#41">41、</a></h2>
<p><code>剑指 Offer II 041. 滑动窗口的平均值</code></p>
<p>给定一个指定大小的窗口，提供数据流并返回这个窗口内的元素的平均值</p>
<pre><code class="language-go">type MovingAverage struct {
    size, sum int
    q         []int
}

func Constructor(size int) MovingAverage {
    return MovingAverage{size: size}
}

func (m *MovingAverage) Next(val int) float64 {
    if len(m.q) == m.size {
        m.sum -= m.q[0]
        m.q = m.q[1:]
    }
    m.sum += val
    m.q = append(m.q, val)
    return float64(m.sum) / float64(len(m.q))
}
</code></pre>
<h2 id="42"><a class="header" href="#42">42、</a></h2>
<p><code>剑指 Offer II 042. 最近请求次数</code></p>
<p>记录请求的时间等，并且返回最近3000ms内的调用次数</p>
<pre><code class="language-go">type RecentCounter []int

func Constructor() (_ RecentCounter) { return }

func (q *RecentCounter) Ping(t int) int {
    *q = append(*q, t)
    for (*q)[0] &lt; t-3000 {
        *q = (*q)[1:]
    }
    return len(*q)
}
</code></pre>
<h2 id="43"><a class="header" href="#43">43、</a></h2>
<p><code>剑指 Offer II 043. 往完全二叉树添加节点</code></p>
<p>一个尽量集中在左边的完全二叉树，提供插入以及获取根节点的元素</p>
<pre><code class="language-go">type CBTInserter struct {
    root      *TreeNode
    candidate []*TreeNode
}

func Constructor(root *TreeNode) CBTInserter {
    q := []*TreeNode{root}
    candidate := []*TreeNode{}
    for len(q) &gt; 0 {
        node := q[0]
        q = q[1:]
        if node.Left != nil {
            q = append(q, node.Left)
        }
        if node.Right != nil {
            q = append(q, node.Right)
        }
        if node.Left == nil || node.Right == nil {
            candidate = append(candidate, node)
        }
    }
    return CBTInserter{root, candidate}
}

func (c *CBTInserter) Insert(val int) int {
    child := &amp;TreeNode{Val: val}
    node := c.candidate[0]
    if node.Left == nil {
        node.Left = child
    } else {
        node.Right = child
        c.candidate = c.candidate[1:]
    }
    c.candidate = append(c.candidate, child)
    return node.Val
}

func (c *CBTInserter) Get_root() *TreeNode {
    return c.root
}
</code></pre>
<h2 id="44"><a class="header" href="#44">44、</a></h2>
<p><code>剑指 Offer II 044. 二叉树每层的最大值</code></p>
<p>给定一个二叉树，找出二叉树每一层的最大值</p>
<pre><code class="language-go">func largestValues(root *TreeNode) (ans []int) {
    var dfs func(*TreeNode, int)
    dfs = func(node *TreeNode, curHeight int) {
        if node == nil {
            return
        }
        if curHeight == len(ans) {
            ans = append(ans, node.Val)
        } else {
            ans[curHeight] = max(ans[curHeight], node.Val)
        }
        dfs(node.Left, curHeight+1)
        dfs(node.Right, curHeight+1)
    }
    dfs(root, 0)
    return
}

func max(a, b int) int {
    if b &gt; a {
        return b
    }
    return a
}
</code></pre>
<h2 id="45"><a class="header" href="#45">45、</a></h2>
<p><code>剑指 Offer II 045. 二叉树最底层最左边的值</code></p>
<p>给定一个二叉树，找出二叉树最底层，最左边的元素</p>
<pre><code class="language-go">func findBottomLeftValue(root *TreeNode) (curVal int) {
    curHeight := 0
    var dfs func(*TreeNode, int)
    dfs = func(node *TreeNode, height int) {
        if node == nil {
            return
        }
        height++
        dfs(node.Left, height)
        dfs(node.Right, height)
        if height &gt; curHeight {
            curHeight = height
            curVal = node.Val
        }
    }
    dfs(root, 0)
    return
}
</code></pre>
<h2 id="46"><a class="header" href="#46">46、</a></h2>
<p><code>剑指 Offer II 046. 二叉树的右侧视图</code></p>
<p>给定一个二叉树，返回其右边的第一层视图，并从上往下打印出来</p>
<pre><code class="language-go">/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    ans:=[]int{}
    if root==nil{
        return  ans
    }
    var dfs func(node *TreeNode,depth int)
    dfs = func(node *TreeNode,depth int){
        if node==nil{
            return
        }
        
        if len(ans)==depth{
            ans = append(ans,node.Val)
        }
        dfs(node.Right,depth+1)
        dfs(node.Left,depth+1)
    }
    dfs(root,0)
    return ans
}
</code></pre>
<h2 id="47"><a class="header" href="#47">47、</a></h2>
<p><code>剑指 Offer II 047. 二叉树剪枝</code></p>
<p>给定一个二叉树，对所有只包含0数据的子树进行剪枝</p>
<pre><code class="language-go">
func pruneTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    root.Left = pruneTree(root.Left)
    root.Right = pruneTree(root.Right)
    if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; root.Val == 0 {
        return nil
    }
    return root
}
</code></pre>
<h2 id="48"><a class="header" href="#48">48、</a></h2>
<p><code>剑指 Offer II 048. 序列化与反序列化二叉树</code></p>
<p>将二叉树进行序列化和反序列化</p>
<pre><code class="language-go">type Codec struct{}

func Constructor() (_ Codec) {
    return
}

func (Codec) serialize(root *TreeNode) string {
    sb := &amp;strings.Builder{}
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            sb.WriteString("null,")
            return
        }
        sb.WriteString(strconv.Itoa(node.Val))
        sb.WriteByte(',')
        dfs(node.Left)
        dfs(node.Right)
    }
    dfs(root)
    return sb.String()
}

func (Codec) deserialize(data string) *TreeNode {
    sp := strings.Split(data, ",")
    var build func() *TreeNode
    build = func() *TreeNode {
        if sp[0] == "null" {
            sp = sp[1:]
            return nil
        }
        val, _ := strconv.Atoi(sp[0])
        sp = sp[1:]
        return &amp;TreeNode{val, build(), build()}
    }
    return build()
}
</code></pre>
<h2 id="49"><a class="header" href="#49">49、</a></h2>
<p><code>剑指 Offer II 049. 从根节点到叶节点的路径数字之和</code></p>
<p>给定一个二叉树，获取从根节点到叶子节点的所有路径所表示的数字之和。</p>
<pre><code class="language-go">func dfs(root *TreeNode, prevSum int) int {
    if root == nil {
        return 0
    }
    sum := prevSum*10 + root.Val
    if root.Left == nil &amp;&amp; root.Right == nil {
        return sum
    }
    return dfs(root.Left, sum) + dfs(root.Right, sum)
}

func sumNumbers(root *TreeNode) int {
    return dfs(root, 0)
}
</code></pre>
<h2 id="50"><a class="header" href="#50">50、</a></h2>
<p><code>剑指 Offer II 050. 向下的路径节点之和</code></p>
<p>给定一个二叉树，返回其中路径和为target的路径个数，其中这路径只能从上往下</p>
<pre><code class="language-go">func pathSum(root *TreeNode, targetSum int) (ans int) {
    preSum := map[int64]int{0: 1}
    var dfs func(*TreeNode, int64)
    dfs = func(node *TreeNode, curr int64) {
        if node == nil {
            return
        }
        curr += int64(node.Val)
        ans += preSum[curr-int64(targetSum)]
        preSum[curr]++
        dfs(node.Left, curr)
        dfs(node.Right, curr)
        preSum[curr]--
        return
    }
    dfs(root, 0)
    return
}
</code></pre>
<h2 id="51"><a class="header" href="#51">51、</a></h2>
<p><code>剑指 Offer II 051. 节点之和最大的路径</code></p>
<p>给定一个二叉树，返回其最大的路径和，这里的路径可以是任意两个节点之间相连的路径</p>
<pre><code class="language-go">func maxPathSum(root *TreeNode) int {
    maxSum := math.MinInt32
    var maxGain func(*TreeNode) int
    maxGain = func(node *TreeNode) int {
        if node == nil {
            return 0
        }

        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        leftGain := max(maxGain(node.Left), 0)
        rightGain := max(maxGain(node.Right), 0)

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        priceNewPath := node.Val + leftGain + rightGain

        // 更新答案
        maxSum = max(maxSum, priceNewPath)

        // 返回节点的最大贡献值
        return node.Val + max(leftGain, rightGain)
    }
    maxGain(root)
    return maxSum
}

func max(x, y int) int {
    if x &gt; y {
        return x
    }
    return y
}
</code></pre>
<h2 id="52"><a class="header" href="#52">52、</a></h2>
<p><code>剑指 Offer II 052. 展平二叉搜索树</code></p>
<p>给定一个二叉搜索树，将其进行结构转换，使得没有左节点，只有右节点</p>
<pre><code class="language-go">func increasingBST(root *TreeNode) *TreeNode {
    dummyNode := &amp;TreeNode{}
    resNode := dummyNode

    var inorder func(*TreeNode)
    inorder = func(node *TreeNode) {
        if node == nil {
            return
        }
        inorder(node.Left)

        // 在中序遍历的过程中修改节点指向
        resNode.Right = node
        node.Left = nil
        resNode = node

        inorder(node.Right)
    }
    inorder(root)

    return dummyNode.Right
}
</code></pre>
<h2 id="53"><a class="header" href="#53">53、</a></h2>
<p><code>剑指 Offer II 053. 二叉搜索树中的中序后继</code></p>
<p>给定一个二叉搜索树以及一个节点，找到这个节点的中序后继</p>
<pre><code class="language-go">func inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode {
    var successor *TreeNode
    if p.Right != nil {
        successor = p.Right
        for successor.Left != nil {
            successor = successor.Left
        }
        return successor
    }
    node := root
    for node != nil {
        if node.Val &gt; p.Val {
            successor = node
            node = node.Left
        } else {
            node = node.Right
        }
    }
    return successor
}
</code></pre>
<h2 id="54"><a class="header" href="#54">54、</a></h2>
<p><code>剑指 Offer II 054. 所有大于等于节点的值之和</code></p>
<p>给定一个二叉搜索树，将每个节点替换成大于他节点的元素的和</p>
<pre><code class="language-go">func convertBST(root *TreeNode) *TreeNode {
    sum := 0
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node != nil {
            dfs(node.Right)
            sum += node.Val
            node.Val = sum
            dfs(node.Left)
        }
    }
    dfs(root)
    return root
}
</code></pre>
<h2 id="55"><a class="header" href="#55">55、</a></h2>
<p><code>剑指 Offer II 055. 二叉搜索树迭代器</code></p>
<p>给定一个二叉搜素树迭代器，提供next和hasNext两个方法</p>
<pre><code class="language-go">type BSTIterator struct {
    stack []*TreeNode
    cur   *TreeNode
}

func Constructor(root *TreeNode) BSTIterator {
    return BSTIterator{cur: root}
}

func (it *BSTIterator) Next() int {
    for node := it.cur; node != nil; node = node.Left {
        it.stack = append(it.stack, node)
    }
    it.cur, it.stack = it.stack[len(it.stack)-1], it.stack[:len(it.stack)-1]
    val := it.cur.Val
    it.cur = it.cur.Right
    return val
}

func (it *BSTIterator) HasNext() bool {
    return it.cur != nil || len(it.stack) &gt; 0
}
</code></pre>
<h2 id="56"><a class="header" href="#56">56、</a></h2>
<p><code>剑指 Offer II 056. 二叉搜索树中两个节点之和</code></p>
<p>判断二叉搜索树中是否存在两个节点，和为目标值</p>
<pre><code class="language-go">func findTarget(root *TreeNode, k int) bool {
    visit := map[int]struct{}{}
    flag := false
    var inorder func(*TreeNode)
    inorder = func(node *TreeNode) {
        if node == nil || flag {
            return
        }
        inorder(node.Left)
        if _, ok := visit[k-node.Val]; ok {
            flag = true
            return
        }
        visit[node.Val] = struct{}{}
        inorder(node.Right)
    }
    inorder(root)
    return flag
}
</code></pre>
<h2 id="57"><a class="header" href="#57">57、</a></h2>
<p><code>剑指 Offer II 057. 值和下标之差都在给定的范围内</code></p>
<p>给定一个数组，判断是否存在两个下标i、j，下标差绝对值小于等于k，所对应的值差值小于等于t</p>
<pre><code class="language-go">func getID(x, w int) int {
    if x &gt;= 0 {
        return x / w
    }
    return (x+1)/w - 1
}

func containsNearbyAlmostDuplicate(nums []int, k, t int) bool {
    mp := map[int]int{}
    for i, x := range nums {
        id := getID(x, t+1)
        if _, has := mp[id]; has {
            return true
        }
        if y, has := mp[id-1]; has &amp;&amp; abs(x-y) &lt;= t {
            return true
        }
        if y, has := mp[id+1]; has &amp;&amp; abs(x-y) &lt;= t {
            return true
        }
        mp[id] = x
        if i &gt;= k {
            delete(mp, getID(nums[i-k], t+1))
        }
    }
    return false
}

func abs(x int) int {
    if x &lt; 0 {
        return -x
    }
    return x
}
</code></pre>
<h2 id="58"><a class="header" href="#58">58、</a></h2>
<p><code>剑指 Offer II 058. 日程表</code></p>
<p>提供一个方法，在添加日程的时候，时间区间为<code>[start, end)</code>, 只要这个时间段没有其他安排就能够使用</p>
<pre><code class="language-go">type MyCalendar struct {
    tree, lazy map[int]bool
}

func Constructor() MyCalendar {
    return MyCalendar{map[int]bool{}, map[int]bool{}}
}

func (c MyCalendar) query(start, end, l, r, idx int) bool {
    if r &lt; start || end &lt; l {
        return false
    }
    if c.lazy[idx] { // 如果该区间已被预订，则直接返回
        return true
    }
    if start &lt;= l &amp;&amp; r &lt;= end {
        return c.tree[idx]
    }
    mid := (l + r) &gt;&gt; 1
    return c.query(start, end, l, mid, 2*idx) ||
        c.query(start, end, mid+1, r, 2*idx+1)
}

func (c MyCalendar) update(start, end, l, r, idx int) {
    if r &lt; start || end &lt; l {
        return
    }
    if start &lt;= l &amp;&amp; r &lt;= end {
        c.tree[idx] = true
        c.lazy[idx] = true
    } else {
        mid := (l + r) &gt;&gt; 1
        c.update(start, end, l, mid, 2*idx)
        c.update(start, end, mid+1, r, 2*idx+1)
        c.tree[idx] = true
        if c.lazy[2*idx] &amp;&amp; c.lazy[2*idx+1] {
            c.lazy[idx] = true
        }
    }
}

func (c MyCalendar) Book(start, end int) bool {
    if c.query(start, end-1, 0, 1e9, 1) {
        return false
    }
    c.update(start, end-1, 0, 1e9, 1)
    return true
}
</code></pre>
<h2 id="59"><a class="header" href="#59">59、</a></h2>
<p><code>剑指 Offer II 059. 数据流的第 K 大数值</code></p>
<p>一个数据流结构，在插入元素的时候返回数据中第k大的数。</p>
<pre><code class="language-go">type KthLargest struct {
    sort.IntSlice
    k int
}

func Constructor(k int, nums []int) KthLargest {
    kl := KthLargest{k: k}
    for _, val := range nums {
        kl.Add(val)
    }
    return kl
}

func (kl *KthLargest) Push(v interface{}) {
    kl.IntSlice = append(kl.IntSlice, v.(int))
}

func (kl *KthLargest) Pop() interface{} {
    a := kl.IntSlice
    v := a[len(a)-1]
    kl.IntSlice = a[:len(a)-1]
    return v
}

func (kl *KthLargest) Add(val int) int {
    heap.Push(kl, val)
    if kl.Len() &gt; kl.k {
        heap.Pop(kl)
    }
    return kl.IntSlice[0]
}
</code></pre>
<h2 id="60"><a class="header" href="#60">60、</a></h2>
<p>剑指 Offer II 060. 出现频率最高的 k 个数字</p>
<p>统计数字数组中元素的出现次数，返回出现频率最高的几个</p>
<pre><code class="language-go">func topKFrequent(nums []int, k int) []int {
    occurrences := map[int]int{}
    for _, num := range nums {
        occurrences[num]++
    }
    h := &amp;IHeap{}
    heap.Init(h)
    for key, value := range occurrences {
        heap.Push(h, [2]int{key, value})
        if h.Len() &gt; k {
            heap.Pop(h)
        }
    }
    ret := make([]int, k)
    for i := 0; i &lt; k; i++ {
        ret[k - i - 1] = heap.Pop(h).([2]int)[0]
    }
    return ret
}

type IHeap [][2]int

func (h IHeap) Len() int           { return len(h) }
func (h IHeap) Less(i, j int) bool { return h[i][1] &lt; h[j][1] }
func (h IHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IHeap) Push(x interface{}) {
    *h = append(*h, x.([2]int))
}

func (h *IHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="61"><a class="header" href="#61">61、</a></h2>
<p><code>剑指 Offer II 061. 和最小的 k 个数对</code></p>
<p>给定两个升序数组，找到前n小的数对</p>
<pre><code class="language-go">func kSmallestPairs(nums1, nums2 []int, k int) (ans [][]int) {
    h := hp{nums1: nums1, nums2: nums2}
    m, n := len(nums1), len(nums2)
    for i := 0; i &lt; k &amp;&amp; i &lt; m; i++ {
        heap.Push(&amp;h, pair{i, 0})
    }
    for h.Len() &gt; 0 &amp;&amp; len(ans) &lt; k {
        p := heap.Pop(&amp;h).(pair)
        i, j := p.i, p.j
        ans = append(ans, []int{nums1[i], nums2[j]})
        if j + 1 &lt; n {
            heap.Push(&amp;h, pair{i, j+1})
        }
    }
    return
}

type hp struct{
    data []pair
    nums1, nums2 []int
}

type pair struct{
    i, j int
}

func (h hp) Len() int {
    return len(h.data)
}

func (h hp) Less(i, j int) bool {
    p1, p2 := h.data[i], h.data[j]
    return h.nums1[p1.i] + h.nums2[p1.j] &lt; h.nums1[p2.i] + h.nums2[p2.j]
}

func (h hp) Swap(i, j int) {
    h.data[i], h.data[j] = h.data[j], h.data[i]
}

func (h *hp) Push(val interface{}) {
    h.data = append(h.data, val.(pair))
}

func (h *hp) Pop() interface{} {
    data := h.data
    val := data[len(data)-1]
    h.data = data[:len(data)-1]
    return val
}
</code></pre>
<h2 id="62"><a class="header" href="#62">62、</a></h2>
<p><code>剑指 Offer II 062. 实现前缀树</code></p>
<p>设计一个前缀树，提供数据插入，数据搜索，判断是否存在某个前缀</p>
<pre><code class="language-go">type Trie struct {
    children [26]*Trie
    isEnd    bool
}

func Constructor() Trie {
    return Trie{}
}

func (t *Trie) Insert(word string) {
    node := t
    for _, ch := range word {
        ch -= 'a'
        if node.children[ch] == nil {
            node.children[ch] = &amp;Trie{}
        }
        node = node.children[ch]
    }
    node.isEnd = true
}

func (t *Trie) SearchPrefix(prefix string) *Trie {
    node := t
    for _, ch := range prefix {
        ch -= 'a'
        if node.children[ch] == nil {
            return nil
        }
        node = node.children[ch]
    }
    return node
}

func (t *Trie) Search(word string) bool {
    node := t.SearchPrefix(word)
    return node != nil &amp;&amp; node.isEnd
}

func (t *Trie) StartsWith(prefix string) bool {
    return t.SearchPrefix(prefix) != nil
}
</code></pre>
<h2 id="63"><a class="header" href="#63">63、</a></h2>
<p><code>剑指 Offer II 063. 替换单词</code></p>
<p>当一个词为另一个词的前缀那么称其为词根，后者称为继承词</p>
<p>给定一个词根数组，一个句子，将句子中的所有词语，如果存在其词根，那么就用词根进行替换</p>
<pre><code class="language-go">func replaceWords(dictionary []string, sentence string) string {
    type trie map[rune]trie
    root := trie{}
    for _, s := range dictionary {
        cur := root
        for _, c := range s {
            if cur[c] == nil {
                cur[c] = trie{}
            }
            cur = cur[c]
        }
        cur['#'] = trie{}
    }

    words := strings.Split(sentence, " ")
    for i, word := range words {
        cur := root
        for j, c := range word {
            if cur['#'] != nil {
                words[i] = word[:j]
                break
            }
            if cur[c] == nil {
                break
            }
            cur = cur[c]
        }
    }
    return strings.Join(words, " ")
}
</code></pre>
<h2 id="64"><a class="header" href="#64">64、</a></h2>
<p><code>剑指 Offer II 064. 神奇的字典</code></p>
<p>一个初始字符串列表，提供一个搜索方法，判断需要搜索的字符串进行一次字符替换后是否出现在初始字符串列表。</p>
<pre><code class="language-go">type MagicDictionary struct {
    trie *trie
}

type trie struct{
    children [26]*trie
    isEnd bool
}

/** Initialize your data structure here. */
func Constructor() MagicDictionary {
    return MagicDictionary{trie: &amp;trie{}}
}


func (this *MagicDictionary) BuildDict(dictionary []string)  {
    for _, word := range dictionary {
        cur := this.trie
        for _, ch := range word {
            idx := ch - 'a'
            if cur.children[idx] == nil {
                cur.children[idx] = &amp;trie{}
            }
            cur = cur.children[idx]
        }
        cur.isEnd = true
    }
}


func (this *MagicDictionary) Search(searchWord string) bool {
    var dfs func(node *trie, searchWord string, modified bool) bool
    dfs = func(node *trie, searchWord string, modified bool) bool {
        if searchWord == "" {
            return modified &amp;&amp; node.isEnd
        }
        c := searchWord[0] - 'a'
        if node.children[c] != nil &amp;&amp; dfs(node.children[c], searchWord[1:], modified) {
            return true
        }
        if !modified {
            for i, child := range node.children {
                if i != int(c) &amp;&amp; child != nil &amp;&amp; dfs(child, searchWord[1:], true) {
                    return true
                }
            }
        }
        return false
    }
    return dfs(this.trie, searchWord, false)
}
</code></pre>
<h2 id="65"><a class="header" href="#65">65、</a></h2>
<p><code>剑指 Offer II 065. 最短的单词编码</code></p>
<blockquote>
<p>暂时没理解到含义，详情查看https://leetcode.cn/problems/iSwD2y/?favorite=e8X3pBZi</p>
</blockquote>
<pre><code class="language-go">
type Trie struct {
	child [26]*Trie
	depth int
}

func Constructor() *Trie {
	return &amp;Trie{
		child: [26]*Trie{},
		depth: 1,
	}
}

func (t *Trie) Insert(word string) {
	curr := t
	n := len(word)
	for i := n - 1; i &gt;= 0; i-- {
		c := word[i] - 'a'
		if curr.child[c] == nil {
			curr.child[c] = Constructor()
		}
		curr.child[c].depth = curr.depth + 1
		curr = curr.child[c]
	}
}

func minimumLengthEncoding(words []string) int {
	t := Constructor()
	for _, w := range words {
		t.Insert(w)
	}
	var res int
	var dfs func(node *Trie)
	dfs = func(node *Trie) {
		var hasChild bool
		for i := 0; i &lt; 26; i++ {
			if node.child[i] != nil {
				hasChild = true
				dfs(node.child[i])
			}
		}
		if !hasChild {
			res += node.depth
		}
	}
	dfs(t)
	return res
}
</code></pre>
<h2 id="66"><a class="header" href="#66">66、</a></h2>
<p><code>剑指 Offer II 066. 单词之和</code></p>
<p>提供两个方法，插入字符串以及个数，查询一个前缀所包含的值的大小。</p>
<p>如果该key已经存在则进行替换，给定一个字符串查询以该字符串为前缀的元素总和</p>
<pre><code class="language-go">type TrieNode struct {
    children [26]*TrieNode
    val      int
}

type MapSum struct {
    root *TrieNode
    cnt  map[string]int
}

func Constructor() MapSum {
    return MapSum{
        &amp;TrieNode{}, 
        map[string]int{},
    }
}

func (m *MapSum) Insert(key string, val int) {
    delta := val
    if m.cnt[key] &gt; 0 {
        delta -= m.cnt[key]
    }
    m.cnt[key] = val
    node := m.root
    for _, ch := range key {
        ch -= 'a'
        if node.children[ch] == nil {
            node.children[ch] = &amp;TrieNode{}
        }
        node = node.children[ch]
        node.val += delta
    }
}

func (m *MapSum) Sum(prefix string) int {
    node := m.root
    for _, ch := range prefix {
        ch -= 'a'
        if node.children[ch] == nil {
            return 0
        }
        node = node.children[ch]
    }
    return node.val
}
</code></pre>
<h2 id="67"><a class="header" href="#67">67、</a></h2>
<p><code>剑指 Offer II 067. 最大的异或</code></p>
<p>给定一个整数数组，两两元素进行异或，找到最大值</p>
<pre><code class="language-go">const highBit = 30

type trie struct {
    left, right *trie
}

func (t *trie) add(num int) {
    cur := t
    for i := highBit; i &gt;= 0; i-- {
        bit := num &gt;&gt; i &amp; 1
        if bit == 0 {
            if cur.left == nil {
                cur.left = &amp;trie{}
            }
            cur = cur.left
        } else {
            if cur.right == nil {
                cur.right = &amp;trie{}
            }
            cur = cur.right
        }
    }
}

func (t *trie) check(num int) (x int) {
    cur := t
    for i := highBit; i &gt;= 0; i-- {
        bit := num &gt;&gt; i &amp; 1
        if bit == 0 {
            // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走
            if cur.right != nil {
                cur = cur.right
                x = x*2 + 1
            } else {
                cur = cur.left
                x = x * 2
            }
        } else {
            // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走
            if cur.left != nil {
                cur = cur.left
                x = x*2 + 1
            } else {
                cur = cur.right
                x = x * 2
            }
        }
    }
    return
}

func findMaximumXOR(nums []int) (x int) {
    root := &amp;trie{}
    for i := 1; i &lt; len(nums); i++ {
        // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中
        root.add(nums[i-1])
        // 将 nums[i] 看作 ai，找出最大的 x 更新答案
        x = max(x, root.check(nums[i]))
    }
    return
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>
<h2 id="68"><a class="header" href="#68">68、</a></h2>
<p><code>剑指 Offer II 068. 查找插入位置</code></p>
<p>往一个有序数组中进行数据插入，查找数据的插入位置，要求使用O(logn)复杂度</p>
<pre><code class="language-go">func searchInsert(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n - 1
    ans := n
    for left &lt;= right {
        mid := (right - left) &gt;&gt; 1 + left
        if target &lt;= nums[mid] {
            ans = mid
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return ans
}
</code></pre>
<h2 id="69"><a class="header" href="#69">69、</a></h2>
<p><code>剑指 Offer II 069. 山峰数组的顶部</code></p>
<p>找到下标i，在i之前是递增数据，在i之后是递减数据</p>
<p>题目保证满足存在这样的i</p>
<pre><code class="language-go">func peakIndexInMountainArray(arr []int) int {
    return sort.Search(len(arr)-1, func(i int) bool { return arr[i] &gt; arr[i+1] })
}
</code></pre>
<h2 id="70"><a class="header" href="#70">70、</a></h2>
<p>剑指 Offer II 070. 排序数组中只出现一次的数字</p>
<p>一个有序数组，有一个元素只出现一次，其他元素出现了两次，找到这个只出现了一次的元素，满足O(logn)时间复杂度，O(1)空间复杂度</p>
<pre><code class="language-go">func singleNonDuplicate(nums []int) int {
    low, high := 0, len(nums)-1
    for low &lt; high {
        mid := low + (high-low)/2
        if nums[mid] == nums[mid^1] {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return nums[low]
}
</code></pre>
<h2 id="71"><a class="header" href="#71">71、</a></h2>
<p><code>剑指 Offer II 071. 按权重生成随机数</code></p>
<p>按照值的大小作为权重占比进行随机数获取，返回其数据下标</p>
<pre><code class="language-go">type Solution struct {
    pre []int
}

func Constructor(w []int) Solution {
    for i := 1; i &lt; len(w); i++ {
        w[i] += w[i-1]
    }
    return Solution{w}
}

func (s *Solution) PickIndex() int {
    x := rand.Intn(s.pre[len(s.pre)-1]) + 1
    return sort.SearchInts(s.pre, x)
}
</code></pre>
<h2 id="72"><a class="header" href="#72">72、</a></h2>
<p><code>剑指 Offer II 072. 求平方根</code></p>
<p>计算一个整数的开平方根，只取正数那一个</p>
<pre><code class="language-go">func mySqrt(x int) int {
    l, r := 0, x
    ans := -1
    for l &lt;= r {
        mid := l + (r - l) / 2
        if mid * mid &lt;= x {
            ans = mid
            l = mid + 1
        } else {
            r = mid - 1
        }
    }
    return ans
}
</code></pre>
<h2 id="73"><a class="header" href="#73">73、</a></h2>
<p><code>剑指 Offer II 073. 狒狒吃香蕉</code></p>
<p>n堆香蕉，在h小时内要吃完，选择要吃完所有香蕉的最小速度，不过需要注意如果选择了一堆香蕉后，小于k个也会等待下一个小时才会继续吃。</p>
<pre><code class="language-go">func minEatingSpeed(piles []int, h int) int {
    max := 0
    for _, pile := range piles {
        if pile &gt; max {
            max = pile
        }
    }
    return 1 + sort.Search(max-1, func(speed int) bool {
        speed++
        time := 0
        for _, pile := range piles {
            time += (pile + speed - 1) / speed
        }
        return time &lt;= h
    })
}
</code></pre>
<h2 id="74"><a class="header" href="#74">74、</a></h2>
<p><code>剑指 Offer II 074. 合并区间</code></p>
<p>给定一个元组数组，其中的元素即为一个左右区间，将所有重叠的区间进行合并，并返回一个不重叠的区间数组</p>
<pre><code class="language-go">func merge(intervals [][]int) [][]int {
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] &lt; intervals[j][0] || (intervals[i][0] == intervals[j][0] &amp;&amp; intervals[i][1] &lt; intervals[j][1])
	})
	var res [][]int
	for _, interval := range intervals {
		if len(res) == 0 || res[len(res)-1][1] &lt; interval[0] {
			res = append(res, interval)
		} else {
			res[len(res)-1][1] = max(res[len(res)-1][1], interval[1])
		}
	}
	return res
}

func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</code></pre>
<h2 id="75"><a class="header" href="#75">75</a></h2>
<p><code>剑指 Offer II 075. 数组相对排序</code></p>
<p>给定两个数组arr1和arr2，将arr1按照arr2的顺序进行排序，未出现过的就按照升序之后放在arr1的末尾。</p>
<pre><code class="language-go">type zset map[int]int

func(zs *zset) keys() []int {
    res := []int{}
    for key := range *zs {
        res = append(res, key)
    }
    sort.Ints(res)
    return res
}

func relativeSortArray(arr1 []int, arr2 []int) []int {
    zs := zset{}
    for _, val := range arr1 {
        zs[val]++
    }

    res := make([]int, 0, len(arr1))
    for _, val := range arr2 {
        for i := 0; i &lt; zs[val]; i++ {
            res = append(res, val)
        }
        delete(zs, val)
    }
    for _, key := range zs.keys() {
        for i := 0; i &lt; zs[key]; i++ {
            res = append(res, key)
        }
    }
    return res
}
</code></pre>
<h2 id="76"><a class="header" href="#76">76</a></h2>
<p><code>剑指 Offer II 076. 数组中的第 k 大的数字</code></p>
<p>给定一个整数数组和整数，返回数组中第k个最大的元素</p>
<pre><code class="language-go">func findKthLargest(nums []int, k int) int {
    rand.Seed(time.Now().UnixNano())
    return quickSelect(nums, 0, len(nums)-1, len(nums)-k)
}

func quickSelect(a []int, l, r, index int) int {
    q := randomPartition(a, l, r)
    if q == index {
        return a[q]
    } else if q &lt; index {
        return quickSelect(a, q + 1, r, index)
    }
    return quickSelect(a, l, q - 1, index)
}

func randomPartition(a []int, l, r int) int {
    i := rand.Int() % (r - l + 1) + l
    a[i], a[r] = a[r], a[i]
    return partition(a, l, r)
}

func partition(a []int, l, r int) int {
    x := a[r]
    i := l - 1
    for j := l; j &lt; r; j++ {
        if a[j] &lt;= x {
            i++
            a[i], a[j] = a[j], a[i]
        }
    }
    a[i+1], a[r] = a[r], a[i+1]
    return i + 1
}
</code></pre>
<h2 id="77"><a class="header" href="#77">77</a></h2>
<p><code>剑指 Offer II 077. 链表排序</code></p>
<p>对链表节点进行升序排序</p>
<pre><code class="language-go">func merge(head1, head2 *ListNode) *ListNode {
    dummyHead := &amp;ListNode{}
    temp, temp1, temp2 := dummyHead, head1, head2
    for temp1 != nil &amp;&amp; temp2 != nil {
        if temp1.Val &lt;= temp2.Val {
            temp.Next = temp1
            temp1 = temp1.Next
        } else {
            temp.Next = temp2
            temp2 = temp2.Next
        }
        temp = temp.Next
    }
    if temp1 != nil {
        temp.Next = temp1
    } else if temp2 != nil {
        temp.Next = temp2
    }
    return dummyHead.Next
}

func sort(head, tail *ListNode) *ListNode {
    if head == nil {
        return head
    }

    if head.Next == tail {
        head.Next = nil
        return head
    }

    slow, fast := head, head
    for fast != tail {
        slow = slow.Next
        fast = fast.Next
        if fast != tail {
            fast = fast.Next
        }
    }

    mid := slow
    return merge(sort(head, mid), sort(mid, tail))
}

func sortList(head *ListNode) *ListNode {
    return sort(head, nil)
}
</code></pre>
<h2 id="78"><a class="header" href="#78">78</a></h2>
<p><code>剑指 Offer II 078. 合并排序链表</code></p>
<p>给定一个链表数组，将链表按照升序排列</p>
<pre><code class="language-go">//合并K个升序链表
func mergeKLists(lists []*ListNode) (res *ListNode) {
	for _, v := range lists {
		res = mergeTwoLists(res, v)
	}
	return res
}

//合并两个升序链表
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
	//初始化一个虚拟的头节点
	newList := &amp;ListNode{}
	p := newList
	p1 := list1
	p2 := list2
	//遍历对比两个指针值的大小，有一个走完了就停止
	for p1 != nil &amp;&amp; p2 != nil {
		//将值小的节点接到p指针后面
		if p1.Val &gt; p2.Val {
			p.Next = p2
			p2 = p2.Next
		} else {
			p.Next = p1
			p1 = p1.Next
		}
		//p指针前进
		p = p.Next
	}
	//将未比较的剩余节点都放到p指针后面
	if p1 != nil {
		p.Next = p1
	}
	if p2 != nil {
		p.Next = p2
	}
	//返回虚拟头节点的下一个节点就是真正的头节点
	return newList.Next
}
</code></pre>
<h2 id="79"><a class="header" href="#79">79</a></h2>
<p><code>剑指 Offer II 079. 所有子集</code></p>
<p>给定一个元素各不相同的的数组，返回所有不重复的子集</p>
<pre><code class="language-go">func subsets(nums []int) (ans [][]int) {
    n := len(nums)
    for mask := 0; mask &lt; 1&lt;&lt;n; mask++ {
        set := []int{}
        for i, v := range nums {
            if mask&gt;&gt;i&amp;1 &gt; 0 {
                set = append(set, v)
            }
        }
        ans = append(ans, append([]int(nil), set...))
    }
    return
}
</code></pre>
<h2 id="80"><a class="header" href="#80">80</a></h2>
<p><code>剑指 Offer II 080. 含有 k 个元素的组合</code></p>
<p>给定整数n和k，返回<code>1...n</code>中所有可能的k个数的组合</p>
<pre><code class="language-go">func combine(n int, k int) (ans [][]int) {
	temp := []int{}
	var dfs func(int)
	dfs = func(cur int) {
		// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp
		if len(temp) + (n - cur + 1) &lt; k {
			return
		}
		// 记录合法的答案
		if len(temp) == k {
			comb := make([]int, k)
			copy(comb, temp)
			ans = append(ans, comb)
			return
		}
		// 考虑选择当前位置
		temp = append(temp, cur)
		dfs(cur + 1)
		temp = temp[:len(temp)-1]
		// 考虑不选择当前位置
		dfs(cur + 1)
	}
	dfs(1)
	return
}
</code></pre>
<h2 id="81"><a class="header" href="#81">81</a></h2>
<p><code>剑指 Offer II 081. 允许重复选择元素的组合</code></p>
<p>从数组中寻找和为目标值的组合，数组中的元素可以重复选择</p>
<blockquote>
<p>下面这种题解是标准解法，不过不能去除重复的情况，详情看82</p>
</blockquote>
<pre><code class="language-go">func combinationSum(candidates []int, target int) (ans [][]int) {
	comb := []int{}
	var dfs func(target, idx int)
	dfs = func(target, idx int) {
		if idx == len(candidates) {
			return
		}
		if target == 0 {
			ans = append(ans, append([]int(nil), comb...))
			return
		}
		// 直接跳过
		dfs(target, idx+1)
		// 选择当前数
		if target-candidates[idx] &gt;= 0 {
			comb = append(comb, candidates[idx])
			dfs(target-candidates[idx], idx)
			comb = comb[:len(comb)-1]
		}
	}
	dfs(target, 0)
	return
}
</code></pre>
<h2 id="82"><a class="header" href="#82">82</a></h2>
<p><code>剑指 Offer II 082. 含有重复元素集合的组合</code></p>
<p>与81题类似，不过这里元素只能使用一次</p>
<pre><code class="language-go">func combinationSum2(candidates []int, target int) (ans [][]int) {
    sort.Ints(candidates)
    var freq [][2]int // [值，次数]
    for _, num := range candidates {
        if freq == nil || num != freq[len(freq)-1][0] {
            freq = append(freq, [2]int{num, 1})
        } else {
            freq[len(freq)-1][1]++
        }
    }

    var sequence []int
    var dfs func(pos, rest int)
    dfs = func(pos, rest int) {
        if rest == 0 {
            ans = append(ans, append([]int(nil), sequence...))
            return
        }
        if pos == len(freq) || rest &lt; freq[pos][0] {
            return
        }

        dfs(pos+1, rest)

        most := min(rest/freq[pos][0], freq[pos][1])
        for i := 1; i &lt;= most; i++ {
            sequence = append(sequence, freq[pos][0])
            dfs(pos+1, rest-i*freq[pos][0])
        }
        sequence = sequence[:len(sequence)-most]
    }
    dfs(0, target)
    return
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}
</code></pre>
<h2 id="83"><a class="header" href="#83">83</a></h2>
<p><code>剑指 Offer II 083. 没有重复元素集合的全排列</code></p>
<p>给定一个不包含重复数字的整数数组，返回所有可能的全排列</p>
<pre><code class="language-go">func permute(nums []int) [][]int {
	n := len(nums)
	var ans [][]int
	var path []int
	vis := make([]bool, n)
	var dfs func()
	dfs = func() {
		if len(path) == n {
			ans = append(ans, append([]int{}, path...))
			return
		}
		for i := 0; i &lt; n; i++ {
			if !vis[i] {
				vis[i] = true
				path = append(path, nums[i])
				dfs()
				vis[i] = false
				path = path[:len(path) - 1]
			}
		}
	}
	dfs()
	return ans
}
</code></pre>
<h2 id="84"><a class="header" href="#84">84</a></h2>
<p><code>剑指 Offer II 084. 含有重复元素集合的全排列</code></p>
<p>给定一个可包含重复数字的整数集合 nums ，按任意顺序 返回它所有不重复的全排列。</p>
<pre><code class="language-go">func permuteUnique(nums []int) (ans [][]int) {
    sort.Ints(nums)
    n := len(nums)
    perm := []int{}
    vis := make([]bool, n)
    var backtrack func(int)
    backtrack = func(idx int) {
        if idx == n {
            ans = append(ans, append([]int(nil), perm...))
            return
        }
        for i, v := range nums {
            if vis[i] || i &gt; 0 &amp;&amp; !vis[i-1] &amp;&amp; v == nums[i-1] {
                continue
            }
            perm = append(perm, v)
            vis[i] = true
            backtrack(idx + 1)
            vis[i] = false
            perm = perm[:len(perm)-1]
        }
    }
    backtrack(0)
    return
}
</code></pre>
<h2 id="85"><a class="header" href="#85">85</a></h2>
<p><code>剑指 Offer II 085. 生成匹配的括号</code></p>
<p>正整数 n 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<pre><code class="language-go">// 动态规划版本
func generateParenthesis(n int) []string {
	dp := make([][]string, n+1)
	dp[0] = []string{""}
	for i := 1; i &lt;= n; i++ {
		for j := 0; j &lt; i; j++ {
			for _, left := range dp[j] {
				for _, right := range dp[i-j-1] {
					dp[i] = append(dp[i], "("+left+")"+right)
				}
			}

		}
	}
	return dp[n]
}

// 递归版本
func generateParenthesis(n int) []string {
	var res []string
	var leftCnt, rightCnt int
	var tmp []byte
	var dfs func(cnt int)
	dfs = func(cnt int) {
		if cnt == n*2 {
			res = append(res, string(tmp))
			return
		}
		if leftCnt &lt; n {
			leftCnt++
			tmp = append(tmp, '(')
			dfs(cnt + 1)
			leftCnt--
			tmp = tmp[:len(tmp)-1]
		}
		if leftCnt &gt; rightCnt {
			rightCnt++
			tmp = append(tmp, ')')
			dfs(cnt + 1)
			rightCnt--
			tmp = tmp[:len(tmp)-1]
		}
	}
	dfs(0)
	return res
}
</code></pre>
<h2 id="86"><a class="header" href="#86">86</a></h2>
<p><code>剑指 Offer II 086. 分割回文子字符串</code></p>
<p>将字符串分割成回文串, 返回所有可能的方案</p>
<pre><code class="language-go">func partition(s string) (ans [][]string) {
    n := len(s)
    f := make([][]bool, n)
    for i := range f {
        f[i] = make([]bool, n)
        for j := range f[i] {
            f[i][j] = true
        }
    }
    for i := n - 1; i &gt;= 0; i-- {
        for j := i + 1; j &lt; n; j++ {
            f[i][j] = s[i] == s[j] &amp;&amp; f[i+1][j-1]
        }
    }

    splits := []string{}
    var dfs func(int)
    dfs = func(i int) {
        if i == n {
            ans = append(ans, append([]string(nil), splits...))
            return
        }
        for j := i; j &lt; n; j++ {
            if f[i][j] {
                splits = append(splits, s[i:j+1])
                dfs(j + 1)
                splits = splits[:len(splits)-1]
            }
        }
    }
    dfs(0)
    return
}
</code></pre>
<h2 id="87"><a class="header" href="#87">87</a></h2>
<p><code>剑指 Offer II 087. 复原 IP</code></p>
<p>将字符串格式化成所有合法的ipv4地址</p>
<pre><code class="language-go">const SEG_COUNT = 4

var (
    ans []string
    segments []int
)

func restoreIpAddresses(s string) []string {
    segments = make([]int, SEG_COUNT)
    ans = []string{}
    dfs(s, 0, 0)
    return ans
}

func dfs(s string, segId, segStart int) {
    // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
    if segId == SEG_COUNT {
        if segStart == len(s) {
            ipAddr := ""
            for i := 0; i &lt; SEG_COUNT; i++ {
                ipAddr += strconv.Itoa(segments[i])
                if i != SEG_COUNT - 1 {
                    ipAddr += "."
                }
            }
            ans = append(ans, ipAddr)
        }
        return
    }

    // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
    if segStart == len(s) {
        return
    }
    // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
    if s[segStart] == '0' {
        segments[segId] = 0
        dfs(s, segId + 1, segStart + 1)
    }
    // 一般情况，枚举每一种可能性并递归
    addr := 0
    for segEnd := segStart; segEnd &lt; len(s); segEnd++ {
        addr = addr * 10 + int(s[segEnd] - '0')
        if addr &gt; 0 &amp;&amp; addr &lt;= 0xFF {
            segments[segId] = addr
            dfs(s, segId + 1, segEnd + 1)
        } else {
            break
        }
    }
}
</code></pre>
<h2 id="88"><a class="header" href="#88">88</a></h2>
<p><code>剑指 Offer II 088. 爬楼梯的最少成本</code></p>
<p>给定一个一维数组表示爬楼梯需要的成本，并且每次支付一次就可以往上爬一个阶梯或者爬两个阶梯, 计算爬楼梯的最少成本。</p>
<pre><code class="language-go">func minCostClimbingStairs(cost []int) int {
    n := len(cost)
    pre, cur := 0, 0
    for i := 2; i &lt;= n; i++ {
        pre, cur = cur, min(cur+cost[i-1], pre+cost[i-2])
    }
    return cur
}

func min(a, b int) int {
    if a &lt; b {
        return a
    }
    return b
}
</code></pre>
<h2 id="89"><a class="header" href="#89">89</a></h2>
<p><code>剑指 Offer II 089. 房屋偷盗</code></p>
<p>给定一个一维数组表示每间房子的价值，不能偷相邻的两家，问能够偷窃到的最高金额</p>
<pre><code class="language-go">func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i &lt; len(nums); i++ {
        dp[i] = max(dp[i-2] + nums[i], dp[i-1])
    }
    return dp[len(nums)-1]
}

func max(x, y int) int {
    if x &gt; y {
        return x
    }
    return y
}
</code></pre>
<h2 id="90"><a class="header" href="#90">90</a></h2>
<p><code>剑指 Offer II 090. 环形房屋偷盗</code></p>
<p>与上一题类似，不过这一题房屋是首位相连的，问能够偷窃到的最大价值</p>
<pre><code class="language-go">func _rob(nums []int) int {
    first, second := nums[0], max(nums[0], nums[1])
    for _, v := range nums[2:] {
        first, second = second, max(first+v, second)
    }
    return second
}

func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }
    if n == 2 {
        return max(nums[0], nums[1])
    }
    return max(_rob(nums[:n-1]), _rob(nums[1:]))
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="91"><a class="header" href="#91">91</a></h2>
<p><code>剑指 Offer II 091. 粉刷房子</code></p>
<p>一排房子n个，可以涂成红色、蓝色、绿色这三种颜色中的一种，需要让各个颜色并不相同</p>
<p>给定一个花费数组，其中的每个元素就是该房子涂成红、蓝、绿三种颜色所需要的花费</p>
<p>计算粉刷完所有房子最少的花费成本</p>
<pre><code class="language-go">func minCost(costs [][]int) int {
    dp := costs[0]
    for _, cost := range costs[1:] {
        dpNew := make([]int, 3)
        for j, c := range cost {
            dpNew[j] = min(dp[(j+1)%3], dp[(j+2)%3]) + c
        }
        dp = dpNew
    }
    return min(min(dp[0], dp[1]), dp[2])
}

func min(a, b int) int {
    if a &gt; b {
        return b
    }
    return a
}
</code></pre>
<h2 id="92"><a class="header" href="#92">92</a></h2>
<p><code>剑指 Offer II 092. 翻转字符</code></p>
<p>一个<code>0 1</code>组成的字符串，求使得s单调递增(前面全是0 后面全是1)的最小翻转次数</p>
<pre><code class="language-go">func minFlipsMonoIncr(s string) int {
    dp0, dp1 := 0, 0
    for _, c := range s {
        dp0New, dp1New := dp0, min(dp0, dp1)
        if c == '1' {
            dp0New++
        } else {
            dp1New++
        }
        dp0, dp1 = dp0New, dp1New
    }
    return min(dp0, dp1)
}

func min(a, b int) int {
    if a &gt; b {
        return b
    }
    return a
}
</code></pre>
<h2 id="93"><a class="header" href="#93">93</a></h2>
<p><code>剑指 Offer II 093. 最长斐波那契数列</code></p>
<p>给定一个递增的正整数数组，找到其中最长的一个满足斐波那契数列的元素</p>
<pre><code class="language-go">func lenLongestFibSubseq(arr []int) (ans int) {
    n := len(arr)
    indices := make(map[int]int, n)
    for i, x := range arr {
        indices[x] = i
    }
    dp := make([][]int, n)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    for i, x := range arr {
        for j := n - 1; j &gt;= 0 &amp;&amp; arr[j]*2 &gt; x; j-- {
            if k, ok := indices[x-arr[j]]; ok {
                dp[j][i] = max(dp[k][j]+1, 3)
                ans = max(ans, dp[j][i])
            }
        }
    }
    return
}

func max(a, b int) int {
    if b &gt; a {
        return b
    }
    return a
}
</code></pre>
<h2 id="94"><a class="header" href="#94">94</a></h2>
<p><code>剑指 Offer II 094. 最少回文分割</code></p>
<p>给定一个字符串s，找到分割的最小次数，将s分割成字串，且每个字串都是回文串，</p>
<pre><code class="language-go">func minCut(s string) int {
    n := len(s)
    g := make([][]bool, n)
    for i := range g {
        g[i] = make([]bool, n)
        for j := range g[i] {
            g[i][j] = true
        }
    }
    for i := n - 1; i &gt;= 0; i-- {
        for j := i + 1; j &lt; n; j++ {
            g[i][j] = s[i] == s[j] &amp;&amp; g[i+1][j-1]
        }
    }

    f := make([]int, n)
    for i := range f {
        if g[0][i] {
            continue
        }
        f[i] = math.MaxInt64
        for j := 0; j &lt; i; j++ {
            if g[j+1][i] &amp;&amp; f[j]+1 &lt; f[i] {
                f[i] = f[j] + 1
            }
        }
    }
    return f[n-1]
}
</code></pre>
<h2 id="95"><a class="header" href="#95">95</a></h2>
<p><code>剑指 Offer II 095. 最长公共子序列</code></p>
<p>找到两个字符串的最长的公共子序列(即满足不改变字符的相对顺序的情况下删除某些字符)</p>
<pre><code class="language-go">func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i, c1 := range text1 {
        for j, c2 := range text2 {
            if c1 == c2 {
                dp[i+1][j+1] = dp[i][j] + 1
            } else {
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a &gt; b {
        return a
    }
    return b
}
</code></pre>
<h2 id="96"><a class="header" href="#96">96</a></h2>
<p><code>剑指 Offer II 096. 字符串交织</code></p>
<p>判断两个字符串s1 s2交织(轮流选择元素)后是否与s3相等</p>
<pre><code class="language-go">func isInterleave(s1 string, s2 string, s3 string) bool {
    n, m, t := len(s1), len(s2), len(s3)
    if (n + m) != t {
        return false
    }
    f := make([]bool, m + 1)
    f[0] = true
    for i := 0; i &lt;= n; i++ {
        for j := 0; j &lt;= m; j++ {
            p := i + j - 1
            if i &gt; 0 {
                f[j] = f[j] &amp;&amp; s1[i-1] == s3[p]
            }
            if j &gt; 0 {
                f[j] = f[j] || f[j-1] &amp;&amp; s2[j-1] == s3[p]
            }
        }
    }
    return f[m]
}
</code></pre>
<h2 id="97"><a class="header" href="#97">97</a></h2>
<p><code>剑指 Offer II 097. 子序列的数目</code></p>
<p>判断字符串s中有多少个子序列是在t中出现了</p>
<pre><code class="language-go">func numDistinct(s, t string) int {
    m, n := len(s), len(t)
    if m &lt; n {
        return 0
    }
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
        dp[i][n] = 1
    }
    for i := m - 1; i &gt;= 0; i-- {
        for j := n - 1; j &gt;= 0; j-- {
            if s[i] == t[j] {
                dp[i][j] = dp[i+1][j+1] + dp[i+1][j]
            } else {
                dp[i][j] = dp[i+1][j]
            }
        }
    }
    return dp[0][0]
}
</code></pre>
<h2 id="98"><a class="header" href="#98">98</a></h2>
<p><code>剑指 Offer II 098. 路径的数目</code></p>
<p>一个<code>m*n</code>的网格，从左上到右下，只能向下或者向右移动一步，问总共有多少条不同的路径。</p>
<pre><code class="language-go">func uniquePaths(m, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }
    for j := 0; j &lt; n; j++ {
        dp[0][j] = 1
    }
    for i := 1; i &lt; m; i++ {
        for j := 1; j &lt; n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
</code></pre>
<h2 id="99"><a class="header" href="#99">99</a></h2>
<p><code>剑指 Offer II 099. 最小路径之和</code></p>
<p>一个<code>m*n</code>的网格，从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>每次向下或者向右移动一步</p>
<pre><code class="language-go">func minPathSum(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }
    rows, columns := len(grid), len(grid[0])
    dp := make([][]int, rows)
    for i := 0; i &lt; len(dp); i++ {
        dp[i] = make([]int, columns)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i &lt; rows; i++ {
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    }
    for j := 1; j &lt; columns; j++ {
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    }
    for i := 1; i &lt; rows; i++ {
        for j := 1; j &lt; columns; j++ {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
        }
    }
    return dp[rows - 1][columns - 1]
}

func min(x, y int) int {
    if x &lt; y {
        return x
    }
    return y
}
</code></pre>
<h2 id="100"><a class="header" href="#100">100</a></h2>
<p><code>剑指 Offer II 100. 三角形中最小路径之和</code></p>
<p>一个三角形的矩阵，从上往下找到最小路径之和</p>
<p>下标移动的时候只能移动到<code>i</code>以及<code>i+1</code></p>
<pre><code class="language-go">func minimumTotal(triangle [][]int) int {
    n := len(triangle)
    f := make([][]int, n)
    for i := 0; i &lt; n; i++ {
        f[i] = make([]int, n)
    }
    f[0][0] = triangle[0][0]
    for i := 1; i &lt; n; i++ {
        f[i][0] = f[i - 1][0] + triangle[i][0]
        for j := 1; j &lt; i; j++ {
            f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
        }
        f[i][i] = f[i - 1][i - 1] + triangle[i][i]
    }
    ans := math.MaxInt32
    for i := 0; i &lt; n; i++ {
        ans = min(ans, f[n-1][i])
    }
    return ans
}

func min(x, y int) int {
    if x &lt; y {
        return x
    }
    return y
}
</code></pre>
<h2 id="101"><a class="header" href="#101">101</a></h2>
<p><code>剑指 Offer II 101. 分割等和子集</code></p>
<p>给定一个非空的正整数数组 nums ，请判断能否将这些数字分成元素和相等的两部分。</p>
<pre><code class="language-go">func canPartition(nums []int) bool {
    n := len(nums)
    if n &lt; 2 {
        return false
    }

    sum, max := 0, 0
    for _, v := range nums {
        sum += v
        if v &gt; max {
            max = v
        }
    }
    if sum%2 != 0 {
        return false
    }

    target := sum / 2
    if max &gt; target {
        return false
    }

    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, target+1)
    }
    for i := 0; i &lt; n; i++ {
        dp[i][0] = true
    }
    dp[0][nums[0]] = true
    for i := 1; i &lt; n; i++ {
        v := nums[i]
        for j := 1; j &lt;= target; j++ {
            if j &gt;= v {
                dp[i][j] = dp[i-1][j] || dp[i-1][j-v]
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[n-1][target]
}
</code></pre>
<h2 id="102"><a class="header" href="#102">102</a></h2>
<p><code>剑指 Offer II 102. 加减的目标值</code></p>
<p>给定一个数组以及target值，提供正负符号使得数组中的和等于目标值</p>
<pre><code class="language-go">func findTargetSumWays(nums []int, target int) (count int) {
    var backtrack func(int, int)
    backtrack = func(index, sum int) {
        if index == len(nums) {
            if sum == target {
                count++
            }
            return
        }
        backtrack(index+1, sum+nums[index])
        backtrack(index+1, sum-nums[index])
    }
    backtrack(0, 0)
    return
}
</code></pre>
<h2 id="103"><a class="header" href="#103">103</a></h2>
<p>剑指 Offer II 103. 最少的硬币数目</p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>每种硬币的数量是无限的。</p>
<pre><code class="language-go">func coinChange(nums []int, target int) int {
	dp := make([]int, target+1)
	for i := 1; i &lt;= target; i++ {
		dp[i] = math.MaxInt32
	}
	for _, num := range nums {
		for i := 0; i &lt;= target-num; i++ {
			if dp[i] == math.MaxInt32 {
				continue
			}
			dp[i+num] = min(dp[i+num], dp[i]+1)
		}
	}
	if dp[target] == math.MaxInt32 {
		return -1
	}
	return dp[target]
}

func min(a, b int) int {
	if a &lt; b {
		return a
	}
	return b
}
</code></pre>
<h2 id="104"><a class="header" href="#104">104</a></h2>
<p>剑指 Offer II 104. 排列的数目</p>
<p>给定一个由 不同 正整数组成的数组 nums ，和一个目标整数 target 。请从 nums 中找出并返回总和为 target 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p>
<pre><code class="language-go">func combinationSum4(nums []int, target int) int {
    dp := make([]int, target+1)
    dp[0] = 1
    for i := 1; i &lt;= target; i++ {
        for _, num := range nums {
            if num &lt;= i {
                dp[i] += dp[i-num]
            }
        }
    }
    return dp[target]
}
</code></pre>
<h2 id="105"><a class="header" href="#105">105</a></h2>
<p><code>剑指 Offer II 105. 岛屿的最大面积</code></p>
<p>01二维矩阵，全1代表陆地，找到岛屿的最大面积</p>
<pre><code class="language-go">func maxAreaOfIsland(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	visited := make([][]bool, m)
	for i := 0; i &lt; m; i++ {
		visited[i] = make([]bool, n)
	}
	var getArea func(int, int) int
	getArea = func(i, j int) int {
		if i &lt; 0 || i == m || j &lt; 0 || j == n {
			return 0
		}
		if grid[i][j] == 0 || visited[i][j] {
			return 0
		}
		visited[i][j] = true
		return getArea(i-1, j) + getArea(i+1, j) + getArea(i, j-1) + getArea(i, j+1) + 1
	}
	ans := 0
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			area := getArea(i, j)
			if area &gt; ans {
				ans = area
			}
		}
	}
	return ans
}
</code></pre>
<h2 id="106"><a class="header" href="#106">106</a></h2>
<p><code>剑指 Offer II 106. 二分图</code></p>
<p>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p>
<p>如果图是二分图，返回 true ；否则，返回 false 。</p>
<pre><code class="language-go">// some comment
var (
    UNCOLOR, RED, GREEN = 0, 1, 2
)

func isBipartite(graph [][]int) bool {
    n := len(graph)

    state := make([]int, n)
    valid := true

    var dfs func(idx, color int)
    dfs = func(idx, color int) {
        necolor := RED
        if color == RED {
            necolor = GREEN
        }
        state[idx] = color

        for _, ne := range graph[idx] {
            if state[ne] == UNCOLOR {
                dfs(ne, necolor)
            } else {
                valid = necolor == state[ne]
            }

            if !valid {
                return
            }
        }
    }

    for i := 0; i &lt; n &amp;&amp; valid; i++ {
        if state[i] == UNCOLOR {
            dfs(i, RED)
        }
    }
    return valid
}
</code></pre>
<h2 id="107"><a class="header" href="#107">107</a></h2>
<p><code>剑指 Offer II 107. 矩阵中的距离</code></p>
<p>一个01矩阵，找到每个元素距离其最近0的距离长度，结果用二维矩阵表达</p>
<pre><code class="language-go">func updateMatrix(mat [][]int) [][]int {
	m := len(mat)
	n := len(mat[0])
	res := make([][]int, m)
	for i := range res {
		res[i] = make([]int, n)
	}
	dx := []int{1, 0, -1, 0}
	dy := []int{0, -1, 0, 1}
	var queue [][]int
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if mat[i][j] == 0 {
				queue = append(queue, []int{i, j})
			}
		}
	}
	for len(queue) &gt; 0 {
		x := queue[0][0]
		y := queue[0][1]
		queue = queue[1:]
		for k := 0; k &lt; 4; k++ {
			nx := x + dx[k]
			ny := y + dy[k]
			if nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; mat[nx][ny] == 1 {
				if res[nx][ny] == 0 || res[x][y]+1 &lt; res[nx][ny] {
					res[nx][ny] = res[x][y] + 1
					queue = append(queue, []int{nx, ny})
				}
			}
		}
	}
	return res
}
</code></pre>
<h2 id="108"><a class="header" href="#108">108</a></h2>
<p><code>剑指 Offer II 108. 单词演变</code></p>
<p>将单词从begin转换成end需要的最小步骤，并且每次的转换中间节点要在wordList中出现</p>
<pre><code class="language-go">func ladderLength(beginWord string, endWord string, wordList []string) int {
    wordId := map[string]int{}
    graph := [][]int{}
    addWord := func(word string) int {
        id, has := wordId[word]
        if !has {
            id = len(wordId)
            wordId[word] = id
            graph = append(graph, []int{})
        }
        return id
    }
    addEdge := func(word string) int {
        id1 := addWord(word)
        s := []byte(word)
        for i, b := range s {
            s[i] = '*'
            id2 := addWord(string(s))
            graph[id1] = append(graph[id1], id2)
            graph[id2] = append(graph[id2], id1)
            s[i] = b
        }
        return id1
    }

    for _, word := range wordList {
        addEdge(word)
    }
    beginId := addEdge(beginWord)
    endId, has := wordId[endWord]
    if !has {
        return 0
    }

    const inf int = math.MaxInt64
    dist := make([]int, len(wordId))
    for i := range dist {
        dist[i] = inf
    }
    dist[beginId] = 0
    queue := []int{beginId}
    for len(queue) &gt; 0 {
        v := queue[0]
        queue = queue[1:]
        if v == endId {
            return dist[endId]/2 + 1
        }
        for _, w := range graph[v] {
            if dist[w] == inf {
                dist[w] = dist[v] + 1
                queue = append(queue, w)
            }
        }
    }
    return 0
}
</code></pre>
<h2 id="109"><a class="header" href="#109">109</a></h2>
<p><code>剑指 Offer II 109. 开密码锁</code></p>
<p>四个环形波轮组成的锁，找到转到目标值target的最小转动次数，另外不能转动到deadends列表中的数据</p>
<pre><code class="language-go">func openLock(deadends []string, target string) int {
    if target == "0000" {
        return 0
    }

    deadendsSet := map[string]bool{}
    for _, item := range deadends {
        deadendsSet[item] = true
    }
    if deadendsSet[target] || deadendsSet["0000"] {
        return -1
    }

    visit := map[string]bool{}
    
    getnei := func(state string) []string {
        res := []string{}
        s := []byte(state)
        for i, ch := range s {
            s[i] = ch + 1
            if s[i] &gt; '9' {
                s[i] = '0'
            }
            res = append(res, string(s))

            s[i] = ch - 1
            if s[i] &lt; '0' {
                s[i] = '9'
            }
            res = append(res, string(s))

            s[i] = ch
        }
        return res
    }
    
    queue := []string{"0000"}
    step := 0
    for len(queue) &gt; 0 {
        newqueue := []string{}
        for _, state := range queue {
            for _, ne := range getnei(state) {
                if !visit[ne] &amp;&amp; !deadendsSet[ne] {
                    if ne == target {
                        return step + 1
                    }
                    visit[ne] = true
                    newqueue = append(newqueue, ne)
                }
            }
        }
        queue = newqueue
        step++
    }
    return -1
}
</code></pre>
<h2 id="110"><a class="header" href="#110">110</a></h2>
<p><code>剑指 Offer II 110. 所有路径</code></p>
<p>给定一个邻接矩阵结构，用于表示一个有向有环图，找到其中的所有的从0到n-1节点的路径</p>
<pre><code class="language-go">func allPathsSourceTarget(graph [][]int) (ans [][]int) {
    stk := []int{0}
    var dfs func(int)
    dfs = func(x int) {
        if x == len(graph)-1 {
            ans = append(ans, append([]int{}, stk...))
            return
        }
        for _, y := range graph[x] {
            stk = append(stk, y)
            dfs(y)
            stk = stk[:len(stk)-1]
        }
    }
    dfs(0)
    return
}
</code></pre>
<h2 id="111"><a class="header" href="#111">111</a></h2>
<p><code>剑指 Offer II 111. 计算除法</code></p>
<p>给定一些已知变量除法获取到的值，提供数据查询结果</p>
<pre><code class="language-go">func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {
    // 给方程组中的每个变量编号
    id := map[string]int{}
    for _, eq := range equations {
        a, b := eq[0], eq[1]
        if _, has := id[a]; !has {
            id[a] = len(id)
        }
        if _, has := id[b]; !has {
            id[b] = len(id)
        }
    }

    // 建图
    type edge struct {
        to     int
        weight float64
    }
    graph := make([][]edge, len(id))
    for i, eq := range equations {
        v, w := id[eq[0]], id[eq[1]]
        graph[v] = append(graph[v], edge{w, values[i]})
        graph[w] = append(graph[w], edge{v, 1 / values[i]})
    }

    bfs := func(start, end int) float64 {
        ratios := make([]float64, len(graph))
        ratios[start] = 1
        queue := []int{start}
        for len(queue) &gt; 0 {
            v := queue[0]
            queue = queue[1:]
            if v == end {
                return ratios[v]
            }
            for _, e := range graph[v] {
                if w := e.to; ratios[w] == 0 {
                    ratios[w] = ratios[v] * e.weight
                    queue = append(queue, w)
                }
            }
        }
        return -1
    }

    ans := make([]float64, len(queries))
    for i, q := range queries {
        start, hasS := id[q[0]]
        end, hasE := id[q[1]]
        if !hasS || !hasE {
            ans[i] = -1
        } else {
            ans[i] = bfs(start, end)
        }
    }
    return ans
}
</code></pre>
<h2 id="112"><a class="header" href="#112">112</a></h2>
<p><code>剑指 Offer II 112. 最长递增路径</code></p>
<p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<pre><code class="language-go">var (
    dirs = [][2]int{
        {-1, 0}, 
        {1, 0},
        {0, -1},
        {0, 1},
    }
    rows, columns int
)

func longestIncreasingPath(matrix [][]int) int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return 0
    }
    rows, columns = len(matrix), len(matrix[0])
    outdegrees := make([][]int, rows)
    for i := 0; i &lt; rows; i++ {
        outdegrees[i] = make([]int, columns)
    }
    for i := 0; i &lt; rows; i++ {
        for j := 0; j &lt; columns; j++ {
            for _, dir := range dirs {
                newRow, newColumn := i + dir[0], j + dir[1]
                if newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j] {
                    outdegrees[i][j]++
                }
            }
        }
    }

    queue := [][]int{}
    for i := 0; i &lt; rows; i++ {
        for j := 0; j &lt; columns; j++ {
            if outdegrees[i][j] == 0 {
                queue = append(queue, []int{i, j})
            }
        }
    }
    ans := 0
    for len(queue) != 0 {
        ans++
        size := len(queue)
        for i := 0; i &lt; size; i++ {
            cell := queue[0]
            queue = queue[1:]
            row, column := cell[0], cell[1]
            for _, dir := range dirs {
                newRow, newColumn := row + dir[0], column + dir[1]
                if newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column] {
                    outdegrees[newRow][newColumn]--
                    if outdegrees[newRow][newColumn] == 0 {
                        queue = append(queue, []int{newRow, newColumn})
                    }
                }
            }
        }
    }
    return ans
}
</code></pre>
<h2 id="113"><a class="header" href="#113">113</a></h2>
<p><code>剑指 Offer II 113. 课程顺序</code></p>
<p>总共n门课，并且有一些先后依赖顺序，返回要完成所有课程所需要的一个正确的课程顺序</p>
<pre><code class="language-go">func findOrder(numCourses int, prerequisites [][]int) []int {
    var (
        edges = make([][]int, numCourses)
        indeg = make([]int, numCourses)
        result []int
    )

    for _, info := range prerequisites {
        edges[info[1]] = append(edges[info[1]], info[0])
        indeg[info[0]]++
    }

    q := []int{}
    for i := 0; i &lt; numCourses; i++ {
        if indeg[i] == 0 {
            q = append(q, i)
        }
    }

    for len(q) &gt; 0 {
        u := q[0]
        q = q[1:]
        result = append(result, u)
        for _, v := range edges[u] {
            indeg[v]--
            if indeg[v] == 0 {
                q = append(q, v)
            }
        }
    }
    if len(result) != numCourses {
        return []int{}
    }
    return result
}
</code></pre>
<h2 id="114"><a class="header" href="#114">114</a></h2>
<p><code>剑指 Offer II 114. 外星文字典</code></p>
<p>通过已知的满足特定顺序的字符串数组，来推导出这个而特定的顺序</p>
<pre><code class="language-go">func alienOrder(words []string) string {
    g := map[byte][]byte{}
    inDeg := map[byte]int{}
    for _, c := range words[0] {
        inDeg[byte(c)] = 0
    }
next:
    for i := 1; i &lt; len(words); i++ {
        s, t := words[i-1], words[i]
        for _, c := range t {
            inDeg[byte(c)] += 0
        }
        for j := 0; j &lt; len(s) &amp;&amp; j &lt; len(t); j++ {
            if s[j] != t[j] {
                g[s[j]] = append(g[s[j]], t[j])
                inDeg[t[j]]++
                continue next
            }
        }
        if len(s) &gt; len(t) {
            return ""
        }
    }

    order := make([]byte, len(inDeg))
    q := order[:0]
    for u, d := range inDeg {
        if d == 0 {
            q = append(q, u)
        }
    }
    for len(q) &gt; 0 {
        u := q[0]
        q = q[1:]
        for _, v := range g[u] {
            if inDeg[v]--; inDeg[v] == 0 {
                q = append(q, v)
            }
        }
    }
    if cap(q) == 0 {
        return string(order)
    }
    return ""
}
</code></pre>
<h2 id="115"><a class="header" href="#115">115</a></h2>
<p><code>剑指 Offer II 115. 重建序列</code></p>
<p>https://leetcode.cn/problems/ur2n8P/?favorite=e8X3pBZi</p>
<pre><code class="language-go">func sequenceReconstruction(nums []int, sequences [][]int) bool {
    n := len(nums)
    g := make([][]int, n+1)
    inDeg := make([]int, n+1)
    for _, sequence := range sequences {
        for i := 1; i &lt; len(sequence); i++ {
            x, y := sequence[i-1], sequence[i]
            g[x] = append(g[x], y)
            inDeg[y]++
        }
    }

    q := []int{}
    for i := 1; i &lt;= n; i++ {
        if inDeg[i] == 0 {
            q = append(q, i)
        }
    }
    for len(q) &gt; 0 {
        if len(q) &gt; 1 {
            return false
        }
        x := q[0]
        q = q[1:]
        for _, y := range g[x] {
            if inDeg[y]--; inDeg[y] == 0 {
                q = append(q, y)
            }
        }
    }
    return true
}
</code></pre>
<h2 id="116"><a class="header" href="#116">116</a></h2>
<p><code>剑指 Offer II 116. 省份数量</code></p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<pre><code class="language-go">func findCircleNum(isConnected [][]int) (ans int) {
    n := len(isConnected)
    parent := make([]int, n)
    for i := range parent {
        parent[i] = i
    }
    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }
    union := func(from, to int) {
        parent[find(from)] = find(to)
    }

    for i, row := range isConnected {
        for j := i + 1; j &lt; n; j++ {
            if row[j] == 1 {
                union(i, j)
            }
        }
    }
    for i, p := range parent {
        if i == p {
            ans++
        }
    }
    return
}
</code></pre>
<h2 id="117"><a class="header" href="#117">117</a></h2>
<p><code>剑指 Offer II 117. 相似的字符串</code></p>
<p>寻找一个字符串数组中，有多少个分组，这些分组里面都是同一种字母异位词。</p>
<pre><code class="language-go">type unionFind struct {
    parent, size []int
    setCount     int // 当前连通分量数目
}

func newUnionFind(n int) *unionFind {
    parent := make([]int, n)
    size := make([]int, n)
    for i := range parent {
        parent[i] = i
        size[i] = 1
    }
    return &amp;unionFind{parent, size, n}
}

func (uf *unionFind) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *unionFind) union(x, y int) {
    fx, fy := uf.find(x), uf.find(y)
    if fx == fy {
        return
    }
    if uf.size[fx] &lt; uf.size[fy] {
        fx, fy = fy, fx
    }
    uf.size[fx] += uf.size[fy]
    uf.parent[fy] = fx
    uf.setCount--
}

func (uf *unionFind) inSameSet(x, y int) bool {
    return uf.find(x) == uf.find(y)
}

func isSimilar(s, t string) bool {
    diff := 0
    for i := range s {
        if s[i] != t[i] {
            diff++
            if diff &gt; 2 {
                return false
            }
        }
    }
    return true
}

func numSimilarGroups(strs []string) int {
    n := len(strs)
    uf := newUnionFind(n)
    for i, s := range strs {
        for j := i + 1; j &lt; n; j++ {
            if !uf.inSameSet(i, j) &amp;&amp; isSimilar(s, strs[j]) {
                uf.union(i, j)
            }
        }
    }
    return uf.setCount
}
</code></pre>
<h2 id="118"><a class="header" href="#118">118</a></h2>
<p><code>剑指 Offer II 118. 多余的边</code></p>
<p>给定一个无向图，找到找出一条可以删除的边，使其变为树</p>
<pre><code class="language-go">func findRedundantConnection(edges [][]int) []int {
    parent := make([]int, len(edges)+1)
    for i := range parent {
        parent[i] = i
    }
    var find func(int) int
    find = func(x int) int {
        if parent[x] != x {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }
    union := func(from, to int) bool {
        x, y := find(from), find(to)
        if x == y {
            return false
        }
        parent[x] = y
        return true
    }
    for _, e := range edges {
        if !union(e[0], e[1]) {
            return e
        }
    }
    return nil
}
</code></pre>
<h2 id="119"><a class="header" href="#119">119</a></h2>
<p><code>剑指 Offer II 119. 最长连续序列</code></p>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>要求时间复杂度为O(n)</p>
<pre><code class="language-go">func longestConsecutive(nums []int) int {
    numSet := map[int]bool{}
    for _, num := range nums {
        numSet[num] = true
    }
    longestStreak := 0
    for num := range numSet {
        if !numSet[num-1] {
            currentNum := num
            currentStreak := 1
            for numSet[currentNum+1] {
                currentNum++
                currentStreak++
            }
            if longestStreak &lt; currentStreak {
                longestStreak = currentStreak
            }
        }
    }
    return longestStreak
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<hr />
<h2>routeAlias: algo-shortlink
layout: two-cols</h2>
<Watermark />
<h1 id="短链系统设计"><a class="header" href="#短链系统设计">短链系统设计</a></h1>
<ul>
<li>功能性需求
<ul>
<li>指定一个url能够生成一个短链接</li>
<li>当用户点击短链接的时候会跳转到原始链接</li>
<li>用户可以定义短链接格式</li>
<li>用户可以设置链接的过期时间</li>
</ul>
</li>
<li>非功能性需求
<ul>
<li>系统必须保证高可用，否则如果服务挂了，所有的链接跳转将会失败</li>
<li>链接跳转延迟须尽可能低</li>
<li>短链接内容不能被预测到</li>
</ul>
</li>
</ul>
<p>::right::</p>
<v-click>
<ul>
<li>多个用户是否可以发布同一个长链接，可以，因为用户可以有自己不同的短链格式，支持多次短链生成</li>
<li>用户是否可以访问其他人的链接，可以，目前这个短链生成器是所有用户通用</li>
</ul>
</v-click>
<v-click>
<pre><code class="language-cpp">ShortLink sl

sl.newlink(string url, string format, time duration) // 获取短链接，生成的短链接不能重复 如果已经映射过直接返回
sl.visit(string url) // 可以使用短链也可以使用长链访问到原始链接
</code></pre>
</v-click>
<hr />
<h2 id="layout-two-cols"><a class="header" href="#layout-two-cols">layout: two-cols</a></h2>
<Watermark />
<h1 id="短链类"><a class="header" href="#短链类">短链类</a></h1>
<v-click>
<pre><code class="language-plantuml">@startuml

class LinkMap {
  -shortlinks: set[string] 用于判断一个短链是否已经存在
  -links :map[string]string 长链向短链的映射
  +register(string link, string format)
  +visit(string link)
}

@enduml
</code></pre>
</v-click>
<hr />
<h2 id="layout-two-cols-1"><a class="header" href="#layout-two-cols-1">layout: two-cols</a></h2>
<Watermark />
<h1 id="用户类"><a class="header" href="#用户类">用户类</a></h1>
<v-click>
<pre><code class="language-plantuml">@startuml

class User {
  -id :int 用户的id
  -links :int[] 用户的链接id
  +register(string link)
  +visit(string link)
}

@enduml
</code></pre>
</v-click>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<pre><code class="language-c++">#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;mutex&gt;
#include &lt;optional&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

template &lt;typename Key, typename Value&gt; class LRUCache {
private:
  size_t _capacity;
  std::list&lt;Key&gt; _lru;
  std::unordered_map&lt;Key, std::pair&lt;Value, typename std::list&lt;Key&gt;::iterator&gt;&gt;
      _cache;
  std::mutex _mutex;

public:
  LRUCache(size_t capacity) : _capacity(capacity) {}

  std::optional&lt;Value&gt; get(const Key &amp;key) {
    std::lock_guard&lt;std::mutex&gt; lock(_mutex);
    auto it = _cache.find(key);
    if (it == _cache.end()) {
      return std::nullopt; // 返回一个空的std::optional对象
    } else {
      _lru.splice(_lru.begin(), _lru, it-&gt;second.second);
      return it-&gt;second.first; // 返回找到的值
    }
  }

  void put(const Key &amp;key, const Value &amp;value) {
    std::lock_guard&lt;std::mutex&gt; lock(_mutex);
    auto it = _cache.find(key);
    if (it != _cache.end()) {
      it-&gt;second.first = value;
      _lru.splice(_lru.begin(), _lru, it-&gt;second.second);
    } else {
      if (_cache.size() == _capacity) {
        auto last = _lru.end();
        --last;
        _cache.erase(*last);
        _lru.pop_back();
      }
      _lru.push_front(key);
      _cache[key] = {value, _lru.begin()};
    }
  }
};

void exampleLRUCache() {
  LRUCache&lt;int, char&gt; cache(2);

  // 添加元素并检查是否正确返回
  cache.put(1, 'A');
  assert(cache.get(1).value_or(' ') == 'A'); // 应该返回'A'

  cache.put(2, 'B');
  assert(cache.get(2).value_or(' ') == 'B'); // 应该返回'B'

  // 添加第三个元素，应该淘汰键为1的元素
  cache.put(3, 'C');
  assert(!cache.get(1).has_value()); // 应该返回false，因为键为1的元素已被淘汰
  assert(cache.get(3).value_or(' ') == 'C'); // 应该返回'C'

  // 添加第四个元素，应该淘汰键为2的元素
  cache.put(4, 'D');
  assert(!cache.get(2).has_value()); // 应该返回false，因为键为2的元素已被淘汰
  assert(cache.get(4).value_or(' ') == 'D'); // 应该返回'D'

  std::cout &lt;&lt; "所有测试通过！" &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>volatile static const extern等关键字</li>
<li>宏定义和展开、内联函数区别</li>
<li>常用库函数实现</li>
<li>malloc,strcpy,strcmp的实现，常用库函数实现，哪些库函数属于高危函数</li>
<li>STL原理及实现</li>
<li>什么是虚函数</li>
<li>指针</li>
<li>C++ 内存分配机制</li>
<li>override和overload的区别</li>
<li>写string类的构造，析构，拷贝函数</li>
<li>C++中类成员的访问权限有那些？</li>
<li>C++多态的实现有那几种？他们有什么不同？</li>
<li>C++中右值引用有什么作用？</li>
<li>面向对象的三大特征是什么</li>
<li>静态分配内存和动态分配内存有什么区别？</li>
<li>C++结构体内存对齐</li>
<li>讲一讲C++中的原子操作有那些？</li>
<li>C++中动态链接库和静态连接库的区别是什么？</li>
<li>在C++中，对一个对象先malloc后delete这样使用可以吗？有什么风险？</li>
<li>在C++中，三个全局变量相互依赖，程序应该如何初始化呢？300个呢？</li>
<li>在C++中为什么需要深拷贝，浅拷贝会存在哪些问题？</li>
<li>如何构造一个类使得只能在堆上或者栈上分配内存？</li>
<li>什么是C++的内存模型？</li>
<li>指针和引用在内存中的表现形式有何不同？</li>
<li>内存映射文件是什么？如何用它来处理大文件？</li>
<li>C++中结构体内存布局的规则是什么？</li>
<li>在C++中，用堆和用栈谁更快一点？</li>
<li>C++中struct和class有什么区别？</li>
<li>如果A这个对象对应的类是一个空类，那么sizeof(A)的值是多少？</li>
<li>如果A这个指针指向一个数组，那么sizeof(A)的值是多少？</li>
<li>如果A是某一个类的指针，那么在它等于nullptr的情况下能直接调用里面的A对应类里面的public函数吗？</li>
<li>C++中，结构体可以直接赋值吗？</li>
<li>#define和const的区别有那些？</li>
<li>在C++的map中，[]与insert有那些区别？</li>
<li>在32位和64位系统中，指针分别为多大？</li>
<li>weak_ptr是如何解决shared_ptr循环引用的？</li>
<li>虚函数是否可以声明为static？</li>
<li>如何使用gdb来定位C++程序中的死锁？</li>
<li>C++中常用的类优化技术有那些？</li>
<li>C++的atomic代码底层是如何实现的？</li>
<li>原子变量的内存序是什么？</li>
<li>引用变量</li>
<li>C++中四种cast的转换？</li>
<li>内存池是什么？在C++中如何设计一个简单的内存池？</li>
<li>set，mutiset，map，mutimap之间都有什么区别？</li>
<li>在C++的算法库中，find()和binary_search()有什么区别？</li>
<li>lower_bound()和upper_bound()有什么区别？</li>
<li>函数参数的入栈顺序是什么，从左到右还是从右到左?</li>
<li>讲讲函数调用的过程</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<p>在C++中，左值（lvalue）和右值（rvalue）是与值的生命周期和表达式类型有关的概念。它们与C++11引入的右值引用和完美转发机制密切相关。以下是这些概念的详细解释和代码示例。</p>
<h2 id="1-左值lvalue"><a class="header" href="#1-左值lvalue">1. 左值（Lvalue）</a></h2>
<p>左值是指持久存在的对象或内存位置，它可以出现在赋值操作符的左边。换句话说，左值可以被引用，并且有明确的地址。</p>
<p><code>示例</code>：</p>
<pre><code class="language-cpp">int x = 10;  // x是一个左值，因为它可以被引用并且有内存地址
int&amp; ref = x;  // 可以通过引用来绑定左值
ref = 20;  // 通过引用修改x的值
</code></pre>
<p>在上面的代码中，x 是一个左值，因为它有明确的地址并且可以被赋值或引用。</p>
<h2 id="2-右值rvalue"><a class="header" href="#2-右值rvalue">2. 右值（Rvalue）</a></h2>
<p>右值是指一个临时值，通常是一个表达式的结果，并且没有明确的内存地址。右值不能出现在赋值操作符的左边，因为它们没有持久的存储空间。</p>
<pre><code class="language-cpp">int a = 5;
int b = 3;
int result = a + b;  // a + b是一个右值，因为它是一个表达式的结果，没有具体的地址s
</code></pre>
<h2 id="3-右值引用rvalue-reference"><a class="header" href="#3-右值引用rvalue-reference">3. 右值引用（Rvalue Reference）</a></h2>
<p>C++11引入了右值引用，用来绑定右值。右值引用使用&amp;&amp;语法，可以捕获和操作临时对象，从而避免不必要的复制。右值引用的主要应用之一是移动语义，即通过转移临时对象的资源来提高性能。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;  // for std::move

void process(int&amp;&amp; x) {
    std::cout &lt;&lt; "Processing rvalue: " &lt;&lt; x &lt;&lt; std::endl;
    x = 30; // 对于左值move过来的右值引用是可以修改的, 当然这个不是右值引用(本身只是为了处理右值复制的问题)的专利，普通引用int也可以修改
}

int main() {
    int a = 10;
    process(std::move(a));  // std::move将a转换为右值
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    process(20);  // 20是右值，可以直接传递给右值引用
    // output
    // Processing rvalue: 10
    // 30
    // Processing rvalue: 20
}
</code></pre>
<h2 id="4-完美转发perfect-forwarding"><a class="header" href="#4-完美转发perfect-forwarding">4. 完美转发（Perfect Forwarding）</a></h2>
<p>完美转发是指在模板中将参数精确地传递给另一个函数，保持其原始的左值或右值特性。它通常通过结合模板参数推导和右值引用来实现。</p>
<p>完美转发的主要工具是std::forward。std::forward确保在函数调用中参数的值类别（左值或右值）得以保留。</p>
<p><code>示例</code>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;  // for std::forward

// 处理左值和右值的函数重载
void process(int&amp; x) {
    std::cout &lt;&lt; "Processing lvalue: " &lt;&lt; x &lt;&lt; std::endl;
}

void process(int&amp;&amp; x) {
    std::cout &lt;&lt; "Processing rvalue: " &lt;&lt; x &lt;&lt; std::endl;
}

// 泛型函数，接收任意类型的参数并转发给另一个函数
template&lt;typename T&gt;
void wrapper(T&amp;&amp; arg) {
    process(std::forward&lt;T&gt;(arg));  // 完美转发
}

int main() {
    int a = 5;
    wrapper(a);        // 传递左值
    wrapper(10);       // 传递右值
}
</code></pre>
<p><code>说明</code>：</p>
<ul>
<li>在wrapper函数中，<code>T&amp;&amp;</code> 是一个万能引用（universal reference），可以绑定左值或右值。</li>
<li><code>std::forward&lt;T&gt;(arg)</code> 保证了当传入的是左值时，arg会作为左值传递；当传入的是右值时，arg会作为右值传递，这就是完美转发。</li>
</ul>
<p><code>总结</code></p>
<ul>
<li>左值（lvalue） 是有具体地址的对象，可以被持久引用。</li>
<li>右值（rvalue） 是临时对象或表达式的结果，通常没有地址。</li>
<li>右值引用（rvalue reference） 是通过&amp;&amp;来引用右值的机制，主要用于移动语义，避免拷贝。</li>
<li>完美转发 用于保持参数的值类别（左值或右值）不变，通过std::forward实现。</li>
</ul>
<p>这些特性有助于优化代码性能，尤其是在处理临时对象和资源转移时。</p>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="概览"><a class="header" href="#概览">概览</a></h2>
<ul>
<li>什么是虚函数,有什么作用?</li>
<li>纯虚函数，为什么需要纯虚函数？</li>
<li>为什么需要虚析构函数,什么时候不需要?</li>
<li>内联函数、构造函数、静态成员函数可以是虚函数吗?</li>
<li>构造函数中可以调用虚函数吗?</li>
<li>为什么需要虚继承?虚继承实现原理解析</li>
<li>虚函数是针对类还是针对对象的？</li>
<li>同一个类的两个对象的虚函数表是如何维护的？</li>
</ul>
<hr />
<p>在C++中，虚函数（virtual function）是面向对象编程的一个核心概念，它允许通过基类指针或引用来调用派生类的重写方法，实现动态多态（dynamic polymorphism）。虚函数的背后涉及虚函数表（vtable）、指针机制以及一些运行时的操作。</p>
<h1 id="虚函数的基本概念与作用"><a class="header" href="#虚函数的基本概念与作用">虚函数的基本概念与作用</a></h1>
<p>虚函数是基类中声明为virtual的成员函数，它允许派生类重写该函数，并支持通过基类的指针或引用调用派生类的重写函数。</p>
<p><code>作用</code>：</p>
<ul>
<li>虚函数实现了动态多态，允许基类指针或引用在运行时调用派生类的重写函数，而不是基类的版本。</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Base {
public:
    virtual void show() {
        std::cout &lt;&lt; "Base class show() called" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {  // 重写虚函数
        std::cout &lt;&lt; "Derived class show() called" &lt;&lt; std::endl;
    }
};

int main() {
    Base* ptr = new Derived();  // 基类指针指向派生类对象
    ptr-&gt;show();  // 调用派生类的show()，而不是Base的show()
    // 输出 Derived class show() called
    delete ptr;
}
</code></pre>
<p>在这个例子中，Base类的show()是虚函数，当通过基类指针ptr调用时，实际调用的是派生类Derived的show()，这就是虚函数的作用——动态分派。</p>
<h2 id="纯虚函数与抽象类"><a class="header" href="#纯虚函数与抽象类">纯虚函数与抽象类</a></h2>
<p>纯虚函数（pure virtual function）是指在基类中只声明而不定义的虚函数，形式是<code>virtual void func() = 0;</code>。一个包含纯虚函数的类称为抽象类，抽象类不能实例化，只能被继承。</p>
<pre><code class="language-cpp">class Base {
public:
    virtual void show() = 0;  // 纯虚函数
};

class Derived : public Base {
public:
    void show() override {
        std::cout &lt;&lt; "Derived class show() called" &lt;&lt; std::endl;
    }
};

int main() {
    // Base obj;  // 错误！抽象类不能实例化
    Base* ptr = new Derived();
    ptr-&gt;show();  // 调用派生类的show()
    delete ptr;
}
</code></pre>
<h2 id="虚析构函数的必要性"><a class="header" href="#虚析构函数的必要性">虚析构函数的必要性</a></h2>
<p>如果一个类中存在虚函数，通常也需要将析构函数声明为虚函数。这是为了确保通过基类指针或引用删除对象时，能够正确调用派生类的析构函数，防止资源泄漏。</p>
<p>为什么需要虚析构函数：
如果基类的析构函数不是虚函数，那么通过基类指针删除派生类对象时，只会调用基类的析构函数，导致派生类的资源没有正确释放。</p>
<pre><code class="language-cpp">class Base {
public:
    virtual ~Base() {
        std::cout &lt;&lt; "Base destructor called" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout &lt;&lt; "Derived destructor called" &lt;&lt; std::endl;
    }
};

int main() {
    Base* ptr = new Derived();  // 基类指针指向派生类对象
    delete ptr;  // 调用虚析构函数，确保派生类析构函数被调用
   // output
   // Derived destructor called
   // Base destructor called
}
</code></pre>
<p>如果没有虚析构函数，Derived类的析构函数将不会被调用，导致资源泄漏。</p>
<p><code>什么时候不需要虚析构函数</code>：</p>
<p>当类不打算用于继承，或者不打算通过基类指针删除派生类对象时，虚析构函数可以省略。普通的类（非多态类）不需要虚析构函数。</p>
<h2 id="构造函数中可以调用虚函数吗"><a class="header" href="#构造函数中可以调用虚函数吗">构造函数中可以调用虚函数吗？</a></h2>
<p>不可以。在构造函数中调用虚函数时，虚函数的动态分派机制不会工作。因为在构造基类对象时，派生类部分还未构造完成，此时即便调用的是虚函数，调用的也是基类的版本。</p>
<pre><code class="language-cpp">class Base {
public:
    Base() { show(); }  // 构造函数中调用虚函数
    virtual void show() {
        std::cout &lt;&lt; "Base show() called" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout &lt;&lt; "Derived show() called" &lt;&lt; std::endl;
    }
};

int main() {
    Derived obj;  // 调用Derived的构造函数
    // output
    // Base show() called
}
</code></pre>
<p>即使派生类Derived重写了show()，构造函数中调用的仍然是基类的show()。</p>
<h2 id="哪些函数不能是虚函数"><a class="header" href="#哪些函数不能是虚函数">哪些函数不能是虚函数</a></h2>
<ul>
<li>内联函数（inline function）：理论上内联函数可以是虚函数，但实际中，虚函数需要动态分派，因此通常不会被内联。编译器无法在运行时决定调用哪个版本的函数，所以虚函数的内联机会较少。</li>
<li>构造函数：构造函数不能是虚函数，因为在对象构造时无法进行动态分派。构造函数的职责是创建对象，虚函数的作用是在对象创建完成后进行动态分派。</li>
<li>静态成员函数：静态成员函数不能是虚函数，因为它们与具体的对象无关。虚函数依赖于对象的动态类型，而静态函数属于类本身，不依赖于对象实例。</li>
</ul>
<h2 id="为什么需要虚继承"><a class="header" href="#为什么需要虚继承">为什么需要虚继承？</a></h2>
<p>虚继承用于解决多重继承中的菱形继承问题，即当多个派生类从同一个基类继承时，可能导致基类被多次继承，从而引发二义性或资源冗余。虚继承通过让所有派生类共享基类的唯一实例来解决这个问题。</p>
<pre><code class="language-cpp">class Base {
public:
    int value;
};

class Derived1 : virtual public Base {};
class Derived2 : virtual public Base {};

class Final : public Derived1, public Derived2 {};

int main() {
    Final obj;
    obj.value = 10;  // 没有二义性，只有一个Base子对象
}
</code></pre>
<p>在上面的例子中，如果不使用虚继承，Final类将有两个Base的副本，导致value的二义性。</p>
<p><code>虚继承的实现原理</code></p>
<p>虚继承通过引入**虚基类指针（virtual base pointer, vptr）**来跟踪共享的基类实例。派生类在内存布局中包含一个指向虚基类实例的指针，所有派生类都指向同一个基类实例，避免重复继承。</p>
<h2 id="虚函数表vtable的维护"><a class="header" href="#虚函数表vtable的维护">虚函数表（vtable）的维护</a></h2>
<p>每个具有虚函数的类在编译时会生成一个虚函数表（vtable），表中存储了该类的虚函数指针。每个对象会有一个虚函数表指针（vptr），指向该类的虚函数表。</p>
<p><code>同一个类的两个对象的虚函数表</code>：</p>
<p>对于同一个类的多个对象，它们共享相同的虚函数表（vtable），但每个对象都有自己的虚函数表指针（vptr），指向相同的vtable。</p>
<p><code>虚函数是针对类还是对象的</code>：</p>
<p>虚函数是针对类的。虚函数表是类级别的，所有对象共享同一个虚函数表，但调用虚函数时，是根据对象的动态类型来选择合适的函数。这就是动态多态的核心机制。</p>
<pre><code class="language-cpp">class Base {
public:
    virtual void show() { std::cout &lt;&lt; "Base show() called" &lt;&lt; std::endl; }
};

class Derived : public Base {
public:
    void show() override { std::cout &lt;&lt; "Derived show() called" &lt;&lt; std::endl; }
};

int main() {
    Base b;
    Derived d;
    Base* ptr1 = &amp;b;
    Base* ptr2 = &amp;d;
    ptr1-&gt;show();  // 调用Base的show()
    ptr2-&gt;show();  // 调用Derived的show()
    // output
    // Base show() called
    // Derived show() called
}
</code></pre>
<p>在这个例子中，Base和Derived类都有各自的虚函数表，ptr1指向基类对象，调用基类的show()，ptr2指向派生类对象，调用派生类的show()。</p>
<p><code>如果拿到虚函数表的储存地址，是否可以改写虚函数表的内容？</code></p>
<p>虽然可以修改虚函数表的内容，但这种操作是非常危险的，如果将虚函数表的某个条目改为无效地址，调用虚函数时会导致崩溃。改写虚函数表后，程序行为变得不可预测，可能导致奇怪的结果、错误调用、数据损坏等问题。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

class Base {
public:
    virtual void func1() {
        std::cout &lt;&lt; "Base func1" &lt;&lt; std::endl;
    }
    virtual void func2() {
        std::cout &lt;&lt; "Base func2" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void func1() override {
        std::cout &lt;&lt; "Derived func1" &lt;&lt; std::endl;
    }
    void func2() override {
        std::cout &lt;&lt; "Derived func2" &lt;&lt; std::endl;
    }
};

// 一个假的函数，伪装成虚函数
void hacked_func() {
    std::cout &lt;&lt; "Hacked function called!" &lt;&lt; std::endl;
}

int main() {
    Derived obj;

    // 获取虚函数表指针
    // vptr通常是对象的前8个字节（或者32位系统的前4个字节）
    long long* vptr = *(long long**)(&amp;obj);

    // 打印虚函数表内容
    std::cout &lt;&lt; "Before hacking:" &lt;&lt; std::endl;
    typedef void(*FuncPtr)();
    FuncPtr original_func1 = (FuncPtr)vptr[0];
    original_func1();  // 调用虚函数表的第一个函数，应该调用Derived::func1

    // 修改虚函数表的第一个函数指针
    vptr[0] = (long long)(&amp;hacked_func);

    // 调用虚函数表第一个函数，应该调用伪造的hacked_func
    std::cout &lt;&lt; "After hacking:" &lt;&lt; std::endl;
    original_func1 = (FuncPtr)vptr[0];
    original_func1();  // 调用hacked_func

    // output
    // Before hacking:
    // Derived func1
    // After hacking:
    // Hacked function called!
    return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="概览-1"><a class="header" href="#概览-1">概览</a></h2>
<ul>
<li>指针</li>
<li>迭代器与普通指针有什么区别</li>
<li>C++的智能指针及其原理</li>
<li>悬挂指针和野指针有什么区别？</li>
<li>指针常量和常量指针的区别</li>
<li>指针和引用有什么区别呢？</li>
<li>如何避免悬挂指针？</li>
</ul>
<hr />
<h2 id="指针的基础概念"><a class="header" href="#指针的基础概念">指针的基础概念</a></h2>
<p>指针是存储内存地址的变量。它指向一个特定类型的对象或变量，并且通过解引用操作（*）可以访问该地址上的值。</p>
<p><code>示例</code>：</p>
<pre><code class="language-cpp">int a = 10;
int* p = &amp;a;  // p是指向a的指针
std::cout &lt;&lt; *p;  // 解引用p，输出a的值：10
</code></pre>
<p>指针的用途很多，例如动态内存分配、函数参数传递、数组操作等。</p>
<p><code>指针常量与常量指针</code></p>
<ul>
<li>指针常量（constant pointer）：指针本身是常量，指向的地址不能改变，但指向的内容可以改变。</li>
<li>常量指针（pointer to constant）：指针指向的对象是常量，不能通过指针修改该对象的值，但可以改变指针指向的地址。</li>
</ul>
<pre><code class="language-cpp">int a = 5;
int b = 10;

// 指针常量：指向的地址不能改变
int* const ptr1 = &amp;a;
*ptr1 = 20;  // 可以修改a的值
// ptr1 = &amp;b;  // 错误，ptr1不能改变指向

// 常量指针：指向的值不能改变
const int* ptr2 = &amp;a;
ptr2 = &amp;b;  // 可以改变ptr2的指向
// *ptr2 = 30;  // 错误，不能修改指向对象的值
</code></pre>
<p><code>指针和引用的区别</code></p>
<ul>
<li>指针可以为空，也可以重新指向其他对象；指针的大小是固定的。</li>
<li>引用必须在定义时初始化，且不能重新绑定到其他对象。引用实际上是对象的别名，不占用额外内存。</li>
</ul>
<blockquote>
<p>主要区别：指针更灵活，允许指向不同的对象；引用更简单，用于定义后不会变化的别名。</p>
</blockquote>
<pre><code class="language-cpp">int a = 5;
int* ptr = &amp;a;  // 指针
int&amp; ref = a;   // 引用

ref = 10;  // 通过引用修改a的值
ptr = nullptr;  // 指针可以为空
// ref = &amp;b;  // 引用不能重新绑定
</code></pre>
<p><code>nullptr 的含义是什么？</code></p>
<p>nullptr 是C++11引入的，用来统一表示“空指针”概念。它替代了之前使用的 NULL 宏定义。</p>
<ul>
<li>类型安全： 与旧的 NULL 不同，nullptr 有明确的类型，是 std::nullptr_t 类型的常量值，它可以自动转换为任何指针类型，但它不是整数（这避免了 NULL 被解释为整数的歧义）。nullptr 只能用于指针类型，不能用于非指针类型的场景。</li>
<li>表示空指针： nullptr 代表一个明确的“空指针”，即它不指向任何有效的内存地址。</li>
</ul>
<h2 id="指针的基本注意事项"><a class="header" href="#指针的基本注意事项">指针的基本注意事项</a></h2>
<ul>
<li>解引用空指针：在解引用指针之前，确保它指向有效的内存，否则会导致运行时错误（如段错误）。</li>
<li>初始化指针：指针必须初始化（如nullptr或指向有效内存），否则可能成为悬挂指针或野指针。</li>
<li>动态内存管理：在使用new分配的内存时，必须记得用delete释放，防止内存泄漏。</li>
</ul>
<p><code>悬挂指针与野指针</code></p>
<ul>
<li>悬挂指针（dangling pointer）：指向已经被释放或销毁的内存地址。</li>
<li>野指针（wild pointer）：未初始化的指针，指向随机的内存位置。</li>
</ul>
<pre><code class="language-cpp">int* ptr = new int(5);
delete ptr;  // 释放内存
// 此时ptr是悬挂指针，因为它指向的内存已经释放
ptr = nullptr;  // 通过将指针置为nullptr避免悬挂指针
</code></pre>
<p><code>如何避免悬挂指针？</code></p>
<ul>
<li>使用智能指针：智能指针自动管理内存，避免悬挂指针。</li>
<li>设置指针为nullptr：在释放内存后，将指针置为nullptr，避免误用。</li>
<li>尽量减少使用原始指针：优先使用智能指针和引用，减少直接使用原始指针的场景。</li>
<li>注意作用域：确保指针的作用域与其指向的对象保持一致，避免指向已经销毁的对象。</li>
</ul>
<pre><code class="language-cpp">int* ptr = new int(10);
delete ptr;
ptr = nullptr;  // 避免悬挂指针
</code></pre>
<h2 id="智能指针及其原理"><a class="header" href="#智能指针及其原理">智能指针及其原理</a></h2>
<p>C++11引入了智能指针，它们自动管理内存，避免手动delete。主要有三种类型的智能指针：</p>
<ul>
<li>std::unique_ptr：独占所有权，指针不能共享，生命周期结束时自动释放内存。</li>
<li>std::shared_ptr：允许多个智能指针共享同一个对象，使用引用计数来管理内存。引用计数为0时，自动释放内存。</li>
<li>std::weak_ptr：与shared_ptr配合使用，不影响引用计数，防止循环引用。</li>
</ul>
<pre><code class="language-cpp">#include &lt;memory&gt;

std::unique_ptr&lt;int&gt; ptr1 = std::make_unique&lt;int&gt;(10);
std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl;  // 输出10

std::shared_ptr&lt;int&gt; ptr2 = std::make_shared&lt;int&gt;(20);
std::shared_ptr&lt;int&gt; ptr3 = ptr2;  // 引用计数增加
std::cout &lt;&lt; *ptr3 &lt;&lt; std::endl;  // 输出20
</code></pre>
<p>原理：智能指针通过构造函数和析构函数控制指针的生命周期。当智能指针超出作用域或引用计数为0时，自动释放所管理的内存，避免内存泄漏。</p>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<p>C++中的并发编程是指多个线程或任务同时执行，旨在提高程序的效率、响应性或处理多个任务。虽然并发编程可以带来性能提升，但它也引入了许多复杂的问题，如<code>线程竞争（race conditions）</code>、<code>死锁（deadlocks）</code>、<code>内存可见性问题（memory visibility issues）</code>等。</p>
<h2 id="并发编程的基本原理"><a class="header" href="#并发编程的基本原理">并发编程的基本原理</a></h2>
<p>在并发编程中，多个线程同时运行并访问共享资源。C++标准库提供了<code>&lt;thread&gt;</code>库，允许我们轻松创建和管理线程。线程可以共享相同的内存地址空间，这意味着它们可以直接访问同一个变量。这种共享内存的特性可以提高性能，但同时也可能导致竞争条件等并发问题。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void task(int id) {
    std::cout &lt;&lt; "Task " &lt;&lt; id &lt;&lt; " is running." &lt;&lt; std::endl;
}

int main() {
    std::thread t1(task, 1); // 启动线程t1
    std::thread t2(task, 2); // 启动线程t2

    t1.join();  // 等待线程t1执行完毕
    t2.join();  // 等待线程t2执行完毕

    return 0;
}
</code></pre>
<p>这段代码中，我们创建了两个线程t1和t2，它们并行执行相同的task函数。每个线程都会输出自己的任务ID。为了确保程序正常退出，我们使用了join()，使得主线程等待所有子线程结束。</p>
<h2 id="并发问题"><a class="header" href="#并发问题">并发问题</a></h2>
<p>并发问题通常发生在多个线程访问共享资源时，如果没有合适的同步机制，可能会产生不可预测的行为。常见的并发问题包括：</p>
<ul>
<li>(1) 竞争条件（Race Condition）</li>
</ul>
<p>当多个线程并发地读写相同的共享资源且没有适当的同步时，可能导致竞争条件。结果是，程序的输出依赖于线程的执行顺序，而这个顺序是无法预测的。</p>
<p>错误示例：竞争条件</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

int counter = 0;

void increment(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        ++counter;  // 不安全的递增操作
    }
}

int main() {
    std::thread t1(increment, 100000);
    std::thread t2(increment, 100000);

    t1.join();
    t2.join();

    std::cout &lt;&lt; "Final counter value: " &lt;&lt; counter &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>在这个例子中，counter是两个线程共享的变量。多个线程同时对counter进行递增操作时会发生竞争条件，最终输出的结果会不一致，因为递增操作不是原子的（非原子操作可能会被多个线程同时访问并中断）。</p>
<p><code>(2) 死锁（Deadlock）</code></p>
<p>当多个线程相互等待对方持有的资源释放时，就会发生死锁。死锁会导致程序无法继续运行。</p>
<p>错误示例：死锁</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

std::mutex mutex1, mutex2;

void task1() {
    std::lock_guard&lt;std::mutex&gt; lock1(mutex1);
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    std::lock_guard&lt;std::mutex&gt; lock2(mutex2);  // 死锁
}

void task2() {
    std::lock_guard&lt;std::mutex&gt; lock2(mutex2);
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    std::lock_guard&lt;std::mutex&gt; lock1(mutex1);  // 死锁
}

int main() {
    std::thread t1(task1);
    std::thread t2(task2);

    t1.join();
    t2.join();
    return 0;
}
</code></pre>
<p>在这个例子中，task1持有mutex1并等待mutex2，而task2持有mutex2并等待mutex1，从而造成了死锁。</p>
<h2 id="并发安全线程安全的常见方法"><a class="header" href="#并发安全线程安全的常见方法">并发安全（线程安全）的常见方法</a></h2>
<p>为了避免并发问题，我们需要引入适当的同步机制。C++标准库提供了多种工具来帮助我们实现线程安全。</p>
<ul>
<li>(1) 互斥量（Mutex）</li>
</ul>
<p>互斥量是用来保证只有一个线程可以访问共享资源的工具。使用互斥量可以确保某个线程在访问共享资源时不会被其他线程打断。</p>
<p>正确示例：使用互斥量避免竞争条件</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

int counter = 0;
std::mutex mtx;

void increment(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);  // 锁定互斥量
        ++counter;  // 安全的递增操作
    }
}

int main() {
    std::thread t1(increment, 100000);
    std::thread t2(increment, 100000);

    t1.join();
    t2.join();

    std::cout &lt;&lt; "Final counter value: " &lt;&lt; counter &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>使用std::mutex保证同一时间只有一个线程可以访问counter，从而避免竞争条件。</p>
<ul>
<li>(2) 原子操作（Atomic Operations）</li>
</ul>
<p>C++提供了<code>&lt;atomic&gt;</code>库，允许对某些基本类型执行原子操作。原子操作不需要显式的锁机制，通常更高效。</p>
<p>正确示例：使用原子变量</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

std::atomic&lt;int&gt; counter(0);

void increment(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        ++counter;  // 原子递增操作
    }
}

int main() {
    std::thread t1(increment, 100000);
    std::thread t2(increment, 100000);

    t1.join();
    t2.join();

    std::cout &lt;&lt; "Final counter value: " &lt;&lt; counter.load() &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>在这个例子中，counter是一个原子变量，递增操作是线程安全的，无需使用互斥量。</p>
<h2 id="性能问题分析"><a class="header" href="#性能问题分析">性能问题分析</a></h2>
<p>在并发编程中，性能与安全性之间存在权衡。引入锁和同步机制可以保证线程安全，但会带来额外的性能开销。以下是一些需要考虑的性能问题：</p>
<ul>
<li>锁的开销：频繁加锁和解锁会降低并发性能，特别是在竞争激烈的场合（多个线程频繁尝试获取锁）。</li>
<li>原子操作的开销：尽管原子操作比锁轻量，但它们也会引入一些性能开销，尤其是在复杂的数据结构上。</li>
<li>上下文切换：线程之间的切换会带来额外的系统开销，如果线程数量过多，上下文切换可能导致性能下降。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<p>在C++中，理解对象的内存布局是编写高效代码、进行性能优化和调试的重要基础。不同类型的对象在内存中的布局各不相同，从基本类型、指针和引用到复杂的类和对象，C++编译器为它们在内存中分配空间。我们将循序渐进地讨论这些对象的内存布局，并提供相应的代码示例以帮助理解。</p>
<h2 id="1-基本类型primitive-types"><a class="header" href="#1-基本类型primitive-types">1. 基本类型（Primitive Types）</a></h2>
<p>C++中的基本类型包括int、char、float、double等。这些类型的内存布局是固定的，并且它们通常被直接存储在栈（stack）上。</p>
<p>基本类型的内存布局</p>
<ul>
<li>int 通常占用4个字节（具体取决于平台和编译器）。</li>
<li>char 通常占用1个字节。</li>
<li>float 通常占用4个字节。</li>
<li>double 通常占用8个字节。</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int a = 10;
    char b = 'c';
    float c = 3.14;
    double d = 2.718;

    std::cout &lt;&lt; "Size of int: " &lt;&lt; sizeof(a) &lt;&lt; " bytes\n";
    std::cout &lt;&lt; "Size of char: " &lt;&lt; sizeof(b) &lt;&lt; " bytes\n";
    std::cout &lt;&lt; "Size of float: " &lt;&lt; sizeof(c) &lt;&lt; " bytes\n";
    std::cout &lt;&lt; "Size of double: " &lt;&lt; sizeof(d) &lt;&lt; " bytes\n";
    return 0;
}
</code></pre>
<p>输出结果可能为：</p>
<pre><code class="language-cpp">Size of int: 4 bytes
Size of char: 1 byte
Size of float: 4 bytes
Size of double: 8 bytes
</code></pre>
<h2 id="2-指针pointer"><a class="header" href="#2-指针pointer">2. 指针（Pointer）</a></h2>
<p>指针是用于存储内存地址的变量。指针的大小通常取决于平台的架构：</p>
<ul>
<li>在32位系统上，指针通常占用4个字节（32位地址空间）。</li>
<li>在64位系统上，指针通常占用8个字节（64位地址空间）。</li>
</ul>
<p>指针的大小与它指向的对象类型无关，关键在于操作系统的地址空间大小。</p>
<p>示例代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int* p1 = nullptr;  // 指向int类型的指针
    double* p2 = nullptr;  // 指向double类型的指针

    std::cout &lt;&lt; "Size of int pointer: " &lt;&lt; sizeof(p1) &lt;&lt; " bytes\n";
    std::cout &lt;&lt; "Size of double pointer: " &lt;&lt; sizeof(p2) &lt;&lt; " bytes\n";
    return 0;
}
</code></pre>
<p>输出结果可能为：</p>
<pre><code class="language-cpp">Size of int pointer: 8 bytes
Size of double pointer: 8 bytes
</code></pre>
<h2 id="3-引用reference"><a class="header" href="#3-引用reference">3. 引用（Reference）</a></h2>
<p>引用在C++中是某个变量的别名。虽然它在语法上类似于指针，但它本质上是不同的。引用的内存布局取决于编译器的实现。在大多数情况下，引用会被编译器实现为指针，因此它的大小通常与指针相同。</p>
<p>示例代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int a = 5;
    int&amp; ref = a;

    std::cout &lt;&lt; "Address of a: " &lt;&lt; &amp;a &lt;&lt; std::endl;
    std::cout &lt;&lt; "Address of ref: " &lt;&lt; &amp;ref &lt;&lt; std::endl;  // 与a的地址相同
    return 0;
}
</code></pre>
<p>尽管引用与变量共享同一个地址，但编译器可能在内部将引用实现为指针。</p>
<h2 id="4-函数function"><a class="header" href="#4-函数function">4. 函数（Function）</a></h2>
<p>在C++中，函数的内存布局相对较为抽象，因为函数通常存储在代码段（code segment）中。指向函数的指针在内存中存储着函数的入口地址。</p>
<p>函数指针示例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

void myFunction() {
    std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;
}

int main() {
    void (*funcPtr)() = &amp;myFunction;  // 函数指针

    std::cout &lt;&lt; "Address of function: " &lt;&lt; reinterpret_cast&lt;void*&gt;(funcPtr) &lt;&lt; std::endl;
    funcPtr();  // 通过函数指针调用函数
    return 0;
}
</code></pre>
<p>输出结果会显示函数的内存地址，并执行该函数。</p>
<h2 id="5-类class"><a class="header" href="#5-类class">5. 类（Class）</a></h2>
<p>类在内存中的布局取决于其成员变量和方法。编译器会为类中的数据成员分配内存，而成员函数不会影响对象的大小（因为成员函数是共享的，不占用对象实例的内存空间）。</p>
<p>类的内存布局示例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class MyClass {
public:
    int a;  // 占用4字节
    char b;  // 占用1字节
    double c;  // 占用8字节
};

int main() {
    MyClass obj;
    std::cout &lt;&lt; "Size of MyClass: " &lt;&lt; sizeof(obj) &lt;&lt; " bytes\n";
    return 0;
}
</code></pre>
<p>在这个例子中，MyClass对象的大小不是简单的相加，因为编译器可能会进行内存对齐。即使char只占1字节，编译器可能会填充额外的字节以保证对齐。</p>
<p>对齐与填充：</p>
<ul>
<li>内存对齐（Memory Alignment）：为了提高内存访问效率，编译器通常会把数据对齐到特定的边界。例如，32位系统中可能要求4字节对齐，64位系统可能要求8字节对齐。</li>
<li>填充字节（Padding Bytes）：为了满足对齐要求，编译器会在成员变量之间插入一些空白字节。</li>
</ul>
<p>示例输出可能是：<code>Size of MyClass: 16 bytes</code></p>
<p>这说明编译器在char后面插入了3个字节的填充，以保证double按8字节对齐。</p>
<p><code>如果 A 这个对象对应的类是一个空类，那么 sizeof(A) 的值是多少？</code></p>
<p>在C++中，即使类是空的，sizeof 一个对象仍然不会是 0。一个空类在 C++ 中的 sizeof 值通常是 1 字节。这是为了确保每个实例都有一个唯一的地址。不同的编译器实现可能会有不同的结果，但通常会返回 1 字节。</p>
<h2 id="6-对象的内存布局"><a class="header" href="#6-对象的内存布局">6. 对象的内存布局</a></h2>
<p>对象是类的实例，它在内存中存储着类的所有非静态数据成员。静态成员属于类，而不是某个具体的对象，因此不包含在对象的内存布局中。</p>
<p>多重继承和虚表
当类使用继承时，特别是使用多重继承或虚函数时，对象的内存布局会更加复杂。例如，如果一个类有虚函数，编译器会为每个对象分配一个指向虚表（vtable）的指针，称为虚指针（vptr）。虚表存储了虚函数的地址。</p>
<p>示例代码（虚函数和虚表）：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class Base {
public:
    virtual void func() {
        std::cout &lt;&lt; "Base function\n";
    }
};

class Derived : public Base {
public:
    void func() override {
        std::cout &lt;&lt; "Derived function\n";
    }
};

int main() {
    Base b;
    Derived d;

    std::cout &lt;&lt; "Size of Base: " &lt;&lt; sizeof(b) &lt;&lt; " bytes\n";
    std::cout &lt;&lt; "Size of Derived: " &lt;&lt; sizeof(d) &lt;&lt; " bytes\n";
    return 0;
}
</code></pre>
<p>由于类Base和Derived都有虚函数，编译器会为每个对象分配虚指针。通常，虚指针的大小等于一个普通指针的大小（例如，64位系统上为8字节）。</p>
<p><code>如果 A 是某一个类的指针，那么在它等于 nullptr 的情况下能直接调用它对应类的 public 函数吗？</code></p>
<p>这取决于该 public 函数是否访问了该对象的成员。如果该函数不访问对象成员，并且它是一个非虚函数，那么可以在 A == nullptr 的情况下调用它而不会出错。但如果函数访问了对象的成员（无论是直接还是间接），或者是虚函数（因为虚函数需要通过虚表指针调用），那么调用时会引发未定义行为。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;utility&gt;  // for std::forward

class A{
public:
void process(int x) {
    std::cout &lt;&lt; "Processing lvalue: " &lt;&lt; x &lt;&lt; std::endl;
}
};

int main() {
    A* a = nullptr;
    a-&gt;process(2);
    // output
    // Processing lvalue: 2
}
</code></pre>
<p><code>非成员访问的成员函数</code>： 当一个成员函数不访问该对象的成员变量时，它在本质上相当于一个普通的函数，只是函数签名上有一个隐式的 this 指针。这种函数不会依赖于指针所指向的对象内容。</p>
<ul>
<li>当你调用一个函数，比如 ptr-&gt;foo()，编译器会将它转化为 foo(ptr)，其中 ptr 是隐式传递的 this 指针。</li>
<li>如果 foo 函数内部并不访问成员变量，而是执行独立逻辑，传入的 nullptr 就不会导致问题，因为它实际上没有解引用 this 指针中的任何内容。</li>
</ul>
<p>对于其他的，比如需要解引用this指针，比如调用虚函数涉及虚表指针的解引用，使用nullptr就会出问题了。</p>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<p>C++中的STL（标准模板库）是编程中非常重要的一个部分，STL不仅提供了丰富的数据结构和算法，同时也是泛型编程的重要应用。</p>
<p>选择合适的STL容器通常取决于你对数据结构的需求，如访问速度、插入/删除操作的频率、内存使用等。以下是一些常见的选择标准：</p>
<ul>
<li>std::vector：当你需要频繁随机访问元素，且只在末尾插入/删除时。</li>
<li>std::deque：当你需要在两端进行插入和删除时。</li>
<li>std::list：当你需要频繁的中间插入/删除时。</li>
<li>std::set：当你需要自动排序和唯一性时。</li>
<li>std::map：当你需要键值对关联时。</li>
</ul>
<p>STL容器本身不是线程安全的。多个线程同时读写同一个容器，或者同时修改容器状态（比如插入或删除元素）时，可能会导致数据竞争。因此，需要通过锁（如std::mutex）来确保线程安全。</p>
<p>STL广泛采用了泛型编程，所有STL容器和算法都使用模板，使它们能够处理不同的数据类型。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;typename T&gt;
void print_vector(const std::vector&lt;T&gt;&amp; vec) {
    for (const auto&amp; item : vec) {
        std::cout &lt;&lt; item &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    std::vector&lt;int&gt; int_vec = {1, 2, 3};
    std::vector&lt;double&gt; double_vec = {1.1, 2.2, 3.3};

    print_vector(int_vec);
    print_vector(double_vec);

    return 0;
}
</code></pre>
<p><code>RAII</code></p>
<p>STL中，像std::vector、std::unique_ptr等容器和智能指针都遵循RAII原则。RAII（Resource Acquisition Is Initialization）是一种资源管理的原则。在C++中，RAII意味着对象的生命周期与资源的管理直接相关。当对象被创建时，资源被分配；当对象被销毁时，资源自动释放。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    {
        std::vector&lt;int&gt; vec = {1, 2, 3};
        // vec创建时分配内存，RAII管理其生命周期
    }
    // 离开作用域时，vec自动销毁，内存被释放

    return 0;
}
</code></pre>
<p><code>allocator</code></p>
<p>Allocator是STL中用于管理内存分配的机制。STL中的所有容器都使用allocator来控制如何分配、释放和管理内存。这使得STL能够更灵活地适应不同的内存管理需求。</p>
<p>默认的allocator是std::allocator，但用户可以自定义allocator来优化内存分配策略（比如用于嵌入式系统中的内存池）。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;

int main() {
    std::vector&lt;int, std::allocator&lt;int&gt;&gt; vec = {1, 2, 3};

    return 0;
}
</code></pre>
<h2 id="1-stl中的优先级队列是如何实现的"><a class="header" href="#1-stl中的优先级队列是如何实现的">1. STL中的优先级队列是如何实现的？</a></h2>
<p>STL中的priority_queue是基于堆（heap）实现的。优先级队列默认是一个最大堆，即每次取出的元素都是当前队列中的最大值（或最小值，取决于定义）。堆的性质确保插入和删除的时间复杂度为O(log n)。</p>
<p>代码示例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

int main() {
    std::priority_queue&lt;int&gt; pq;

    pq.push(10);
    pq.push(5);
    pq.push(20);

    while (!pq.empty()) {
        std::cout &lt;&lt; pq.top() &lt;&lt; " ";  // 每次输出最大值
        pq.pop();
    }

    return 0;
}
</code></pre>
<p>这里，std::priority_queue是通过std::vector存储数据，并使用堆来维持顺序。内部使用std::make_heap()、std::push_heap()和std::pop_heap()等算法。</p>
<h2 id="2-stl中常见的算法库"><a class="header" href="#2-stl中常见的算法库">2. STL中常见的算法库</a></h2>
<p>STL中的算法库是其核心部分之一，包含了很多常见的算法，比如排序、查找、遍历等。以下是一些常见的算法：</p>
<ul>
<li>std::sort：快速排序，时间复杂度为O(n log n)。</li>
<li>std::find：在范围内查找某个元素，线性时间复杂度。</li>
<li>std::binary_search：二分查找，时间复杂度为O(log n)，需要排序数组。</li>
<li>std::accumulate：用于计算区间内所有元素的累加值。</li>
</ul>
<p>代码示例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
    std::vector&lt;int&gt; vec = {1, 3, 5, 2, 4};

    // 排序
    std::sort(vec.begin(), vec.end());

    // 查找
    if (std::binary_search(vec.begin(), vec.end(), 3)) {
        std::cout &lt;&lt; "找到元素3" &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<h2 id="map的底层实现"><a class="header" href="#map的底层实现">map的底层实现</a></h2>
<p>std::map的底层实现是红黑树，这是一种自平衡二叉搜索树。红黑树保证插入、删除、查找的时间复杂度为O(log n)。红黑树通过颜色标记和旋转操作保持平衡。</p>
<h2 id="set的底层实现"><a class="header" href="#set的底层实现">set的底层实现</a></h2>
<p>std::set的底层实现与std::map类似，也是基于红黑树。区别在于std::set只存储键，而不存储值。</p>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<p>学习 Linux 系统能够显著提升工作效率、开发能力和系统管理能力。掌握 Linux 系统的各项技能可以帮助程序员更好地管理和维护开发环境，提升自动化水平、问题解决能力和工作效率。特别是在服务器运维、网络编程、大规模集成开发环境等场景下，Linux 的学习能够显著提升程序员的全方位能力，增加对系统底层的理解，为更复杂的技术栈打下坚实的基础。</p>
<h2 id="1-基础命令与文件系统管理"><a class="header" href="#1-基础命令与文件系统管理">1. 基础命令与文件系统管理</a></h2>
<p>重点掌握内容：基本的命令如 ls、cd、cp、mv、rm、chmod、chown、ln、find、grep 等，文件和目录权限（如 rwx 权限的含义），文件路径结构，文件压缩与解压（如 tar、gzip）。
作用：这些命令是管理 Linux 文件系统的基础，掌握它们可以帮助程序员高效地在系统中导航、管理文件、调整权限等。
提升：熟悉这些基础命令可以提高操作系统的工作效率，让程序员更快、更便捷地完成日常开发和运维任务。</p>
<h2 id="2-文本编辑器"><a class="header" href="#2-文本编辑器">2. 文本编辑器</a></h2>
<p>重点掌握内容：使用文本编辑器如 vim、nano、emacs 等进行文件编辑。掌握 vim 的基本操作（如插入模式、命令模式、保存、退出、查找与替换）。</p>
<p>作用：文本编辑器是处理配置文件、代码和脚本的主要工具。快速掌握 vim 等编辑器的使用能够提高工作效率。</p>
<p>提升：熟悉高效的文本编辑工具能够减少切换图形界面编辑器的需求，增强命令行下的开发与配置能力。</p>
<h2 id="3-shell-脚本编程"><a class="header" href="#3-shell-脚本编程">3. Shell 脚本编程</a></h2>
<p>重点掌握内容：了解 bash 等 Shell 语言的基础，如变量、条件判断（if）、循环（for、while）、函数、自定义命令，以及管道（|）与重定向（&gt;、&gt;&gt;、&lt;）的使用。</p>
<p>作用：Shell 脚本能够自动化重复性任务，如批量文件处理、自动化部署和系统监控等，是系统运维的必备技能。</p>
<p>提升：通过编写 Shell 脚本，可以大幅减少人工操作，提高工作流程的自动化水平，增强系统运维和批处理能力。</p>
<h2 id="4-系统权限与用户管理"><a class="header" href="#4-系统权限与用户管理">4. 系统权限与用户管理</a></h2>
<p>重点掌握内容：用户和组的管理（如 useradd、usermod、passwd、groupadd 等），文件权限与归属（chmod、chown），sudo 权限配置与管理。</p>
<p>作用：通过掌握这些内容，程序员可以为不同用户分配权限，保护系统安全，防止未经授权的访问。</p>
<p>提升：掌握用户和权限管理能让程序员确保系统的安全性，特别是在服务器或团队协作开发环境中。</p>
<h2 id="5-进程管理与系统监控"><a class="header" href="#5-进程管理与系统监控">5. 进程管理与系统监控</a></h2>
<p>重点掌握内容：使用 ps、top、htop、kill、pkill 等命令管理进程，使用 systemctl 或 service 管理服务，查看系统日志（如 dmesg、journalctl）。</p>
<p>作用：进程管理是系统资源分配和调度的重要环节，了解如何查看和管理进程可以帮助程序员定位性能瓶颈或崩溃原因。</p>
<p>提升：通过掌握进程和系统监控，程序员可以更好地排查系统问题，优化应用性能，了解系统资源的分配与使用。</p>
<h2 id="6-网络配置与管理"><a class="header" href="#6-网络配置与管理">6. 网络配置与管理</a></h2>
<p>重点掌握内容：了解基本的网络命令如 ifconfig、ping、netstat、ss、traceroute、iptables，学习网络接口配置与调试。</p>
<p>作用：掌握网络相关命令能够帮助程序员配置和管理服务器的网络连接，进行网络调试和诊断，设置防火墙规则。</p>
<p>提升：网络配置能力让程序员能够自己搭建开发或测试环境的网络部分，有助于理解和优化分布式系统或网络应用的性能。</p>
<h2 id="7-软件包管理"><a class="header" href="#7-软件包管理">7. 软件包管理</a></h2>
<p>重点掌握内容：使用软件包管理工具如 apt（Ubuntu/Debian 系列）、yum 或 dnf（CentOS/Fedora 系列），安装、更新、卸载软件包，管理软件依赖。
作用：软件包管理是 Linux 系统中安装、升级和管理软件的主要方式，掌握这些工具可以高效管理开发环境。
提升：掌握软件包管理工具，可以让程序员更加自由地定制开发环境，管理系统所需的库和依赖。</p>
<h2 id="8-日志管理"><a class="header" href="#8-日志管理">8. 日志管理</a></h2>
<p>重点掌握内容：熟悉系统日志文件的路径和格式（如 /var/log 目录中的日志文件），使用 tail、less、grep 等工具查看日志内容，配置日志轮替（如 logrotate）。</p>
<p>作用：日志是系统运行状态的记录，掌握日志查看与分析工具可以帮助程序员定位问题，监控系统运行。</p>
<p>提升：通过熟练掌握日志管理，程序员能够更迅速地排查系统和应用程序的错误，提升问题解决能力。</p>
<h2 id="9-虚拟化与容器化"><a class="header" href="#9-虚拟化与容器化">9. 虚拟化与容器化</a></h2>
<p>重点掌握内容：学习如何使用虚拟机（如 VirtualBox）或容器（如 Docker），掌握虚拟环境的配置和管理。</p>
<p>作用：容器化技术如 Docker 已经成为现代应用开发和部署的核心，掌握这些技术能够提高开发和部署的灵活性与一致性。</p>
<p>提升：通过掌握虚拟化与容器化技术，程序员可以创建独立的开发环境，模拟生产环境，提升开发效率并减少部署出错的概率。</p>
<h2 id="10--版本控制系统与远程管理"><a class="header" href="#10--版本控制系统与远程管理">10.  版本控制系统与远程管理</a></h2>
<p>重点掌握内容：学习 git 版本控制系统的使用，掌握基本的 git 操作（如 clone、commit、push、pull、branch），并掌握远程服务器的管理工具如 ssh、scp。</p>
<p>作用：版本控制和远程管理是多人协作开发和维护服务器的重要技能。通过远程连接和管理服务器，程序员可以进行部署、维护和调试。</p>
<p>提升：这些技能对于程序员的协作开发、代码管理和远程运维具有重要意义，能够让程序员更好地参与团队合作和管理生产服务器。</p>
<h2 id="11-安全与防护"><a class="header" href="#11-安全与防护">11. 安全与防护</a></h2>
<p>重点掌握内容：掌握基础的安全措施，如使用 SSH 密钥登录、设置防火墙、加固文件权限、配置 Fail2Ban 等防护措施。</p>
<p>作用：提高系统的安全性，防止网络攻击或数据泄露。</p>
<p>提升：安全意识和防护技能是保护系统与数据安全的核心，能够帮助程序员打造更安全可靠的开发和生产环境。</p>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<p>在 Linux 系统中，CPU、内存、磁盘和网络等资源的管理和监控是非常重要的，这些资源直接关系到系统性能的高低。要有效分析这些指标，需要理解它们的具体含义，并熟练使用相关命令行工具。以下是各个资源的详细说明、监控工具和优化方案：</p>
<h2 id="1-cpu"><a class="header" href="#1-cpu">1. CPU</a></h2>
<p><code>主要指标</code>：</p>
<ul>
<li>CPU 使用率：衡量 CPU 的工作负载，通常显示为百分比。可以分为用户态（user space）、系统态（kernel space）和空闲态。</li>
<li>负载均值（Load Average）：代表一段时间内 CPU 的平均负载，通常会有 1 分钟、5 分钟和 15 分钟的负载均值。</li>
<li>进程状态：查看占用 CPU 资源最多的进程。</li>
</ul>
<p><code>命令行工具</code>：</p>
<ul>
<li>top / htop：实时显示系统运行状态，包括 CPU、内存、负载等。
<ul>
<li>优化分析：可以通过 top 观察 CPU 使用率较高的进程，并针对性地进行优化。htop 是 top 的增强版，提供了更好的界面和交互性。</li>
</ul>
</li>
<li>mpstat：多核 CPU 的统计数据，显示每个 CPU 核心的使用情况。
<ul>
<li>优化分析：通过查看单核和多核 CPU 的使用情况，可以判断是否需要优化程序的多线程性能。</li>
</ul>
</li>
</ul>
<p><code>优化方案</code>：</p>
<ul>
<li>进程管理：如果某些进程占用 CPU 资源过多，可以通过 nice、renice 调整进程优先级，或者使用 kill 终止不必要的进程。</li>
<li>负载均衡：如果某些任务不需要立刻执行，可以通过 cron 或 at 将任务安排在系统负载较低时运行。</li>
<li>多线程优化：对于多核 CPU，可以优化程序的并行执行能力，使得任务分布在不同的 CPU 核心上，充分利用多核 CPU 性能</li>
</ul>
<h2 id="2-内存"><a class="header" href="#2-内存">2. 内存</a></h2>
<p><code>主要指标</code>：</p>
<ul>
<li>总内存：系统中实际的物理内存大小。</li>
<li>已用内存：已经被进程占用的内存。</li>
<li>空闲内存：尚未使用的物理内存。</li>
<li>交换分区（Swap）：当物理内存不足时，系统会将不常用的数据移到硬盘上的交换分区。过多使用交换空间会降低系统性能。</li>
<li>缓存与缓冲：缓存用于存储文件系统数据，缓冲用于存储即将写入磁盘的数据。</li>
</ul>
<p><code>命令行工具</code>：</p>
<ul>
<li>free：查看内存使用情况，包括物理内存和交换内存。
<ul>
<li>优化分析：通过 free 可以了解物理内存和交换空间的使用情况，如果交换分区的使用较多，可能需要增加物理内存或优化内存管理。</li>
</ul>
</li>
<li>vmstat：显示系统的虚拟内存使用、IO 负载、CPU 等。
<ul>
<li>优化分析：通过 vmstat 可以了解内存分配和交换区的使用情况，帮助判断是否需要调整应用程序的内存使用。</li>
</ul>
</li>
<li>top / htop：显示占用内存最多的进程。
<ul>
<li>优化分析：通过 top 查看内存消耗大户，识别内存泄漏或不必要的内存占用。</li>
</ul>
</li>
</ul>
<p><code>优化方案</code>：</p>
<ul>
<li>释放缓存：通过执行 echo 3 &gt; /proc/sys/vm/drop_caches 清理缓存，但要谨慎使用，避免影响系统性能。</li>
<li>调整交换分区大小：如果物理内存不足且频繁使用交换分区，可以增加交换分区的大小或增加物理内存。</li>
<li>优化内存使用：程序优化时应注意防止内存泄漏，确保释放不再使用的内存。</li>
</ul>
<h2 id="3-磁盘"><a class="header" href="#3-磁盘">3. 磁盘</a></h2>
<p><code>主要指标</code>：</p>
<ul>
<li>磁盘空间使用率：每个挂载点的磁盘使用百分比，常用于判断磁盘是否即将耗尽。</li>
<li>磁盘 IO 速率：磁盘的读写速率，过高的 IO 可能表示磁盘负载过重。</li>
<li>I/O 等待（I/O wait）：CPU 等待磁盘 I/O 完成的时间，通常表示磁盘访问瓶颈。</li>
</ul>
<p><code>命令行工具</code>：</p>
<ul>
<li>df：查看文件系统的磁盘使用情况。
<ul>
<li>优化分析：通过 df 查看各个挂载点的磁盘使用率，判断磁盘空间是否充足。</li>
</ul>
</li>
<li>du：查看指定目录或文件的磁盘使用情况。
<ul>
<li>优化分析：通过 du 可以找到占用磁盘空间较大的文件或目录，方便进行清理。</li>
</ul>
</li>
<li>iostat：显示磁盘的 I/O 性能，包括读取、写入速率。
<ul>
<li>优化分析：通过 iostat 可以判断磁盘是否存在 I/O 性能瓶颈，发现频繁访问磁盘的进程。</li>
</ul>
</li>
<li>iotop：类似于 top 的磁盘 I/O 性能监控工具，显示各进程的磁盘 I/O 使用情况。
<ul>
<li>优化分析：通过 iotop 可以发现磁盘 I/O 负载重的进程，并进行优化。</li>
</ul>
</li>
</ul>
<p><code>优化方案</code>：</p>
<ul>
<li>清理不必要的文件：通过 du 找到大文件，定期清理日志文件、缓存等，保持磁盘空间充足。</li>
<li>磁盘分区管理：合理规划磁盘分区，避免单一分区空间过小导致磁盘使用过载。</li>
<li>磁盘 I/O 优化：对于 I/O 密集型任务，可以使用 SSD 替代 HDD，或将频繁读写的数据放在更快的磁盘上。</li>
<li>文件系统优化：选择合适的文件系统（如 ext4、xfs）和挂载选项来提高磁盘 I/O 性能。</li>
</ul>
<h2 id="4-网络"><a class="header" href="#4-网络">4. 网络</a></h2>
<p><code>主要指标</code>：</p>
<ul>
<li>带宽使用率：网络接口的上传和下载速率。</li>
<li>丢包率：丢失的数据包比例，表示网络通信的稳定性。</li>
<li>延迟（Latency）：网络通信的响应时间，反映网络的时延。</li>
<li>网络连接数：系统的活动连接数，反映了系统的网络负载情况。</li>
</ul>
<p><code>命令行工具</code>：</p>
<ul>
<li>ifconfig / ip addr：显示网络接口的配置和状态。
<ul>
<li>优化分析：通过 ifconfig 查看网络接口的运行状态和基本信息，如 IP 地址、带宽、错误包等。</li>
</ul>
</li>
<li>ping：用于测试网络连通性和延迟。
<ul>
<li>优化分析：通过 ping 测试本地和远程服务器的网络延迟，判断是否存在网络瓶颈。</li>
</ul>
</li>
<li>netstat / ss：查看系统的网络连接、监听的端口和网络接口的流量统计。
<ul>
<li>优化分析：通过 netstat 可以查看系统上正在使用的端口和连接数，发现异常网络连接或网络瓶颈。</li>
</ul>
</li>
<li>iftop：实时监控网络接口的流量。
<ul>
<li>优化分析：通过 iftop 可以发现哪些进程或服务占用了过多的带宽，从而针对性地进行优化。</li>
</ul>
</li>
</ul>
<p><code>优化方案</code>：</p>
<ul>
<li>带宽控制：通过 tc（Traffic Control）命令限制某些进程的带宽占用，避免单一进程耗尽网络资源。</li>
<li>网络配置优化：优化网络接口的配置，如调整 MTU（最大传输单元）大小、开启 TCP Fast Open 提高网络传输性能。</li>
<li>分布式缓存：通过在本地部署缓存服务器（如 Varnish）减少对远程服务器的频繁网络请求，降低带宽使用。</li>
<li>网络负载均衡：对于高并发网络应用，可以引入负载均衡器（如 HAProxy），将网络请求分发到多台服务器，降低单台服务器的负载。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="ifconfig"><a class="header" href="#ifconfig">ifconfig</a></h2>
<ul>
<li>用于配置和显示网络接口的详细信息，包括 IP 地址、网络掩码、广播地址、MAC 地址等。</li>
<li>可以启用或禁用网络接口。</li>
</ul>
<pre><code class="language-bash"># 查看所有网络接口的配置
ifconfig

# 配置某个接口的 IP 地址
ifconfig eth0 192.168.1.100 netmask 255.255.255.0

# 启用网络接口
ifconfig eth0 up

# 禁用网络接口
ifconfig eth0 down
</code></pre>
<h2 id="ip"><a class="header" href="#ip">ip</a></h2>
<ul>
<li>ip 命令是功能更强大的网络配置工具，能够配置 IP 地址、路由、网络接口以及网络命名空间等。</li>
<li>通过该命令可以显示和修改所有网络配置相关的信息。</li>
</ul>
<pre><code class="language-bash"># 查看所有网络接口的信息
ip addr show

# 为网络接口添加 IP 地址
ip addr add 192.168.1.100/24 dev eth0

# 删除网络接口的 IP 地址
ip addr del 192.168.1.100/24 dev eth0

# 启用网络接口
ip link set eth0 up

# 禁用网络接口
ip link set eth0 down

# 查看路由表
ip route show

# 添加默认网关
ip route add default via 192.168.1.1
</code></pre>
<h2 id="ping"><a class="header" href="#ping">ping</a></h2>
<ul>
<li>ping 用于测试主机之间的连通性，通过向目标主机发送 ICMP 请求并接收响应来测试网络连接状况。</li>
<li>可以用来测量网络的延迟（RTT，Round Trip Time）。</li>
</ul>
<pre><code class="language-bash"># 测试与远程主机的连通性
ping www.google.com

# 指定发送数据包的数量（4 个）
ping -c 4 www.google.com
</code></pre>
<h2 id="netstatss"><a class="header" href="#netstatss">netstat/ss</a></h2>
<ul>
<li>netstat 命令用于显示网络连接、路由表、接口统计信息以及多播成员。</li>
<li>ss 是 netstat 的替代工具，用于显示更详细的套接字（socket）信息，速度比 netstat 快。</li>
</ul>
<pre><code class="language-bash"># 显示所有当前的网络连接
netstat -an

# 查看系统中所有监听的端口
netstat -tuln

# 使用 ss 显示监听的端口
ss -tuln

# 显示详细的 TCP 连接信息
ss -ta
</code></pre>
<h2 id="traceroute"><a class="header" href="#traceroute">traceroute</a></h2>
<ul>
<li>traceroute 用于显示从本地主机到目标主机之间经过的路由节点（跳数），帮助定位网络故障点或延迟来源。</li>
<li>它通过向目的地发送 TTL 递增的 ICMP 数据包，并逐步显示路径中的各个路由节点。</li>
</ul>
<pre><code class="language-bash"># 显示到目标主机的路由路径
traceroute www.google.com

# 使用 ICMP 进行路由追踪
traceroute -I www.google.com
</code></pre>
<h2 id="nslookupdig"><a class="header" href="#nslookupdig">nslookup/dig</a></h2>
<ul>
<li>nslookup 和 dig 是 DNS 查询工具，用于查询域名解析信息。</li>
<li>nslookup 是较老的工具，dig 提供更多详细信息并且功能更强大。</li>
</ul>
<pre><code class="language-bash"># 使用 nslookup 查询域名的 IP 地址
nslookup www.google.com

# 使用 dig 查询域名的详细 DNS 解析记录
dig www.google.com

# 反向查询 IP 对应的域名
dig -x 8.8.8.8
</code></pre>
<h2 id="route"><a class="header" href="#route">route</a></h2>
<ul>
<li>route 命令用于查看和配置系统的路由表。</li>
<li>主要用于管理网络流量的路由路径，例如添加、删除或显示网关的路由规则。</li>
</ul>
<pre><code class="language-bash"># 显示当前的路由表
route -n

# 添加默认网关
route add default gw 192.168.1.1

# 删除路由
route del -net 192.168.1.0/24 gw 192.168.1.1
</code></pre>
<h2 id="ethtool"><a class="header" href="#ethtool">ethtool</a></h2>
<ul>
<li>ethtool 命令用于查询和修改网卡（Ethernet device）的配置和状态，支持硬件属性的查看与设置。</li>
<li>查看和修改网络接口的硬件参数，如速率、双工模式、自协商模式等。</li>
<li>排查网络接口性能问题，或调整网卡参数以优化网络性能。</li>
</ul>
<pre><code class="language-bash"># 显示网卡 eth0 的硬件信息
ethtool eth0

# 禁用网卡的自协商功能
ethtool -s eth0 autoneg off

# 设置网卡速率为 100Mbps，全双工模式
ethtool -s eth0 speed 100 duplex full
</code></pre>
<h2 id="iptablesnftables"><a class="header" href="#iptablesnftables">iptables/nftables</a></h2>
<ul>
<li>iptables 是 Linux 系统的防火墙工具，用于配置网络包过滤规则，管理入站和出站的网络流量。</li>
<li>nftables 是 iptables 的替代工具，功能更强大且更灵活，推荐在新系统中使用。</li>
<li>配置防火墙规则，限制或允许某些端口的访问。</li>
<li>设置 NAT（网络地址转换）规则，实现路由功能。</li>
</ul>
<pre><code class="language-bash"># 列出当前的 iptables 规则
iptables -L

# 允许特定端口的流量（如 22 端口的 SSH 连接）
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# 删除规则
iptables -D INPUT -p tcp --dport 22 -j ACCEPT

# 清空所有规则
iptables -F
</code></pre>
<h2 id="nmcli"><a class="header" href="#nmcli">nmcli</a></h2>
<p>nmcli 是 NetworkManager 的命令行接口，用于配置网络连接、管理网络设备和显示网络状态。</p>
<pre><code class="language-bash"># 查看当前的网络连接
nmcli con show

# 启用网络连接
nmcli con up id "Wired connection 1"

# 禁用网络连接
nmcli con down id "Wired connection 1"

# 创建新的有线连接
nmcli con add type ethernet ifname eth0
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="./theme/style.js"></script>
        <script src="clarity.js"></script>
        <script src="./theme/highlight.js"></script>

        <script>
            window.addEventListener('load', function () {
                window.setTimeout(window.print, 100);
            });
        </script>

    </div>
</body>

</html>