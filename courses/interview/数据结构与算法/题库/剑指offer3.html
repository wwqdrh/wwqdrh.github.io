<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>剑指offer3</title>


    <!-- Custom HTML head -->
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="../../favicon.svg">
    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../.././theme/style.css">
    <link rel="stylesheet" href="../.././theme/mdbook-admonish.css">

</head>

<body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">面试指南</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/index.html"><strong aria-hidden="true">1.</strong> 数据结构与算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/index.html"><strong aria-hidden="true">1.1.</strong> 题库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer1.html"><strong aria-hidden="true">1.1.1.</strong> 剑指offer1</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer2.html"><strong aria-hidden="true">1.1.2.</strong> 剑指offer2</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer3.html" class="active"><strong aria-hidden="true">1.1.3.</strong> 剑指offer3</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer4.html"><strong aria-hidden="true">1.1.4.</strong> 剑指offer4</a></li></ol></li><li class="chapter-item expanded "><a href="../../数据结构与算法/短链系统设计.html"><strong aria-hidden="true">1.2.</strong> 短链系统设计</a></li></ol></li><li class="chapter-item expanded "><a href="../../c++/index.html"><strong aria-hidden="true">2.</strong> c++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../c++/c++标准.html"><strong aria-hidden="true">2.1.</strong> c++标准</a></li><li class="chapter-item expanded "><a href="../../c++/引用变量.html"><strong aria-hidden="true">2.2.</strong> 引用变量</a></li><li class="chapter-item expanded "><a href="../../c++/什么是虚函数.html"><strong aria-hidden="true">2.3.</strong> 什么是虚函数</a></li><li class="chapter-item expanded "><a href="../../c++/什么是指针.html"><strong aria-hidden="true">2.4.</strong> 什么是指针</a></li><li class="chapter-item expanded "><a href="../../c++/如何保证并发安全.html"><strong aria-hidden="true">2.5.</strong> 如何保证并发安全</a></li><li class="chapter-item expanded "><a href="../../c++/常见对象的内存结构.html"><strong aria-hidden="true">2.6.</strong> 常见对象的内存结构</a></li><li class="chapter-item expanded "><a href="../../c++/stl容器库.html"><strong aria-hidden="true">2.7.</strong> stl容器库</a></li><li class="chapter-item expanded "><a href="../../c++/内存模型.html"><strong aria-hidden="true">2.8.</strong> 内存模型</a></li></ol></li><li class="chapter-item expanded "><a href="../../linux操作系统/index.html"><strong aria-hidden="true">3.</strong> linux操作系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../linux操作系统/进程结构与调度.html"><strong aria-hidden="true">3.1.</strong> 进程结构与调度</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/内存管理.html"><strong aria-hidden="true">3.2.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/资源管理.html"><strong aria-hidden="true">3.3.</strong> 资源管理</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/网络配置.html"><strong aria-hidden="true">3.4.</strong> 网络配置</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function (e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="https://space.bilibili.com/538676331" target="_blank" title="B站" aria-label="B站">
                            B站
                        </a>
                        <a href="/" target="_blank" title="home" aria-label="Git repository">
                            <i id="git-home" class="fa fa-home"></i>
                        </a>
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wwqdrh/interview-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="61"><a class="header" href="#61">61、</a></h2>
<p><code>剑指 Offer II 061. 和最小的 k 个数对</code></p>
<p>给定两个升序数组，找到前n小的数对</p>
<div><select onchange="changeCodeExample('code-example-tab-0', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-0-cpp">cpp</option><option value="code-example-tab-0-go">go</option></select></div>
<div id="code-example-tab-0-cpp" class="code-example-tab-0"><pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2,
                                   int k) {
  vector&lt;vector&lt;int&gt;&gt; ans;
  auto comp = [](const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) {
    return a.first + a.second &gt; b.first + b.second;
  };
<em></em>
  priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(comp)&gt;
      minHeap(comp);
<em></em>
  int m = nums1.size(), n = nums2.size();
  for (int i = 0; i &lt; k &amp;&amp; i &lt; m; ++i) {
    minHeap.emplace(i, 0);
  }
<em></em>
  while (!minHeap.empty() &amp;&amp; ans.size() &lt; k) {
    auto [i, j] = minHeap.top();
    minHeap.pop();
    ans.push_back({nums1[i], nums2[j]});
    if (j + 1 &lt; n) {
      minHeap.emplace(i, j + 1);
    }
  }
<em></em>
  return ans;
}
</code></pre></div><div id="code-example-tab-0-go" class="code-example-tab-0"><pre><code class="language-go">package main
<em></em>
import &quot;container/heap&quot;
<em></em>
func kSmallestPairs(nums1, nums2 []int, k int) (ans [][]int) {
	h := hp{nums1: nums1, nums2: nums2}
	m, n := len(nums1), len(nums2)
	for i := 0; i &lt; k &amp;&amp; i &lt; m; i++ {
		heap.Push(&amp;h, pair{i, 0})
	}
	for h.Len() &gt; 0 &amp;&amp; len(ans) &lt; k {
		p := heap.Pop(&amp;h).(pair)
		i, j := p.i, p.j
		ans = append(ans, []int{nums1[i], nums2[j]})
		if j+1 &lt; n {
			heap.Push(&amp;h, pair{i, j + 1})
		}
	}
	return
}
<em></em>
type hp struct {
	data         []pair
	nums1, nums2 []int
}
<em></em>
type pair struct {
	i, j int
}
<em></em>
func (h hp) Len() int {
	return len(h.data)
}
<em></em>
func (h hp) Less(i, j int) bool {
	p1, p2 := h.data[i], h.data[j]
	return h.nums1[p1.i]+h.nums2[p1.j] &lt; h.nums1[p2.i]+h.nums2[p2.j]
}
<em></em>
func (h hp) Swap(i, j int) {
	h.data[i], h.data[j] = h.data[j], h.data[i]
}
<em></em>
func (h *hp) Push(val interface{}) {
	h.data = append(h.data, val.(pair))
}
<em></em>
func (h *hp) Pop() interface{} {
	data := h.data
	val := data[len(data)-1]
	h.data = data[:len(data)-1]
	return val
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-0", "code-example-tab-0-cpp")})()</script>
<h2 id="62"><a class="header" href="#62">62、</a></h2>
<p><code>剑指 Offer II 062. 实现前缀树</code></p>
<p>设计一个前缀树，提供数据插入，数据搜索，判断是否存在某个前缀</p>
<div><select onchange="changeCodeExample('code-example-tab-1', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-1-cpp">cpp</option><option value="code-example-tab-1-go">go</option></select></div>
<div id="code-example-tab-1-cpp" class="code-example-tab-1"><pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
class Trie {
public:
  Trie() : children(26, nullptr), isEnd(false) {}
<em></em>
  void Insert(const std::string &amp;word) {
    Trie *node = this;
    for (char ch : word) {
      ch -= &#39;a&#39;;
      if (node-&gt;children[ch] == nullptr) {
        node-&gt;children[ch] = new Trie();
      }
      node = node-&gt;children[ch];
    }
    node-&gt;isEnd = true;
  }
<em></em>
  bool Search(const std::string &amp;word) {
    Trie *node = SearchPrefix(word);
    return node != nullptr &amp;&amp; node-&gt;isEnd;
  }
<em></em>
  bool StartsWith(const std::string &amp;prefix) {
    return SearchPrefix(prefix) != nullptr;
  }
<em></em>
private:
  std::vector&lt;Trie *&gt; children;
  bool isEnd;
<em></em>
  Trie *SearchPrefix(const std::string &amp;prefix) {
    Trie *node = this;
    for (char ch : prefix) {
      ch -= &#39;a&#39;;
      if (node-&gt;children[ch] == nullptr) {
        return nullptr;
      }
      node = node-&gt;children[ch];
    }
    return node;
  }
};
</code></pre></div><div id="code-example-tab-1-go" class="code-example-tab-1"><pre><code class="language-go">package main
<em></em>
type Trie struct {
	children [26]*Trie
	isEnd    bool
}
<em></em>
func Constructor() Trie {
	return Trie{}
}
<em></em>
func (t *Trie) Insert(word string) {
	node := t
	for _, ch := range word {
		ch -= &#39;a&#39;
		if node.children[ch] == nil {
			node.children[ch] = &amp;Trie{}
		}
		node = node.children[ch]
	}
	node.isEnd = true
}
<em></em>
func (t *Trie) SearchPrefix(prefix string) *Trie {
	node := t
	for _, ch := range prefix {
		ch -= &#39;a&#39;
		if node.children[ch] == nil {
			return nil
		}
		node = node.children[ch]
	}
	return node
}
<em></em>
func (t *Trie) Search(word string) bool {
	node := t.SearchPrefix(word)
	return node != nil &amp;&amp; node.isEnd
}
<em></em>
func (t *Trie) StartsWith(prefix string) bool {
	return t.SearchPrefix(prefix) != nil
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-1", "code-example-tab-1-cpp")})()</script>
<h2 id="63"><a class="header" href="#63">63、</a></h2>
<p><code>剑指 Offer II 063. 替换单词</code></p>
<p>当一个词为另一个词的前缀那么称其为词根，后者称为继承词</p>
<p>给定一个词根数组，一个句子，将句子中的所有词语，如果存在其词根，那么就用词根进行替换</p>
<div><select onchange="changeCodeExample('code-example-tab-2', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-2-cpp">cpp</option><option value="code-example-tab-2-go">go</option></select></div>
<div id="code-example-tab-2-cpp" class="code-example-tab-2"><pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
class Trie {
public:
  unordered_map&lt;char, Trie *&gt; children;
  bool isEnd = false;
<em></em>
  void insert(const string &amp;word) {
    Trie *node = this;
    for (char c : word) {
      if (node-&gt;children.find(c) == node-&gt;children.end()) {
        node-&gt;children[c] = new Trie();
      }
      node = node-&gt;children[c];
    }
    node-&gt;isEnd = true;
  }
<em></em>
  string searchRoot(const string &amp;word) {
    Trie *node = this;
    for (int i = 0; i &lt; word.size(); ++i) {
      char c = word[i];
      if (node-&gt;isEnd) {
        return word.substr(0, i);
      }
      if (node-&gt;children.find(c) == node-&gt;children.end()) {
        break;
      }
      node = node-&gt;children[c];
    }
    return word;
  }
};
<em></em>
string replaceWords(vector&lt;string&gt; &amp;dictionary, const string &amp;sentence) {
  Trie root;
  for (const string &amp;word : dictionary) {
    root.insert(word);
  }
<em></em>
  istringstream iss(sentence);
  string word;
  string result;
  while (iss &gt;&gt; word) {
    if (!result.empty()) {
      result += &quot; &quot;;
    }
    result += root.searchRoot(word);
  }
<em></em>
  return result;
}
</code></pre></div><div id="code-example-tab-2-go" class="code-example-tab-2"><pre><code class="language-go">package main
<em></em>
import &quot;strings&quot;
<em></em>
func replaceWords(dictionary []string, sentence string) string {
	type trie map[rune]trie
	root := trie{}
	for _, s := range dictionary {
		cur := root
		for _, c := range s {
			if cur[c] == nil {
				cur[c] = trie{}
			}
			cur = cur[c]
		}
		cur[&#39;#&#39;] = trie{}
	}
<em></em>
	words := strings.Split(sentence, &quot; &quot;)
	for i, word := range words {
		cur := root
		for j, c := range word {
			if cur[&#39;#&#39;] != nil {
				words[i] = word[:j]
				break
			}
			if cur[c] == nil {
				break
			}
			cur = cur[c]
		}
	}
	return strings.Join(words, &quot; &quot;)
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-2", "code-example-tab-2-cpp")})()</script>
<h2 id="64"><a class="header" href="#64">64、</a></h2>
<p><code>剑指 Offer II 064. 神奇的字典</code></p>
<p>一个初始字符串列表，提供一个搜索方法，判断需要搜索的字符串进行一次字符替换后是否出现在初始字符串列表。</p>
<div><select onchange="changeCodeExample('code-example-tab-3', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-3-cpp">cpp</option><option value="code-example-tab-3-go">go</option></select></div>
<div id="code-example-tab-3-cpp" class="code-example-tab-3"><pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
class Trie {
public:
  Trie *children[26] = {nullptr};
  bool isEnd = false;
};
<em></em>
class MagicDictionary {
public:
  MagicDictionary() { root = new Trie(); }
<em></em>
  void BuildDict(const std::vector&lt;std::string&gt; &amp;dictionary) {
    for (const std::string &amp;word : dictionary) {
      Trie *node = root;
      for (char ch : word) {
        int idx = ch - &#39;a&#39;;
        if (node-&gt;children[idx] == nullptr) {
          node-&gt;children[idx] = new Trie();
        }
        node = node-&gt;children[idx];
      }
      node-&gt;isEnd = true;
    }
  }
<em></em>
  bool Search(const std::string &amp;searchWord) {
    return dfs(root, searchWord, 0, false);
  }
<em></em>
private:
  Trie *root;
<em></em>
  bool dfs(Trie *node, const std::string &amp;word, int index, bool modified) {
    if (index == word.size()) {
      return modified &amp;&amp; node-&gt;isEnd;
    }
    int c = word[index] - &#39;a&#39;;
    if (node-&gt;children[c] != nullptr &amp;&amp;
        dfs(node-&gt;children[c], word, index + 1, modified)) {
      return true;
    }
    if (!modified) {
      for (int i = 0; i &lt; 26; ++i) {
        if (i != c &amp;&amp; node-&gt;children[i] != nullptr &amp;&amp;
            dfs(node-&gt;children[i], word, index + 1, true)) {
          return true;
        }
      }
    }
    return false;
  }
};
</code></pre></div><div id="code-example-tab-3-go" class="code-example-tab-3"><pre><code class="language-go">package main
<em></em>
type MagicDictionary struct {
	trie *trie
}
<em></em>
type trie struct {
	children [26]*trie
	isEnd    bool
}
<em></em>
/** Initialize your data structure here. */
func NewMagicDictionary() MagicDictionary {
	return MagicDictionary{trie: &amp;trie{}}
}
<em></em>
func (this *MagicDictionary) BuildDict(dictionary []string) {
	for _, word := range dictionary {
		cur := this.trie
		for _, ch := range word {
			idx := ch - &#39;a&#39;
			if cur.children[idx] == nil {
				cur.children[idx] = &amp;trie{}
			}
			cur = cur.children[idx]
		}
		cur.isEnd = true
	}
}
<em></em>
func (this *MagicDictionary) Search(searchWord string) bool {
	var dfs func(node *trie, searchWord string, modified bool) bool
	dfs = func(node *trie, searchWord string, modified bool) bool {
		if searchWord == &quot;&quot; {
			return modified &amp;&amp; node.isEnd
		}
		c := searchWord[0] - &#39;a&#39;
		if node.children[c] != nil &amp;&amp; dfs(node.children[c], searchWord[1:], modified) {
			return true
		}
		if !modified {
			for i, child := range node.children {
				if i != int(c) &amp;&amp; child != nil &amp;&amp; dfs(child, searchWord[1:], true) {
					return true
				}
			}
		}
		return false
	}
	return dfs(this.trie, searchWord, false)
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-3", "code-example-tab-3-cpp")})()</script>
<h2 id="65"><a class="header" href="#65">65、</a></h2>
<p><code>剑指 Offer II 065. 最短的单词编码</code></p>
<blockquote>
<p>暂时没理解到含义，详情查看https://leetcode.cn/problems/iSwD2y/?favorite=e8X3pBZi</p>
</blockquote>
<div><select onchange="changeCodeExample('code-example-tab-4', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-4-cpp">cpp</option><option value="code-example-tab-4-go">go</option></select></div>
<div id="code-example-tab-4-cpp" class="code-example-tab-4"><pre><code class="language-cpp">{{#include ../../../code/algo/getoffer/c++/3/short_word_encode.cpp}}
</code></pre></div><div id="code-example-tab-4-go" class="code-example-tab-4"><pre><code class="language-go">package main
<em></em>
type WordEncodeTrie struct {
	child [26]*WordEncodeTrie
	depth int
}
<em></em>
func NewTrie() *WordEncodeTrie {
	return &amp;WordEncodeTrie{
		child: [26]*WordEncodeTrie{},
		depth: 1,
	}
}
<em></em>
func (t *WordEncodeTrie) Insert(word string) {
	curr := t
	n := len(word)
	for i := n - 1; i &gt;= 0; i-- {
		c := word[i] - &#39;a&#39;
		if curr.child[c] == nil {
			curr.child[c] = NewTrie()
		}
		curr.child[c].depth = curr.depth + 1
		curr = curr.child[c]
	}
}
<em></em>
func minimumLengthEncoding(words []string) int {
	t := NewTrie()
	for _, w := range words {
		t.Insert(w)
	}
	var res int
	var dfs func(node *WordEncodeTrie)
	dfs = func(node *WordEncodeTrie) {
		var hasChild bool
		for i := 0; i &lt; 26; i++ {
			if node.child[i] != nil {
				hasChild = true
				dfs(node.child[i])
			}
		}
		if !hasChild {
			res += node.depth
		}
	}
	dfs(t)
	return res
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-4", "code-example-tab-4-cpp")})()</script>
<h2 id="66"><a class="header" href="#66">66、</a></h2>
<p><code>剑指 Offer II 066. 单词之和</code></p>
<p>提供两个方法，插入字符串以及个数，查询一个前缀所包含的值的大小。</p>
<p>如果该key已经存在则进行替换，给定一个字符串查询以该字符串为前缀的元素总和</p>
<div><select onchange="changeCodeExample('code-example-tab-5', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-5-cpp">cpp</option><option value="code-example-tab-5-go">go</option></select></div>
<div id="code-example-tab-5-cpp" class="code-example-tab-5"><pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
class TrieNode {
public:
  TrieNode *children[26] = {nullptr};
  int val = 0;
};
<em></em>
class MapSum {
public:
  MapSum() { root = new TrieNode(); }
<em></em>
  void Insert(const std::string &amp;key, int val) {
    int delta = val;
    if (cnt.find(key) != cnt.end()) {
      delta -= cnt[key];
    }
    cnt[key] = val;
    TrieNode *node = root;
    for (char ch : key) {
      ch -= &#39;a&#39;;
      if (node-&gt;children[ch] == nullptr) {
        node-&gt;children[ch] = new TrieNode();
      }
      node = node-&gt;children[ch];
      node-&gt;val += delta;
    }
  }
<em></em>
  int Sum(const std::string &amp;prefix) {
    TrieNode *node = root;
    for (char ch : prefix) {
      ch -= &#39;a&#39;;
      if (node-&gt;children[ch] == nullptr) {
        return 0;
      }
      node = node-&gt;children[ch];
    }
    return node-&gt;val;
  }
<em></em>
private:
  TrieNode *root;
  std::unordered_map&lt;std::string, int&gt; cnt;
};
</code></pre></div><div id="code-example-tab-5-go" class="code-example-tab-5"><pre><code class="language-go">package main
<em></em>
type TrieNode struct {
	children [26]*TrieNode
	val      int
}
<em></em>
type MapSum struct {
	root *TrieNode
	cnt  map[string]int
}
<em></em>
func NewMapSum() MapSum {
	return MapSum{
		&amp;TrieNode{},
		map[string]int{},
	}
}
<em></em>
func (m *MapSum) Insert(key string, val int) {
	delta := val
	if m.cnt[key] &gt; 0 {
		delta -= m.cnt[key]
	}
	m.cnt[key] = val
	node := m.root
	for _, ch := range key {
		ch -= &#39;a&#39;
		if node.children[ch] == nil {
			node.children[ch] = &amp;TrieNode{}
		}
		node = node.children[ch]
		node.val += delta
	}
}
<em></em>
func (m *MapSum) Sum(prefix string) int {
	node := m.root
	for _, ch := range prefix {
		ch -= &#39;a&#39;
		if node.children[ch] == nil {
			return 0
		}
		node = node.children[ch]
	}
	return node.val
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-5", "code-example-tab-5-cpp")})()</script>
<h2 id="67"><a class="header" href="#67">67、</a></h2>
<p><code>剑指 Offer II 067. 最大的异或</code></p>
<p>给定一个整数数组，两两元素进行异或，找到最大值</p>
<div><select onchange="changeCodeExample('code-example-tab-6', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-6-cpp">cpp</option><option value="code-example-tab-6-go">go</option></select></div>
<div id="code-example-tab-6-cpp" class="code-example-tab-6"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
const int highBit = 30;
<em></em>
class Trie {
public:
  Trie *left = nullptr;
  Trie *right = nullptr;
<em></em>
  void add(int num) {
    Trie *cur = this;
    for (int i = highBit; i &gt;= 0; --i) {
      int bit = (num &gt;&gt; i) &amp; 1;
      if (bit == 0) {
        if (cur-&gt;left == nullptr) {
          cur-&gt;left = new Trie();
        }
        cur = cur-&gt;left;
      } else {
        if (cur-&gt;right == nullptr) {
          cur-&gt;right = new Trie();
        }
        cur = cur-&gt;right;
      }
    }
  }
<em></em>
  int check(int num) {
    Trie *cur = this;
    int x = 0;
    for (int i = highBit; i &gt;= 0; --i) {
      int bit = (num &gt;&gt; i) &amp; 1;
      if (bit == 0) {
        if (cur-&gt;right != nullptr) {
          cur = cur-&gt;right;
          x = x * 2 + 1;
        } else {
          cur = cur-&gt;left;
          x = x * 2;
        }
      } else {
        if (cur-&gt;left != nullptr) {
          cur = cur-&gt;left;
          x = x * 2 + 1;
        } else {
          cur = cur-&gt;right;
          x = x * 2;
        }
      }
    }
    return x;
  }
};
<em></em>
int findMaximumXOR(const std::vector&lt;int&gt; &amp;nums) {
  Trie *root = new Trie();
  int x = 0;
  for (int i = 1; i &lt; nums.size(); ++i) {
    root-&gt;add(nums[i - 1]);
    x = std::max(x, root-&gt;check(nums[i]));
  }
  return x;
}
</code></pre></div><div id="code-example-tab-6-go" class="code-example-tab-6"><pre><code class="language-go">package main
<em></em>
const highBit = 30
<em></em>
type xor_trie struct {
	left, right *xor_trie
}
<em></em>
func (t *xor_trie) add(num int) {
	cur := t
	for i := highBit; i &gt;= 0; i-- {
		bit := num &gt;&gt; i &amp; 1
		if bit == 0 {
			if cur.left == nil {
				cur.left = &amp;xor_trie{}
			}
			cur = cur.left
		} else {
			if cur.right == nil {
				cur.right = &amp;xor_trie{}
			}
			cur = cur.right
		}
	}
}
<em></em>
func (t *xor_trie) check(num int) (x int) {
	cur := t
	for i := highBit; i &gt;= 0; i-- {
		bit := num &gt;&gt; i &amp; 1
		if bit == 0 {
			// a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走
			if cur.right != nil {
				cur = cur.right
				x = x*2 + 1
			} else {
				cur = cur.left
				x = x * 2
			}
		} else {
			// a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走
			if cur.left != nil {
				cur = cur.left
				x = x*2 + 1
			} else {
				cur = cur.right
				x = x * 2
			}
		}
	}
	return
}
<em></em>
func findMaximumXOR(nums []int) (x int) {
	root := &amp;xor_trie{}
	for i := 1; i &lt; len(nums); i++ {
		// 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中
		root.add(nums[i-1])
		// 将 nums[i] 看作 ai，找出最大的 x 更新答案
		x = max(x, root.check(nums[i]))
	}
	return
}
<em></em>
func max(a, b int) int {
	if a &gt; b {
		return a
	}
	return b
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-6", "code-example-tab-6-cpp")})()</script>
<h2 id="68"><a class="header" href="#68">68、</a></h2>
<p><code>剑指 Offer II 068. 查找插入位置</code></p>
<p>往一个有序数组中进行数据插入，查找数据的插入位置，要求使用O(logn)复杂度</p>
<div><select onchange="changeCodeExample('code-example-tab-7', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-7-cpp">cpp</option><option value="code-example-tab-7-go">go</option></select></div>
<div id="code-example-tab-7-cpp" class="code-example-tab-7"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
int searchInsert(const std::vector&lt;int&gt; &amp;nums, int target) {
  int n = nums.size();
  int left = 0, right = n - 1;
  int ans = n;
  while (left &lt;= right) {
    int mid = (right - left) / 2 + left;
    if (target &lt;= nums[mid]) {
      ans = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return ans;
}
</code></pre></div><div id="code-example-tab-7-go" class="code-example-tab-7"><pre><code class="language-go">package main
<em></em>
func searchInsert(nums []int, target int) int {
	n := len(nums)
	left, right := 0, n-1
	ans := n
	for left &lt;= right {
		mid := (right-left)&gt;&gt;1 + left
		if target &lt;= nums[mid] {
			ans = mid
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-7", "code-example-tab-7-cpp")})()</script>
<h2 id="69"><a class="header" href="#69">69、</a></h2>
<p><code>剑指 Offer II 069. 山峰数组的顶部</code></p>
<p>找到下标i，在i之前是递增数据，在i之后是递减数据</p>
<p>题目保证满足存在这样的i</p>
<div><select onchange="changeCodeExample('code-example-tab-8', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-8-cpp">cpp</option><option value="code-example-tab-8-go">go</option></select></div>
<div id="code-example-tab-8-cpp" class="code-example-tab-8"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
int peakIndexInMountainArray(const std::vector&lt;int&gt; &amp;arr) {
  return std::distance(arr.begin(), std::find_if(
                                        arr.begin(), arr.end() - 1,
                                        &amp;{ return arr[i] &gt; arr[i + 1]; }));
}
</code></pre></div><div id="code-example-tab-8-go" class="code-example-tab-8"><pre><code class="language-go">package main
<em></em>
import &quot;sort&quot;
<em></em>
func peakIndexInMountainArray(arr []int) int {
	return sort.Search(len(arr)-1, func(i int) bool { return arr[i] &gt; arr[i+1] })
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-8", "code-example-tab-8-cpp")})()</script>
<h2 id="70"><a class="header" href="#70">70、</a></h2>
<p>剑指 Offer II 070. 排序数组中只出现一次的数字</p>
<p>一个有序数组，有一个元素只出现一次，其他元素出现了两次，找到这个只出现了一次的元素，满足O(logn)时间复杂度，O(1)空间复杂度</p>
<div><select onchange="changeCodeExample('code-example-tab-9', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-9-cpp">cpp</option><option value="code-example-tab-9-go">go</option></select></div>
<div id="code-example-tab-9-cpp" class="code-example-tab-9"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
int singleNonDuplicate(const std::vector&lt;int&gt; &amp;nums) {
  int low = 0, high = nums.size() - 1;
  while (low &lt; high) {
    int mid = low + (high - low) / 2;
    if (nums[mid] == nums[mid ^ 1]) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nums[low];
}
</code></pre></div><div id="code-example-tab-9-go" class="code-example-tab-9"><pre><code class="language-go">package main
<em></em>
func singleNonDuplicate(nums []int) int {
	low, high := 0, len(nums)-1
	for low &lt; high {
		mid := low + (high-low)/2
		if nums[mid] == nums[mid^1] {
			low = mid + 1
		} else {
			high = mid
		}
	}
	return nums[low]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-9", "code-example-tab-9-cpp")})()</script>
<h2 id="71"><a class="header" href="#71">71、</a></h2>
<p><code>剑指 Offer II 071. 按权重生成随机数</code></p>
<p>按照值的大小作为权重占比进行随机数获取，返回其数据下标</p>
<div><select onchange="changeCodeExample('code-example-tab-10', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-10-cpp">cpp</option><option value="code-example-tab-10-go">go</option></select></div>
<div id="code-example-tab-10-cpp" class="code-example-tab-10"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
<em></em>
class Solution {
public:
  Solution(std::vector&lt;int&gt; &amp;w) {
    for (int i = 1; i &lt; w.size(); ++i) {
      w[i] += w[i - 1];
    }
    pre = w;
  }
<em></em>
  int PickIndex() {
    int x = rand() % pre.back() + 1;
    return std::lower_bound(pre.begin(), pre.end(), x) - pre.begin();
  }
<em></em>
private:
  std::vector&lt;int&gt; pre;
};
</code></pre></div><div id="code-example-tab-10-go" class="code-example-tab-10"><pre><code class="language-go">package main
<em></em>
import (
	&quot;math/rand&quot;
	&quot;sort&quot;
)
<em></em>
type WeightRandom struct {
	pre []int
}
<em></em>
func NewWeightRandom(w []int) WeightRandom {
	for i := 1; i &lt; len(w); i++ {
		w[i] += w[i-1]
	}
	return WeightRandom{w}
}
<em></em>
func (s *WeightRandom) PickIndex() int {
	x := rand.Intn(s.pre[len(s.pre)-1]) + 1
	return sort.SearchInts(s.pre, x)
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-10", "code-example-tab-10-cpp")})()</script>
<pre><code class="language-go">
</code></pre>
<h2 id="72"><a class="header" href="#72">72、</a></h2>
<p><code>剑指 Offer II 072. 求平方根</code></p>
<p>计算一个整数的开平方根，只取正数那一个</p>
<div><select onchange="changeCodeExample('code-example-tab-11', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-11-cpp">cpp</option><option value="code-example-tab-11-go">go</option></select></div>
<div id="code-example-tab-11-cpp" class="code-example-tab-11"><pre><code class="language-cpp">int mySqrt(int x) {
  int l = 0, r = x;
  int ans = -1;
  while (l &lt;= r) {
    int mid = l + (r - l) / 2;
    if (mid * mid &lt;= x) {
      ans = mid;
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }
  return ans;
}
</code></pre></div><div id="code-example-tab-11-go" class="code-example-tab-11"><pre><code class="language-go">package main
<em></em>
func mySqrt(x int) int {
	l, r := 0, x
	ans := -1
	for l &lt;= r {
		mid := l + (r-l)/2
		if mid*mid &lt;= x {
			ans = mid
			l = mid + 1
		} else {
			r = mid - 1
		}
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-11", "code-example-tab-11-cpp")})()</script>
<h2 id="73"><a class="header" href="#73">73、</a></h2>
<p><code>剑指 Offer II 073. 狒狒吃香蕉</code></p>
<p>n堆香蕉，在h小时内要吃完，选择要吃完所有香蕉的最小速度，不过需要注意如果选择了一堆香蕉后，小于k个也会等待下一个小时才会继续吃。</p>
<div><select onchange="changeCodeExample('code-example-tab-12', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-12-cpp">cpp</option><option value="code-example-tab-12-go">go</option></select></div>
<div id="code-example-tab-12-cpp" class="code-example-tab-12"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
int minEatingSpeed(const std::vector&lt;int&gt; &amp;piles, int h) {
  int maxPile = *std::max_element(piles.begin(), piles.end());
  return 1 + std::lower_bound(1, maxPile - 1, [&amp;](int speed) -&gt; bool {
           int time = 0;
           for (int pile : piles) {
             time += (pile + speed - 1) / speed;
           }
           return time &lt;= h;
         });
}
</code></pre></div><div id="code-example-tab-12-go" class="code-example-tab-12"><pre><code class="language-go">package main
<em></em>
import &quot;sort&quot;
<em></em>
func minEatingSpeed(piles []int, h int) int {
	max := 0
	for _, pile := range piles {
		if pile &gt; max {
			max = pile
		}
	}
	return 1 + sort.Search(max-1, func(speed int) bool {
		speed++
		time := 0
		for _, pile := range piles {
			time += (pile + speed - 1) / speed
		}
		return time &lt;= h
	})
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-12", "code-example-tab-12-cpp")})()</script>
<h2 id="74"><a class="header" href="#74">74、</a></h2>
<p><code>剑指 Offer II 074. 合并区间</code></p>
<p>给定一个元组数组，其中的元素即为一个左右区间，将所有重叠的区间进行合并，并返回一个不重叠的区间数组</p>
<div><select onchange="changeCodeExample('code-example-tab-13', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-13-cpp">cpp</option><option value="code-example-tab-13-go">go</option></select></div>
<div id="code-example-tab-13-cpp" class="code-example-tab-13"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt; &amp;intervals) {
  sort(intervals.begin(), intervals.end(),
       [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) {
         return a[0] &lt; b[0] || (a[0] == b[0] &amp;&amp; a[1] &lt; b[1]);
       });
<em></em>
  vector&lt;vector&lt;int&gt;&gt; res;
  for (const auto &amp;interval : intervals) {
    if (res.empty() || res.back()[1] &lt; interval[0]) {
      res.push_back(interval);
    } else {
      res.back()[1] = max(res.back()[1], interval[1]);
    }
  }
  return res;
}
<em></em>
int max(int a, int b) { return (a &gt; b) ? a : b; }
</code></pre></div><div id="code-example-tab-13-go" class="code-example-tab-13"><pre><code class="language-go">package main
<em></em>
import &quot;sort&quot;
<em></em>
func merge(intervals [][]int) [][]int {
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] &lt; intervals[j][0] || (intervals[i][0] == intervals[j][0] &amp;&amp; intervals[i][1] &lt; intervals[j][1])
	})
	var res [][]int
	for _, interval := range intervals {
		if len(res) == 0 || res[len(res)-1][1] &lt; interval[0] {
			res = append(res, interval)
		} else {
			res[len(res)-1][1] = max(res[len(res)-1][1], interval[1])
		}
	}
	return res
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-13", "code-example-tab-13-cpp")})()</script>
<h2 id="75"><a class="header" href="#75">75</a></h2>
<p><code>剑指 Offer II 075. 数组相对排序</code></p>
<p>给定两个数组arr1和arr2，将arr1按照arr2的顺序进行排序，未出现过的就按照升序之后放在arr1的末尾。</p>
<div><select onchange="changeCodeExample('code-example-tab-14', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-14-cpp">cpp</option><option value="code-example-tab-14-go">go</option></select></div>
<div id="code-example-tab-14-cpp" class="code-example-tab-14"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
class ZSet {
public:
  void insert(int key) { data[key]++; }
<em></em>
  void erase(int key) { data.erase(key); }
<em></em>
  vector&lt;int&gt; keys() const {
    vector&lt;int&gt; res;
    for (const auto &amp;[key, _] : data) {
      res.push_back(key);
    }
    sort(res.begin(), res.end());
    return res;
  }
<em></em>
  int count(int key) const {
    auto it = data.find(key);
    return it != data.end() ? it-&gt;second : 0;
  }
<em></em>
private:
  unordered_map&lt;int, int&gt; data;
};
<em></em>
vector&lt;int&gt; relativeSortArray(vector&lt;int&gt; &amp;arr1, const vector&lt;int&gt; &amp;arr2) {
  ZSet zs;
  for (int val : arr1) {
    zs.insert(val);
  }
<em></em>
  vector&lt;int&gt; res;
  for (int val : arr2) {
    int count = zs.count(val);
    res.insert(res.end(), count, val);
    zs.erase(val);
  }
<em></em>
  vector&lt;int&gt; remainingKeys = zs.keys();
  for (int key : remainingKeys) {
    int count = zs.count(key);
    res.insert(res.end(), count, key);
  }
<em></em>
  return res;
}
</code></pre></div><div id="code-example-tab-14-go" class="code-example-tab-14"><pre><code class="language-go">package main
<em></em>
import &quot;sort&quot;
<em></em>
type zset map[int]int
<em></em>
func (zs *zset) keys() []int {
	res := []int{}
	for key := range *zs {
		res = append(res, key)
	}
	sort.Ints(res)
	return res
}
<em></em>
func relativeSortArray(arr1 []int, arr2 []int) []int {
	zs := zset{}
	for _, val := range arr1 {
		zs[val]++
	}
<em></em>
	res := make([]int, 0, len(arr1))
	for _, val := range arr2 {
		for i := 0; i &lt; zs[val]; i++ {
			res = append(res, val)
		}
		delete(zs, val)
	}
	for _, key := range zs.keys() {
		for i := 0; i &lt; zs[key]; i++ {
			res = append(res, key)
		}
	}
	return res
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-14", "code-example-tab-14-cpp")})()</script>
<h2 id="76"><a class="header" href="#76">76</a></h2>
<p><code>剑指 Offer II 076. 数组中的第 k 大的数字</code></p>
<p>给定一个整数数组和整数，返回数组中第k个最大的元素</p>
<div><select onchange="changeCodeExample('code-example-tab-15', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-15-cpp">cpp</option><option value="code-example-tab-15-go">go</option></select></div>
<div id="code-example-tab-15-cpp" class="code-example-tab-15"><pre><code class="language-cpp">#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
int partition(vector&lt;int&gt; &amp;a, int l, int r) {
  int x = a[r];
  int i = l - 1;
  for (int j = l; j &lt; r; ++j) {
    if (a[j] &lt;= x) {
      ++i;
      swap(a[i], a[j]);
    }
  }
  swap(a[i + 1], a[r]);
  return i + 1;
}
<em></em>
int randomPartition(vector&lt;int&gt; &amp;a, int l, int r) {
  int i = rand() % (r - l + 1) + l;
  swap(a[i], a[r]);
  return partition(a, l, r);
}
<em></em>
int quickSelect(vector&lt;int&gt; &amp;a, int l, int r, int index) {
  int q = randomPartition(a, l, r);
  if (q == index) {
    return a[q];
  } else if (q &lt; index) {
    return quickSelect(a, q + 1, r, index);
  }
  return quickSelect(a, l, q - 1, index);
}
<em></em>
int findKthLargest(vector&lt;int&gt; &amp;nums, int k) {
  srand(time(0));
  return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
}
</code></pre></div><div id="code-example-tab-15-go" class="code-example-tab-15"><pre><code class="language-go">package main
<em></em>
import (
	&quot;math/rand&quot;
	&quot;time&quot;
)
<em></em>
func findKthLargest(nums []int, k int) int {
	rand.Seed(time.Now().UnixNano())
	return quickSelect(nums, 0, len(nums)-1, len(nums)-k)
}
<em></em>
func quickSelect(a []int, l, r, index int) int {
	q := randomPartition(a, l, r)
	if q == index {
		return a[q]
	} else if q &lt; index {
		return quickSelect(a, q+1, r, index)
	}
	return quickSelect(a, l, q-1, index)
}
<em></em>
func randomPartition(a []int, l, r int) int {
	i := rand.Int()%(r-l+1) + l
	a[i], a[r] = a[r], a[i]
	return partition(a, l, r)
}
<em></em>
func partition(a []int, l, r int) int {
	x := a[r]
	i := l - 1
	for j := l; j &lt; r; j++ {
		if a[j] &lt;= x {
			i++
			a[i], a[j] = a[j], a[i]
		}
	}
	a[i+1], a[r] = a[r], a[i+1]
	return i + 1
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-15", "code-example-tab-15-cpp")})()</script>
<h2 id="77"><a class="header" href="#77">77</a></h2>
<p><code>剑指 Offer II 077. 链表排序</code></p>
<p>对链表节点进行升序排序</p>
<div><select onchange="changeCodeExample('code-example-tab-16', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-16-cpp">cpp</option><option value="code-example-tab-16-go">go</option></select></div>
<div id="code-example-tab-16-cpp" class="code-example-tab-16"><pre><code class="language-cpp">struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(nullptr) {}
};
<em></em>
ListNode *merge(ListNode *head1, ListNode *head2) {
  ListNode dummyHead(0);
  ListNode *temp = &amp;dummyHead;
  ListNode *temp1 = head1;
  ListNode *temp2 = head2;
<em></em>
  while (temp1 != nullptr &amp;&amp; temp2 != nullptr) {
    if (temp1-&gt;val &lt;= temp2-&gt;val) {
      temp-&gt;next = temp1;
      temp1 = temp1-&gt;next;
    } else {
      temp-&gt;next = temp2;
      temp2 = temp2-&gt;next;
    }
    temp = temp-&gt;next;
  }
<em></em>
  if (temp1 != nullptr) {
    temp-&gt;next = temp1;
  } else if (temp2 != nullptr) {
    temp-&gt;next = temp2;
  }
<em></em>
  return dummyHead.next;
}
<em></em>
ListNode *sort(ListNode *head, ListNode *tail) {
  if (head == nullptr) {
    return head;
  }
<em></em>
  if (head-&gt;next == tail) {
    head-&gt;next = nullptr;
    return head;
  }
<em></em>
  ListNode *slow = head;
  ListNode *fast = head;
  while (fast != tail) {
    slow = slow-&gt;next;
    fast = fast-&gt;next;
    if (fast != tail) {
      fast = fast-&gt;next;
    }
  }
<em></em>
  ListNode *mid = slow;
  return merge(sort(head, mid), sort(mid, tail));
}
<em></em>
ListNode *sortList(ListNode *head) { return sort(head, nullptr); }
</code></pre></div><div id="code-example-tab-16-go" class="code-example-tab-16"><pre><code class="language-go">package main
<em></em>
type ListNode struct {
	Val  int
	Next *ListNode
}
<em></em>
func MergeList(head1, head2 *ListNode) *ListNode {
	dummyHead := &amp;ListNode{}
	temp, temp1, temp2 := dummyHead, head1, head2
	for temp1 != nil &amp;&amp; temp2 != nil {
		if temp1.Val &lt;= temp2.Val {
			temp.Next = temp1
			temp1 = temp1.Next
		} else {
			temp.Next = temp2
			temp2 = temp2.Next
		}
		temp = temp.Next
	}
	if temp1 != nil {
		temp.Next = temp1
	} else if temp2 != nil {
		temp.Next = temp2
	}
	return dummyHead.Next
}
<em></em>
func SortList(head, tail *ListNode) *ListNode {
	if head == nil {
		return head
	}
<em></em>
	if head.Next == tail {
		head.Next = nil
		return head
	}
<em></em>
	slow, fast := head, head
	for fast != tail {
		slow = slow.Next
		fast = fast.Next
		if fast != tail {
			fast = fast.Next
		}
	}
<em></em>
	mid := slow
	return MergeList(SortList(head, mid), SortList(mid, tail))
}
<em></em>
func sortList(head *ListNode) *ListNode {
	return SortList(head, nil)
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-16", "code-example-tab-16-cpp")})()</script>
<h2 id="78"><a class="header" href="#78">78</a></h2>
<p><code>剑指 Offer II 078. 合并排序链表</code></p>
<div><select onchange="changeCodeExample('code-example-tab-17', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-17-cpp">cpp</option><option value="code-example-tab-17-go">go</option></select></div>
<div id="code-example-tab-17-cpp" class="code-example-tab-17"><pre><code class="language-cpp">#include &lt;queue&gt;
#include &lt;vector&gt;
<em></em>
struct ListNode {
  int val;
  ListNode *next;
  ListNode(int x) : val(x), next(nullptr) {}
};
<em></em>
ListNode *mergeTwoLists(ListNode *list1, ListNode *list2) {
  ListNode dummyHead(0);
  ListNode *p = &amp;dummyHead;
  ListNode *p1 = list1;
  ListNode *p2 = list2;
<em></em>
  while (p1 != nullptr &amp;&amp; p2 != nullptr) {
    if (p1-&gt;val &gt; p2-&gt;val) {
      p-&gt;next = p2;
      p2 = p2-&gt;next;
    } else {
      p-&gt;next = p1;
      p1 = p1-&gt;next;
    }
    p = p-&gt;next;
  }
<em></em>
  if (p1 != nullptr) {
    p-&gt;next = p1;
  }
  if (p2 != nullptr) {
    p-&gt;next = p2;
  }
<em></em>
  return dummyHead.next;
}
<em></em>
ListNode *mergeKLists(std::vector&lt;ListNode *&gt; &amp;lists) {
  ListNode *res = nullptr;
  for (ListNode *list : lists) {
    res = mergeTwoLists(res, list);
  }
  return res;
}
</code></pre></div><div id="code-example-tab-17-go" class="code-example-tab-17"><pre><code class="language-go">package main
<em></em>
// 合并K个升序链表
func mergeKLists(lists []*ListNode) (res *ListNode) {
	for _, v := range lists {
		res = mergeTwoLists(res, v)
	}
	return res
}
<em></em>
// 合并两个升序链表
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
	//初始化一个虚拟的头节点
	newList := &amp;ListNode{}
	p := newList
	p1 := list1
	p2 := list2
	//遍历对比两个指针值的大小，有一个走完了就停止
	for p1 != nil &amp;&amp; p2 != nil {
		//将值小的节点接到p指针后面
		if p1.Val &gt; p2.Val {
			p.Next = p2
			p2 = p2.Next
		} else {
			p.Next = p1
			p1 = p1.Next
		}
		//p指针前进
		p = p.Next
	}
	//将未比较的剩余节点都放到p指针后面
	if p1 != nil {
		p.Next = p1
	}
	if p2 != nil {
		p.Next = p2
	}
	//返回虚拟头节点的下一个节点就是真正的头节点
	return newList.Next
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-17", "code-example-tab-17-cpp")})()</script>
<h2 id="79"><a class="header" href="#79">79</a></h2>
<p><code>剑指 Offer II 079. 所有子集</code></p>
<p>给定一个元素各不相同的的数组，返回所有不重复的子集</p>
<div><select onchange="changeCodeExample('code-example-tab-18', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-18-cpp">cpp</option><option value="code-example-tab-18-go">go</option></select></div>
<div id="code-example-tab-18-cpp" class="code-example-tab-18"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;nums) {
  vector&lt;vector&lt;int&gt;&gt; ans;
  int n = nums.size();
  for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) {
    vector&lt;int&gt; set;
    for (int i = 0; i &lt; n; ++i) {
      if (mask &amp; (1 &lt;&lt; i)) {
        set.push_back(nums[i]);
      }
    }
    ans.push_back(set);
  }
  return ans;
}
</code></pre></div><div id="code-example-tab-18-go" class="code-example-tab-18"><pre><code class="language-go">package main
<em></em>
func subsets(nums []int) (ans [][]int) {
	n := len(nums)
	for mask := 0; mask &lt; 1&lt;&lt;n; mask++ {
		set := []int{}
		for i, v := range nums {
			if mask&gt;&gt;i&amp;1 &gt; 0 {
				set = append(set, v)
			}
		}
		ans = append(ans, append([]int(nil), set...))
	}
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-18", "code-example-tab-18-cpp")})()</script>
<h2 id="80"><a class="header" href="#80">80</a></h2>
<p><code>剑指 Offer II 080. 含有 k 个元素的组合</code></p>
<p>给定整数n和k，返回<code>1...n</code>中所有可能的k个数的组合</p>
<div><select onchange="changeCodeExample('code-example-tab-19', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-19-cpp">cpp</option><option value="code-example-tab-19-go">go</option></select></div>
<div id="code-example-tab-19-cpp" class="code-example-tab-19"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
void dfs(int cur, int n, int k, vector&lt;int&gt; &amp;temp, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {
  // Pruning: if the remaining elements plus the current temp size is less than
  // k, return
  if (temp.size() + (n - cur + 1) &lt; k) {
    return;
  }
  // Record valid answers
  if (temp.size() == k) {
    ans.push_back(temp);
    return;
  }
  // Consider the current position
  temp.push_back(cur);
  dfs(cur + 1, n, k, temp, ans);
  temp.pop_back();
  // Consider not choosing the current position
  dfs(cur + 1, n, k, temp, ans);
}
<em></em>
vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
  vector&lt;vector&lt;int&gt;&gt; ans;
  vector&lt;int&gt; temp;
  dfs(1, n, k, temp, ans);
  return ans;
}
</code></pre></div><div id="code-example-tab-19-go" class="code-example-tab-19"><pre><code class="language-go">package main
<em></em>
func combine(n int, k int) (ans [][]int) {
	temp := []int{}
	var dfs func(int)
	dfs = func(cur int) {
		// 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp
		if len(temp)+(n-cur+1) &lt; k {
			return
		}
		// 记录合法的答案
		if len(temp) == k {
			comb := make([]int, k)
			copy(comb, temp)
			ans = append(ans, comb)
			return
		}
		// 考虑选择当前位置
		temp = append(temp, cur)
		dfs(cur + 1)
		temp = temp[:len(temp)-1]
		// 考虑不选择当前位置
		dfs(cur + 1)
	}
	dfs(1)
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-19", "code-example-tab-19-cpp")})()</script>
<h2 id="81"><a class="header" href="#81">81</a></h2>
<p><code>剑指 Offer II 081. 允许重复选择元素的组合</code></p>
<p>从数组中寻找和为目标值的组合，数组中的元素可以重复选择</p>
<blockquote>
<p>下面这种题解是标准解法，不过不能去除重复的情况，详情看82</p>
</blockquote>
<div><select onchange="changeCodeExample('code-example-tab-20', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-20-cpp">cpp</option><option value="code-example-tab-20-go">go</option></select></div>
<div id="code-example-tab-20-cpp" class="code-example-tab-20"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
void dfs(const vector&lt;int&gt; &amp;candidates, int target, int idx, vector&lt;int&gt; &amp;comb,
         vector&lt;vector&lt;int&gt;&gt; &amp;ans) {
  if (idx == candidates.size()) {
    return;
  }
  if (target == 0) {
    ans.push_back(comb);
    return;
  }
  // Skip the current number
  dfs(candidates, target, idx + 1, comb, ans);
  // Choose the current number
  if (target - candidates[idx] &gt;= 0) {
    comb.push_back(candidates[idx]);
    dfs(candidates, target - candidates[idx], idx, comb, ans);
    comb.pop_back();
  }
}
<em></em>
vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) {
  vector&lt;vector&lt;int&gt;&gt; ans;
  vector&lt;int&gt; comb;
  dfs(candidates, target, 0, comb, ans);
  return ans;
}
</code></pre></div><div id="code-example-tab-20-go" class="code-example-tab-20"><pre><code class="language-go">package main
<em></em>
func combinationSum(candidates []int, target int) (ans [][]int) {
	comb := []int{}
	var dfs func(target, idx int)
	dfs = func(target, idx int) {
		if idx == len(candidates) {
			return
		}
		if target == 0 {
			ans = append(ans, append([]int(nil), comb...))
			return
		}
		// 直接跳过
		dfs(target, idx+1)
		// 选择当前数
		if target-candidates[idx] &gt;= 0 {
			comb = append(comb, candidates[idx])
			dfs(target-candidates[idx], idx)
			comb = comb[:len(comb)-1]
		}
	}
	dfs(target, 0)
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-20", "code-example-tab-20-cpp")})()</script>
<h2 id="82"><a class="header" href="#82">82</a></h2>
<p><code>剑指 Offer II 082. 含有重复元素集合的组合</code></p>
<p>与81题类似，不过这里元素只能使用一次</p>
<div><select onchange="changeCodeExample('code-example-tab-21', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-21-cpp">cpp</option><option value="code-example-tab-21-go">go</option></select></div>
<div id="code-example-tab-21-cpp" class="code-example-tab-21"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
void dfs(int pos, int rest, const vector&lt;pair&lt;int, int&gt;&gt; &amp;freq,
         vector&lt;int&gt; &amp;sequence, vector&lt;vector&lt;int&gt;&gt; &amp;ans) {
  if (rest == 0) {
    ans.push_back(sequence);
    return;
  }
  if (pos == freq.size() || rest &lt; freq[pos].first) {
    return;
  }
<em></em>
  dfs(pos + 1, rest, freq, sequence, ans);
<em></em>
  int most = min(rest / freq[pos].first, freq[pos].second);
  for (int i = 1; i &lt;= most; ++i) {
    sequence.push_back(freq[pos].first);
    dfs(pos + 1, rest - i * freq[pos].first, freq, sequence, ans);
  }
  sequence.resize(sequence.size() - most);
}
<em></em>
vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt; &amp;candidates, int target) {
  sort(candidates.begin(), candidates.end());
  vector&lt;pair&lt;int, int&gt;&gt; freq;
  for (int num : candidates) {
    if (freq.empty() || num != freq.back().first) {
      freq.emplace_back(num, 1);
    } else {
      ++freq.back().second;
    }
  }
<em></em>
  vector&lt;vector&lt;int&gt;&gt; ans;
  vector&lt;int&gt; sequence;
  dfs(0, target, freq, sequence, ans);
  return ans;
}
<em></em>
int min(int a, int b) { return (a &lt; b) ? a : b; }
</code></pre></div><div id="code-example-tab-21-go" class="code-example-tab-21"><pre><code class="language-go">package main
<em></em>
import &quot;sort&quot;
<em></em>
func combinationSum2(candidates []int, target int) (ans [][]int) {
	sort.Ints(candidates)
	var freq [][2]int // [值，次数]
	for _, num := range candidates {
		if freq == nil || num != freq[len(freq)-1][0] {
			freq = append(freq, [2]int{num, 1})
		} else {
			freq[len(freq)-1][1]++
		}
	}
<em></em>
	var sequence []int
	var dfs func(pos, rest int)
	dfs = func(pos, rest int) {
		if rest == 0 {
			ans = append(ans, append([]int(nil), sequence...))
			return
		}
		if pos == len(freq) || rest &lt; freq[pos][0] {
			return
		}
<em></em>
		dfs(pos+1, rest)
<em></em>
		most := min(rest/freq[pos][0], freq[pos][1])
		for i := 1; i &lt;= most; i++ {
			sequence = append(sequence, freq[pos][0])
			dfs(pos+1, rest-i*freq[pos][0])
		}
		sequence = sequence[:len(sequence)-most]
	}
	dfs(0, target)
	return
}
<em></em>
func min(a, b int) int {
	if a &lt; b {
		return a
	}
	return b
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-21", "code-example-tab-21-cpp")})()</script>
<h2 id="83"><a class="header" href="#83">83</a></h2>
<p><code>剑指 Offer II 083. 没有重复元素集合的全排列</code></p>
<p>给定一个不包含重复数字的整数数组，返回所有可能的全排列</p>
<div><select onchange="changeCodeExample('code-example-tab-22', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-22-cpp">cpp</option><option value="code-example-tab-22-go">go</option></select></div>
<div id="code-example-tab-22-cpp" class="code-example-tab-22"><pre><code class="language-cpp">#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
void dfs(vector&lt;int&gt; &amp;nums, vector&lt;bool&gt; &amp;vis, vector&lt;int&gt; &amp;path,
         vector&lt;vector&lt;int&gt;&gt; &amp;ans) {
  if (path.size() == nums.size()) {
    ans.push_back(path);
    return;
  }
  for (int i = 0; i &lt; nums.size(); ++i) {
    if (!vis[i]) {
      vis[i] = true;
      path.push_back(nums[i]);
      dfs(nums, vis, path, ans);
      vis[i] = false;
      path.pop_back();
    }
  }
}
<em></em>
vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp;nums) {
  vector&lt;vector&lt;int&gt;&gt; ans;
  vector&lt;int&gt; path;
  vector&lt;bool&gt; vis(nums.size(), false);
  dfs(nums, vis, path, ans);
  return ans;
}
</code></pre></div><div id="code-example-tab-22-go" class="code-example-tab-22"><pre><code class="language-go">package main
<em></em>
func permute(nums []int) [][]int {
	n := len(nums)
	var ans [][]int
	var path []int
	vis := make([]bool, n)
	var dfs func()
	dfs = func() {
		if len(path) == n {
			ans = append(ans, append([]int{}, path...))
			return
		}
		for i := 0; i &lt; n; i++ {
			if !vis[i] {
				vis[i] = true
				path = append(path, nums[i])
				dfs()
				vis[i] = false
				path = path[:len(path)-1]
			}
		}
	}
	dfs()
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-22", "code-example-tab-22-cpp")})()</script>
<h2 id="84"><a class="header" href="#84">84</a></h2>
<p><code>剑指 Offer II 084. 含有重复元素集合的全排列</code></p>
<p>给定一个可包含重复数字的整数集合 nums ，按任意顺序 返回它所有不重复的全排列。</p>
<div><select onchange="changeCodeExample('code-example-tab-23', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-23-cpp">cpp</option><option value="code-example-tab-23-go">go</option></select></div>
<div id="code-example-tab-23-cpp" class="code-example-tab-23"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
void backtrack(vector&lt;int&gt; &amp;nums, vector&lt;bool&gt; &amp;vis, vector&lt;int&gt; &amp;perm,
               vector&lt;vector&lt;int&gt;&gt; &amp;ans, int idx) {
  if (idx == nums.size()) {
    ans.push_back(perm);
    return;
  }
  for (int i = 0; i &lt; nums.size(); ++i) {
    if (vis[i] || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !vis[i - 1])) {
      continue;
    }
    perm.push_back(nums[i]);
    vis[i] = true;
    backtrack(nums, vis, perm, ans, idx + 1);
    vis[i] = false;
    perm.pop_back();
  }
}
<em></em>
vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt; &amp;nums) {
  sort(nums.begin(), nums.end());
  vector&lt;vector&lt;int&gt;&gt; ans;
  vector&lt;int&gt; perm;
  vector&lt;bool&gt; vis(nums.size(), false);
  backtrack(nums, vis, perm, ans, 0);
  return ans;
}
</code></pre></div><div id="code-example-tab-23-go" class="code-example-tab-23"><pre><code class="language-go">package main
<em></em>
import &quot;sort&quot;
<em></em>
func permuteUnique(nums []int) (ans [][]int) {
	sort.Ints(nums)
	n := len(nums)
	perm := []int{}
	vis := make([]bool, n)
	var backtrack func(int)
	backtrack = func(idx int) {
		if idx == n {
			ans = append(ans, append([]int(nil), perm...))
			return
		}
		for i, v := range nums {
			if vis[i] || i &gt; 0 &amp;&amp; !vis[i-1] &amp;&amp; v == nums[i-1] {
				continue
			}
			perm = append(perm, v)
			vis[i] = true
			backtrack(idx + 1)
			vis[i] = false
			perm = perm[:len(perm)-1]
		}
	}
	backtrack(0)
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-23", "code-example-tab-23-cpp")})()</script>
<h2 id="85"><a class="header" href="#85">85</a></h2>
<p><code>剑指 Offer II 085. 生成匹配的括号</code></p>
<p>正整数 n 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<div><select onchange="changeCodeExample('code-example-tab-24', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-24-cpp">cpp</option><option value="code-example-tab-24-go">go</option></select></div>
<div id="code-example-tab-24-cpp" class="code-example-tab-24"><pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
vector&lt;string&gt; generateParenthesis(int n) {
  vector&lt;vector&lt;string&gt;&gt; dp(n + 1);
  dp[0] = {&quot;&quot;};
  for (int i = 1; i &lt;= n; ++i) {
    for (int j = 0; j &lt; i; ++j) {
      for (const string &amp;left : dp[j]) {
        for (const string &amp;right : dp[i - j - 1]) {
          dp[i].push_back(&quot;(&quot; + left + &quot;)&quot; + right);
        }
      }
    }
  }
  return dp[n];
}
<em></em>
void dfs(int n, int leftCnt, int rightCnt, string &amp;tmp, vector&lt;string&gt; &amp;res) {
  if (tmp.size() == n * 2) {
    res.push_back(tmp);
    return;
  }
  if (leftCnt &lt; n) {
    tmp.push_back(&#39;(&#39;);
    dfs(n, leftCnt + 1, rightCnt, tmp, res);
    tmp.pop_back();
  }
  if (leftCnt &gt; rightCnt) {
    tmp.push_back(&#39;)&#39;);
    dfs(n, leftCnt, rightCnt + 1, tmp, res);
    tmp.pop_back();
  }
}
<em></em>
vector&lt;string&gt; generateParenthesisDFS(int n) {
  vector&lt;string&gt; res;
  string tmp;
  dfs(n, 0, 0, tmp, res);
  return res;
}
</code></pre></div><div id="code-example-tab-24-go" class="code-example-tab-24"><pre><code class="language-go">package main
<em></em>
// 动态规划版本
func generateParenthesisDP(n int) []string {
	dp := make([][]string, n+1)
	dp[0] = []string{&quot;&quot;}
	for i := 1; i &lt;= n; i++ {
		for j := 0; j &lt; i; j++ {
			for _, left := range dp[j] {
				for _, right := range dp[i-j-1] {
					dp[i] = append(dp[i], &quot;(&quot;+left+&quot;)&quot;+right)
				}
			}
<em></em>
		}
	}
	return dp[n]
}
<em></em>
// 递归版本
func generateParenthesisDFS(n int) []string {
	var res []string
	var leftCnt, rightCnt int
	var tmp []byte
	var dfs func(cnt int)
	dfs = func(cnt int) {
		if cnt == n*2 {
			res = append(res, string(tmp))
			return
		}
		if leftCnt &lt; n {
			leftCnt++
			tmp = append(tmp, &#39;(&#39;)
			dfs(cnt + 1)
			leftCnt--
			tmp = tmp[:len(tmp)-1]
		}
		if leftCnt &gt; rightCnt {
			rightCnt++
			tmp = append(tmp, &#39;)&#39;)
			dfs(cnt + 1)
			rightCnt--
			tmp = tmp[:len(tmp)-1]
		}
	}
	dfs(0)
	return res
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-24", "code-example-tab-24-cpp")})()</script>
<h2 id="86"><a class="header" href="#86">86</a></h2>
<p><code>剑指 Offer II 086. 分割回文子字符串</code></p>
<p>将字符串分割成回文串, 返回所有可能的方案</p>
<div><select onchange="changeCodeExample('code-example-tab-25', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-25-cpp">cpp</option><option value="code-example-tab-25-go">go</option></select></div>
<div id="code-example-tab-25-cpp" class="code-example-tab-25"><pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
vector&lt;vector&lt;string&gt;&gt; partition(string s) {
  int n = s.size();
  vector&lt;vector&lt;bool&gt;&gt; f(n, vector&lt;bool&gt;(n, true));
  for (int i = n - 1; i &gt;= 0; --i) {
    for (int j = i + 1; j &lt; n; ++j) {
      f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + 1][j - 1];
    }
  }
<em></em>
  vector&lt;vector&lt;string&gt;&gt; ans;
  vector&lt;string&gt; splits;
  function&lt;void(int)&gt; dfs = [&amp;](int i) {
    if (i == n) {
      ans.push_back(splits);
      return;
    }
    for (int j = i; j &lt; n; ++j) {
      if (f[i][j]) {
        splits.push_back(s.substr(i, j - i + 1));
        dfs(j + 1);
        splits.pop_back();
      }
    };
  };
  dfs(0);
  return ans;
}
</code></pre></div><div id="code-example-tab-25-go" class="code-example-tab-25"><pre><code class="language-go">package main
<em></em>
func palindrome_partition(s string) (ans [][]string) {
	n := len(s)
	f := make([][]bool, n)
	for i := range f {
		f[i] = make([]bool, n)
		for j := range f[i] {
			f[i][j] = true
		}
	}
	for i := n - 1; i &gt;= 0; i-- {
		for j := i + 1; j &lt; n; j++ {
			f[i][j] = s[i] == s[j] &amp;&amp; f[i+1][j-1]
		}
	}
<em></em>
	splits := []string{}
	var dfs func(int)
	dfs = func(i int) {
		if i == n {
			ans = append(ans, append([]string(nil), splits...))
			return
		}
		for j := i; j &lt; n; j++ {
			if f[i][j] {
				splits = append(splits, s[i:j+1])
				dfs(j + 1)
				splits = splits[:len(splits)-1]
			}
		}
	}
	dfs(0)
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-25", "code-example-tab-25-cpp")})()</script>
<h2 id="87"><a class="header" href="#87">87</a></h2>
<p><code>剑指 Offer II 087. 复原 IP</code></p>
<p>将字符串格式化成所有合法的ipv4地址</p>
<div><select onchange="changeCodeExample('code-example-tab-26', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-26-cpp">cpp</option><option value="code-example-tab-26-go">go</option></select></div>
<div id="code-example-tab-26-cpp" class="code-example-tab-26"><pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
const int SEG_COUNT = 4;
<em></em>
vector&lt;string&gt; ans;
vector&lt;int&gt; segments(SEG_COUNT);
<em></em>
void dfs(const string &amp;s, int segId, int segStart) {
  // If we have found 4 segments and traversed the entire string, it&#39;s a valid
  // IP address
  if (segId == SEG_COUNT) {
    if (segStart == s.size()) {
      string ipAddr;
      for (int i = 0; i &lt; SEG_COUNT; ++i) {
        ipAddr += to_string(segments[i]);
        if (i != SEG_COUNT - 1) {
          ipAddr += &quot;.&quot;;
        }
      }
      ans.push_back(ipAddr);
    }
    return;
  }
<em></em>
  // If we haven&#39;t found 4 segments but traversed the entire string, backtrack
  if (segStart == s.size()) {
    return;
  }
<em></em>
  // If the current number is 0, this segment can only be 0
  if (s[segStart] == &#39;0&#39;) {
    segments[segId] = 0;
    dfs(s, segId + 1, segStart + 1);
    return;
  }
<em></em>
  // General case: enumerate each possibility and recurse
  int addr = 0;
  for (int segEnd = segStart; segEnd &lt; s.size(); ++segEnd) {
    addr = addr * 10 + (s[segEnd] - &#39;0&#39;);
    if (addr &gt; 0 &amp;&amp; addr &lt;= 255) {
      segments[segId] = addr;
      dfs(s, segId + 1, segEnd + 1);
    } else {
      break;
    }
  }
}
<em></em>
vector&lt;string&gt; restoreIpAddresses(string s) {
  ans.clear();
  segments = vector&lt;int&gt;(SEG_COUNT);
  dfs(s, 0, 0);
  return ans;
}
</code></pre></div><div id="code-example-tab-26-go" class="code-example-tab-26"><pre><code class="language-go">package main
<em></em>
import &quot;strconv&quot;
<em></em>
const SEG_COUNT = 4
<em></em>
var (
	ans      []string
	segments []int
)
<em></em>
func restoreIpAddresses(s string) []string {
	segments = make([]int, SEG_COUNT)
	ans = []string{}
	dfs(s, 0, 0)
	return ans
}
<em></em>
func dfs(s string, segId, segStart int) {
	// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
	if segId == SEG_COUNT {
		if segStart == len(s) {
			ipAddr := &quot;&quot;
			for i := 0; i &lt; SEG_COUNT; i++ {
				ipAddr += strconv.Itoa(segments[i])
				if i != SEG_COUNT-1 {
					ipAddr += &quot;.&quot;
				}
			}
			ans = append(ans, ipAddr)
		}
		return
	}
<em></em>
	// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
	if segStart == len(s) {
		return
	}
	// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
	if s[segStart] == &#39;0&#39; {
		segments[segId] = 0
		dfs(s, segId+1, segStart+1)
	}
	// 一般情况，枚举每一种可能性并递归
	addr := 0
	for segEnd := segStart; segEnd &lt; len(s); segEnd++ {
		addr = addr*10 + int(s[segEnd]-&#39;0&#39;)
		if addr &gt; 0 &amp;&amp; addr &lt;= 0xFF {
			segments[segId] = addr
			dfs(s, segId+1, segEnd+1)
		} else {
			break
		}
	}
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-26", "code-example-tab-26-cpp")})()</script>
<h2 id="88"><a class="header" href="#88">88</a></h2>
<p><code>剑指 Offer II 088. 爬楼梯的最少成本</code></p>
<p>给定一个一维数组表示爬楼梯需要的成本，并且每次支付一次就可以往上爬一个阶梯或者爬两个阶梯, 计算爬楼梯的最少成本。</p>
<div><select onchange="changeCodeExample('code-example-tab-27', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-27-cpp">cpp</option><option value="code-example-tab-27-go">go</option></select></div>
<div id="code-example-tab-27-cpp" class="code-example-tab-27"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
int minCostClimbingStairs(vector&lt;int&gt; &amp;cost) {
  int n = cost.size();
  int pre = 0, cur = 0;
  for (int i = 2; i &lt;= n; ++i) {
    int newCur = min(cur + cost[i - 1], pre + cost[i - 2]);
    pre = cur;
    cur = newCur;
  }
  return cur;
}
</code></pre></div><div id="code-example-tab-27-go" class="code-example-tab-27"><pre><code class="language-go">package main
<em></em>
func minCostClimbingStairs(cost []int) int {
	n := len(cost)
	pre, cur := 0, 0
	for i := 2; i &lt;= n; i++ {
		pre, cur = cur, min(cur+cost[i-1], pre+cost[i-2])
	}
	return cur
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-27", "code-example-tab-27-cpp")})()</script>
<h2 id="89"><a class="header" href="#89">89</a></h2>
<p><code>剑指 Offer II 089. 房屋偷盗</code></p>
<p>给定一个一维数组表示每间房子的价值，不能偷相邻的两家，问能够偷窃到的最高金额</p>
<div><select onchange="changeCodeExample('code-example-tab-28', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-28-cpp">cpp</option><option value="code-example-tab-28-go">go</option></select></div>
<div id="code-example-tab-28-cpp" class="code-example-tab-28"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
int rob(vector&lt;int&gt; &amp;nums) {
  if (nums.empty()) {
    return 0;
  }
  if (nums.size() == 1) {
    return nums[0];
  }
  vector&lt;int&gt; dp(nums.size());
  dp[0] = nums[0];
  dp[1] = max(nums[0], nums[1]);
  for (int i = 2; i &lt; nums.size(); ++i) {
    dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
  }
  return dp.back();
}
<em></em>
int max(int x, int y) { return (x &gt; y) ? x : y; }
</code></pre></div><div id="code-example-tab-28-go" class="code-example-tab-28"><pre><code class="language-go">package main
<em></em>
func rob(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	if len(nums) == 1 {
		return nums[0]
	}
	dp := make([]int, len(nums))
	dp[0] = nums[0]
	dp[1] = max(nums[0], nums[1])
	for i := 2; i &lt; len(nums); i++ {
		dp[i] = max(dp[i-2]+nums[i], dp[i-1])
	}
	return dp[len(nums)-1]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-28", "code-example-tab-28-cpp")})()</script>
<h2 id="90"><a class="header" href="#90">90</a></h2>
<p><code>剑指 Offer II 090. 环形房屋偷盗</code></p>
<p>与上一题类似，不过这一题房屋是首位相连的，问能够偷窃到的最大价值</p>
<div><select onchange="changeCodeExample('code-example-tab-29', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-29-cpp">cpp</option><option value="code-example-tab-29-go">go</option></select></div>
<div id="code-example-tab-29-cpp" class="code-example-tab-29"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;vector&gt;
<em></em>
using namespace std;
<em></em>
int _rob(const vector&lt;int&gt; &amp;nums) {
  int first = nums[0], second = max(nums[0], nums[1]);
  for (int i = 2; i &lt; nums.size(); ++i) {
    int v = nums[i];
    int newSecond = max(first + v, second);
    first = second;
    second = newSecond;
  }
  return second;
}
<em></em>
int rob(vector&lt;int&gt; &amp;nums) {
  int n = nums.size();
  if (n == 1) {
    return nums[0];
  }
  if (n == 2) {
    return max(nums[0], nums[1]);
  }
  vector&lt;int&gt; nums1(nums.begin(), nums.end() - 1);
  vector&lt;int&gt; nums2(nums.begin() + 1, nums.end());
  return max(_rob(nums1), _rob(nums2));
}
<em></em>
int max(int a, int b) { return (a &gt; b) ? a : b; }
</code></pre></div><div id="code-example-tab-29-go" class="code-example-tab-29"><pre><code class="language-go">package main
<em></em>
func _rob(nums []int) int {
	first, second := nums[0], max(nums[0], nums[1])
	for _, v := range nums[2:] {
		first, second = second, max(first+v, second)
	}
	return second
}
<em></em>
func robCircle(nums []int) int {
	n := len(nums)
	if n == 1 {
		return nums[0]
	}
	if n == 2 {
		return max(nums[0], nums[1])
	}
	return max(_rob(nums[:n-1]), _rob(nums[1:]))
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-29", "code-example-tab-29-cpp")})()</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="../../数据结构与算法/题库/剑指offer2.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next prefetch" href="../../数据结构与算法/题库/剑指offer4.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="../../数据结构与算法/题库/剑指offer2.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next prefetch" href="../../数据结构与算法/题库/剑指offer4.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././theme/style.js"></script>
        <script src="../../clarity.js"></script>
        <script src="../.././theme/highlight.js"></script>


    </div>
</body>

</html>