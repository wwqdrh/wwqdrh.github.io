<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>剑指offer4</title>


    <!-- Custom HTML head -->
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

    <link rel="icon" href="../../favicon.svg">
    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../.././theme/style.css">
    <link rel="stylesheet" href="../.././theme/mdbook-admonish.css">

</head>

<body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">面试指南</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/index.html"><strong aria-hidden="true">1.</strong> 数据结构与算法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/index.html"><strong aria-hidden="true">1.1.</strong> 题库</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer1.html"><strong aria-hidden="true">1.1.1.</strong> 剑指offer1</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer2.html"><strong aria-hidden="true">1.1.2.</strong> 剑指offer2</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer3.html"><strong aria-hidden="true">1.1.3.</strong> 剑指offer3</a></li><li class="chapter-item expanded "><a href="../../数据结构与算法/题库/剑指offer4.html" class="active"><strong aria-hidden="true">1.1.4.</strong> 剑指offer4</a></li></ol></li><li class="chapter-item expanded "><a href="../../数据结构与算法/短链系统设计.html"><strong aria-hidden="true">1.2.</strong> 短链系统设计</a></li></ol></li><li class="chapter-item expanded "><a href="../../c++/index.html"><strong aria-hidden="true">2.</strong> c++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../c++/c++标准.html"><strong aria-hidden="true">2.1.</strong> c++标准</a></li><li class="chapter-item expanded "><a href="../../c++/面向对象.html"><strong aria-hidden="true">2.2.</strong> 面向对象</a></li><li class="chapter-item expanded "><a href="../../c++/lambda表达式.html"><strong aria-hidden="true">2.3.</strong> lambda表达式</a></li><li class="chapter-item expanded "><a href="../../c++/常用库函数.html"><strong aria-hidden="true">2.4.</strong> 常用库函数</a></li><li class="chapter-item expanded "><a href="../../c++/模板编程.html"><strong aria-hidden="true">2.5.</strong> 模板编程</a></li><li class="chapter-item expanded "><a href="../../c++/移动语义.html"><strong aria-hidden="true">2.6.</strong> 移动语义</a></li><li class="chapter-item expanded "><a href="../../c++/引用变量.html"><strong aria-hidden="true">2.7.</strong> 引用变量</a></li><li class="chapter-item expanded "><a href="../../c++/编译期优化.html"><strong aria-hidden="true">2.8.</strong> 编译期优化</a></li><li class="chapter-item expanded "><a href="../../c++/什么是虚函数.html"><strong aria-hidden="true">2.9.</strong> 什么是虚函数</a></li><li class="chapter-item expanded "><a href="../../c++/指针.html"><strong aria-hidden="true">2.10.</strong> 指针</a></li><li class="chapter-item expanded "><a href="../../c++/如何保证并发安全.html"><strong aria-hidden="true">2.11.</strong> 如何保证并发安全</a></li><li class="chapter-item expanded "><a href="../../c++/常见对象的内存结构.html"><strong aria-hidden="true">2.12.</strong> 常见对象的内存结构</a></li><li class="chapter-item expanded "><a href="../../c++/数据类型.html"><strong aria-hidden="true">2.13.</strong> 数据类型</a></li><li class="chapter-item expanded "><a href="../../c++/内存模型.html"><strong aria-hidden="true">2.14.</strong> 内存模型</a></li></ol></li><li class="chapter-item expanded "><a href="../../linux操作系统/index.html"><strong aria-hidden="true">3.</strong> linux操作系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../linux操作系统/cpu资源.html"><strong aria-hidden="true">3.1.</strong> cpu资源</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/内存资源.html"><strong aria-hidden="true">3.2.</strong> 内存资源</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/磁盘资源.html"><strong aria-hidden="true">3.3.</strong> 磁盘资源</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/进程结构与调度.html"><strong aria-hidden="true">3.4.</strong> 进程结构与调度</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/内存管理.html"><strong aria-hidden="true">3.5.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/资源管理.html"><strong aria-hidden="true">3.6.</strong> 资源管理</a></li><li class="chapter-item expanded "><a href="../../linux操作系统/网络配置.html"><strong aria-hidden="true">3.7.</strong> 网络配置</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function (e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                            title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                            aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="https://space.bilibili.com/538676331" target="_blank" title="B站" aria-label="B站">
                            B站
                        </a>
                        <a href="/" target="_blank" title="home" aria-label="Git repository">
                            <i id="git-home" class="fa fa-home"></i>
                        </a>
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/wwqdrh/interview-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <script>
const changeCodeExample = (tabClass, to) => {
    // console.debug(to);
    const tabs = document.getElementsByClassName(tabClass);
    for (let i = 0; i < tabs.length; i++) {
        tabs[i].style.display = "none";
    }

    const theTab = document.getElementById(to);
    theTab.style.display = "block";
}
</script>
<style>
    select.code-example {
        color: var(--fg);
        background-color: var(--bg);
        border: 1px solid;
        border-color: var(--fg);
        padding: 2px 10px 2px 10px;
        border-radius: 5px;
    }
</style>
<h2 id="91"><a class="header" href="#91">91</a></h2>
<p><code>剑指 Offer II 091. 粉刷房子</code></p>
<p>一排房子n个，可以涂成红色、蓝色、绿色这三种颜色中的一种，需要让各个颜色并不相同</p>
<p>给定一个花费数组，其中的每个元素就是该房子涂成红、蓝、绿三种颜色所需要的花费</p>
<p>计算粉刷完所有房子最少的花费成本</p>
<div><select onchange="changeCodeExample('code-example-tab-0', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-0-cpp">cpp</option><option value="code-example-tab-0-go">go</option></select></div>
<div id="code-example-tab-0-cpp" class="code-example-tab-0"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int minCost(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;costs) {
  std::vector&lt;int&gt; dp = costs[0];
  for (size_t i = 1; i &lt; costs.size(); ++i) {
    std::vector&lt;int&gt; dpNew(3);
    for (int j = 0; j &lt; 3; ++j) {
      dpNew[j] = std::min(dp[(j + 1) % 3], dp[(j + 2) % 3]) + costs[i][j];
    }
    dp = dpNew;
  }
  return std::min({dp[0], dp[1], dp[2]});
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; costs = {{17, 2, 17}, {16, 16, 5}, {14, 3, 19}};
  std::cout &lt;&lt; &quot;Minimum cost: &quot; &lt;&lt; minCost(costs) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-0-go" class="code-example-tab-0"><pre><code class="language-go">package main
<em></em>
func minCost(costs [][]int) int {
	dp := costs[0]
	for _, cost := range costs[1:] {
		dpNew := make([]int, 3)
		for j, c := range cost {
			dpNew[j] = min(dp[(j+1)%3], dp[(j+2)%3]) + c
		}
		dp = dpNew
	}
	return min(min(dp[0], dp[1]), dp[2])
}
<em></em>
func min(a, b int) int {
	if a &gt; b {
		return b
	}
	return a
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-0", "code-example-tab-0-cpp")})()</script>
<h2 id="92"><a class="header" href="#92">92</a></h2>
<p><code>剑指 Offer II 092. 翻转字符</code></p>
<p>一个<code>0 1</code>组成的字符串，求使得s单调递增(前面全是0 后面全是1)的最小翻转次数</p>
<div><select onchange="changeCodeExample('code-example-tab-1', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-1-cpp">cpp</option><option value="code-example-tab-1-go">go</option></select></div>
<div id="code-example-tab-1-cpp" class="code-example-tab-1"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
<em></em>
int min(int a, int b) { return (a &lt; b) ? a : b; }
<em></em>
int minFlipsMonoIncr(const std::string &amp;s) {
  int dp0 = 0, dp1 = 0;
  for (char c : s) {
    int dp0New = dp0, dp1New = std::min(dp0, dp1);
    if (c == &#39;1&#39;) {
      dp0New++;
    } else {
      dp1New++;
    }
    dp0 = dp0New;
    dp1 = dp1New;
  }
  return std::min(dp0, dp1);
}
<em></em>
int main() {
  std::string s = &quot;00110&quot;;
  std::cout &lt;&lt; &quot;Minimum flips: &quot; &lt;&lt; minFlipsMonoIncr(s) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-1-go" class="code-example-tab-1"><pre><code class="language-go">package main
<em></em>
func minFlipsMonoIncr(s string) int {
	dp0, dp1 := 0, 0
	for _, c := range s {
		dp0New, dp1New := dp0, min(dp0, dp1)
		if c == &#39;1&#39; {
			dp0New++
		} else {
			dp1New++
		}
		dp0, dp1 = dp0New, dp1New
	}
	return min(dp0, dp1)
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-1", "code-example-tab-1-cpp")})()</script>
<h2 id="93"><a class="header" href="#93">93</a></h2>
<p><code>剑指 Offer II 093. 最长斐波那契数列</code></p>
<p>给定一个递增的正整数数组，找到其中最长的一个满足斐波那契数列的元素</p>
<div><select onchange="changeCodeExample('code-example-tab-2', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-2-cpp">cpp</option><option value="code-example-tab-2-go">go</option></select></div>
<div id="code-example-tab-2-cpp" class="code-example-tab-2"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
int max(int a, int b) { return (a &gt; b) ? a : b; }
<em></em>
int lenLongestFibSubseq(const std::vector&lt;int&gt; &amp;arr) {
  int n = arr.size();
  std::unordered_map&lt;int, int&gt; indices;
  for (int i = 0; i &lt; n; ++i) {
    indices[arr[i]] = i;
  }
  std::vector&lt;std::vector&lt;int&gt;&gt; dp(n, std::vector&lt;int&gt;(n, 0));
  int ans = 0;
  for (int i = 0; i &lt; n; ++i) {
    for (int j = n - 1; j &gt;= 0 &amp;&amp; arr[j] * 2 &gt; arr[i]; --j) {
      auto it = indices.find(arr[i] - arr[j]);
      if (it != indices.end()) {
        int k = it-&gt;second;
        dp[j][i] = max(dp[k][j] + 1, 3);
        ans = max(ans, dp[j][i]);
      }
    }
  }
  return ans;
}
<em></em>
int main() {
  std::vector&lt;int&gt; arr = {1, 3, 7, 11, 12, 14, 18};
  std::cout &lt;&lt; &quot;Length of longest Fibonacci-like subsequence: &quot;
            &lt;&lt; lenLongestFibSubseq(arr) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-2-go" class="code-example-tab-2"><pre><code class="language-go">package main
<em></em>
func lenLongestFibSubseq(arr []int) (ans int) {
	n := len(arr)
	indices := make(map[int]int, n)
	for i, x := range arr {
		indices[x] = i
	}
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, n)
	}
	for i, x := range arr {
		for j := n - 1; j &gt;= 0 &amp;&amp; arr[j]*2 &gt; x; j-- {
			if k, ok := indices[x-arr[j]]; ok {
				dp[j][i] = max(dp[k][j]+1, 3)
				ans = max(ans, dp[j][i])
			}
		}
	}
	return
}
<em></em>
func max(a, b int) int {
	if b &gt; a {
		return b
	}
	return a
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-2", "code-example-tab-2-cpp")})()</script>
<h2 id="94"><a class="header" href="#94">94</a></h2>
<p><code>剑指 Offer II 094. 最少回文分割</code></p>
<p>给定一个字符串s，找到分割的最小次数，将s分割成字串，且每个字串都是回文串，</p>
<div><select onchange="changeCodeExample('code-example-tab-3', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-3-cpp">cpp</option><option value="code-example-tab-3-go">go</option></select></div>
<div id="code-example-tab-3-cpp" class="code-example-tab-3"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
int minCut(const std::string &amp;s) {
  int n = s.size();
  std::vector&lt;std::vector&lt;bool&gt;&gt; g(n, std::vector&lt;bool&gt;(n, true));
  for (int i = n - 1; i &gt;= 0; --i) {
    for (int j = i + 1; j &lt; n; ++j) {
      g[i][j] = (s[i] == s[j]) &amp;&amp; g[i + 1][j - 1];
    }
  }
<em></em>
  std::vector&lt;int&gt; f(n, INT_MAX);
  for (int i = 0; i &lt; n; ++i) {
    if (g[0][i]) {
      f[i] = 0;
    } else {
      for (int j = 0; j &lt; i; ++j) {
        if (g[j + 1][i]) {
          f[i] = std::min(f[i], f[j] + 1);
        }
      }
    }
  }
  return f[n - 1];
}
<em></em>
int main() {
  std::string s = &quot;aab&quot;;
  std::cout &lt;&lt; &quot;Minimum cuts needed for a palindrome partitioning: &quot;
            &lt;&lt; minCut(s) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-3-go" class="code-example-tab-3"><pre><code class="language-go">package main
<em></em>
import &quot;math&quot;
<em></em>
func minCut(s string) int {
	n := len(s)
	g := make([][]bool, n)
	for i := range g {
		g[i] = make([]bool, n)
		for j := range g[i] {
			g[i][j] = true
		}
	}
	for i := n - 1; i &gt;= 0; i-- {
		for j := i + 1; j &lt; n; j++ {
			g[i][j] = s[i] == s[j] &amp;&amp; g[i+1][j-1]
		}
	}
<em></em>
	f := make([]int, n)
	for i := range f {
		if g[0][i] {
			continue
		}
		f[i] = math.MaxInt64
		for j := 0; j &lt; i; j++ {
			if g[j+1][i] &amp;&amp; f[j]+1 &lt; f[i] {
				f[i] = f[j] + 1
			}
		}
	}
	return f[n-1]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-3", "code-example-tab-3-cpp")})()</script>
<h2 id="95"><a class="header" href="#95">95</a></h2>
<p><code>剑指 Offer II 095. 最长公共子序列</code></p>
<p>找到两个字符串的最长的公共子序列(即满足不改变字符的相对顺序的情况下删除某些字符)</p>
<div><select onchange="changeCodeExample('code-example-tab-4', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-4-cpp">cpp</option><option value="code-example-tab-4-go">go</option></select></div>
<div id="code-example-tab-4-cpp" class="code-example-tab-4"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
int max(int a, int b) { return (a &gt; b) ? a : b; }
<em></em>
int longestCommonSubsequence(const std::string &amp;text1,
                             const std::string &amp;text2) {
  int m = text1.size(), n = text2.size();
  std::vector&lt;std::vector&lt;int&gt;&gt; dp(m + 1, std::vector&lt;int&gt;(n + 1, 0));
<em></em>
  for (int i = 0; i &lt; m; ++i) {
    for (int j = 0; j &lt; n; ++j) {
      if (text1[i] == text2[j]) {
        dp[i + 1][j + 1] = dp[i][j] + 1;
      } else {
        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
      }
    }
  }
  return dp[m][n];
}
<em></em>
int main() {
  std::string text1 = &quot;abcde&quot;;
  std::string text2 = &quot;ace&quot;;
  std::cout &lt;&lt; &quot;Length of longest common subsequence: &quot;
            &lt;&lt; longestCommonSubsequence(text1, text2) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-4-go" class="code-example-tab-4"><pre><code class="language-go">package main
<em></em>
func longestCommonSubsequence(text1, text2 string) int {
	m, n := len(text1), len(text2)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}
	for i, c1 := range text1 {
		for j, c2 := range text2 {
			if c1 == c2 {
				dp[i+1][j+1] = dp[i][j] + 1
			} else {
				dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
			}
		}
	}
	return dp[m][n]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-4", "code-example-tab-4-cpp")})()</script>
<h2 id="96"><a class="header" href="#96">96</a></h2>
<p><code>剑指 Offer II 096. 字符串交织</code></p>
<p>判断两个字符串s1 s2交织(轮流选择元素)后是否与s3相等</p>
<div><select onchange="changeCodeExample('code-example-tab-5', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-5-cpp">cpp</option><option value="code-example-tab-5-go">go</option></select></div>
<div id="code-example-tab-5-cpp" class="code-example-tab-5"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
bool isInterleave(const std::string &amp;s1, const std::string &amp;s2,
                  const std::string &amp;s3) {
  int n = s1.size(), m = s2.size(), t = s3.size();
  if (n + m != t) {
    return false;
  }
  std::vector&lt;bool&gt; f(m + 1, false);
  f[0] = true;
  for (int i = 0; i &lt;= n; ++i) {
    for (int j = 0; j &lt;= m; ++j) {
      int p = i + j - 1;
      if (i &gt; 0) {
        f[j] = f[j] &amp;&amp; s1[i - 1] == s3[p];
      }
      if (j &gt; 0) {
        f[j] = f[j] || (f[j - 1] &amp;&amp; s2[j - 1] == s3[p]);
      }
    }
  }
  return f[m];
}
<em></em>
int main() {
  std::string s1 = &quot;aabcc&quot;;
  std::string s2 = &quot;dbbca&quot;;
  std::string s3 = &quot;aadbbcbcac&quot;;
  std::cout &lt;&lt; &quot;Is interleaving: &quot;
            &lt;&lt; (isInterleave(s1, s2, s3) ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-5-go" class="code-example-tab-5"><pre><code class="language-go">package main
<em></em>
func isInterleave(s1 string, s2 string, s3 string) bool {
	n, m, t := len(s1), len(s2), len(s3)
	if (n + m) != t {
		return false
	}
	f := make([]bool, m+1)
	f[0] = true
	for i := 0; i &lt;= n; i++ {
		for j := 0; j &lt;= m; j++ {
			p := i + j - 1
			if i &gt; 0 {
				f[j] = f[j] &amp;&amp; s1[i-1] == s3[p]
			}
			if j &gt; 0 {
				f[j] = f[j] || f[j-1] &amp;&amp; s2[j-1] == s3[p]
			}
		}
	}
	return f[m]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-5", "code-example-tab-5-cpp")})()</script>
<h2 id="97"><a class="header" href="#97">97</a></h2>
<p><code>剑指 Offer II 097. 子序列的数目</code></p>
<p>判断字符串s中有多少个子序列是在t中出现了</p>
<div><select onchange="changeCodeExample('code-example-tab-6', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-6-cpp">cpp</option><option value="code-example-tab-6-go">go</option></select></div>
<div id="code-example-tab-6-cpp" class="code-example-tab-6"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
int numDistinct(const std::string &amp;s, const std::string &amp;t) {
  int m = s.size(), n = t.size();
  if (m &lt; n) {
    return 0;
  }
  std::vector&lt;std::vector&lt;int&gt;&gt; dp(m + 1, std::vector&lt;int&gt;(n + 1, 0));
  for (int i = 0; i &lt;= m; ++i) {
    dp[i][n] = 1;
  }
  for (int i = m - 1; i &gt;= 0; --i) {
    for (int j = n - 1; j &gt;= 0; --j) {
      if (s[i] == t[j]) {
        dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
      } else {
        dp[i][j] = dp[i + 1][j];
      }
    }
  }
  return dp[0][0];
}
<em></em>
int main() {
  std::string s = &quot;rabbbit&quot;;
  std::string t = &quot;rabbit&quot;;
  std::cout &lt;&lt; &quot;Number of distinct subsequences: &quot; &lt;&lt; numDistinct(s, t)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-6-go" class="code-example-tab-6"><pre><code class="language-go">package main
<em></em>
func numDistinct(s, t string) int {
	m, n := len(s), len(t)
	if m &lt; n {
		return 0
	}
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
		dp[i][n] = 1
	}
	for i := m - 1; i &gt;= 0; i-- {
		for j := n - 1; j &gt;= 0; j-- {
			if s[i] == t[j] {
				dp[i][j] = dp[i+1][j+1] + dp[i+1][j]
			} else {
				dp[i][j] = dp[i+1][j]
			}
		}
	}
	return dp[0][0]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-6", "code-example-tab-6-cpp")})()</script>
<h2 id="98"><a class="header" href="#98">98</a></h2>
<p><code>剑指 Offer II 098. 路径的数目</code></p>
<p>一个<code>m*n</code>的网格，从左上到右下，只能向下或者向右移动一步，问总共有多少条不同的路径。</p>
<div><select onchange="changeCodeExample('code-example-tab-7', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-7-cpp">cpp</option><option value="code-example-tab-7-go">go</option></select></div>
<div id="code-example-tab-7-cpp" class="code-example-tab-7"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int uniquePaths(int m, int n) {
  std::vector&lt;std::vector&lt;int&gt;&gt; dp(m, std::vector&lt;int&gt;(n, 0));
  for (int i = 0; i &lt; m; ++i) {
    dp[i][0] = 1;
  }
  for (int j = 0; j &lt; n; ++j) {
    dp[0][j] = 1;
  }
  for (int i = 1; i &lt; m; ++i) {
    for (int j = 1; j &lt; n; ++j) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }
  return dp[m - 1][n - 1];
}
<em></em>
int main() {
  int m = 3, n = 7;
  std::cout &lt;&lt; &quot;Number of unique paths: &quot; &lt;&lt; uniquePaths(m, n) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-7-go" class="code-example-tab-7"><pre><code class="language-go">package main
<em></em>
func uniquePaths(m, n int) int {
	dp := make([][]int, m)
	for i := range dp {
		dp[i] = make([]int, n)
		dp[i][0] = 1
	}
	for j := 0; j &lt; n; j++ {
		dp[0][j] = 1
	}
	for i := 1; i &lt; m; i++ {
		for j := 1; j &lt; n; j++ {
			dp[i][j] = dp[i-1][j] + dp[i][j-1]
		}
	}
	return dp[m-1][n-1]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-7", "code-example-tab-7-cpp")})()</script>
<h2 id="99"><a class="header" href="#99">99</a></h2>
<p><code>剑指 Offer II 099. 最小路径之和</code></p>
<p>一个<code>m*n</code>的网格，从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>每次向下或者向右移动一步</p>
<div><select onchange="changeCodeExample('code-example-tab-8', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-8-cpp">cpp</option><option value="code-example-tab-8-go">go</option></select></div>
<div id="code-example-tab-8-cpp" class="code-example-tab-8"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int min(int x, int y) { return (x &lt; y) ? x : y; }
<em></em>
int minPathSum(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;grid) {
  if (grid.empty() || grid[0].empty()) {
    return 0;
  }
  int rows = grid.size(), columns = grid[0].size();
  std::vector&lt;std::vector&lt;int&gt;&gt; dp(rows, std::vector&lt;int&gt;(columns, 0));
  dp[0][0] = grid[0][0];
  for (int i = 1; i &lt; rows; ++i) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }
  for (int j = 1; j &lt; columns; ++j) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }
  for (int i = 1; i &lt; rows; ++i) {
    for (int j = 1; j &lt; columns; ++j) {
      dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  return dp[rows - 1][columns - 1];
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; grid = {{1, 3, 1}, {1, 5, 1}, {4, 2, 1}};
  std::cout &lt;&lt; &quot;Minimum path sum: &quot; &lt;&lt; minPathSum(grid) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-8-go" class="code-example-tab-8"><pre><code class="language-go">package main
<em></em>
func minPathSum(grid [][]int) int {
	if len(grid) == 0 || len(grid[0]) == 0 {
		return 0
	}
	rows, columns := len(grid), len(grid[0])
	dp := make([][]int, rows)
	for i := 0; i &lt; len(dp); i++ {
		dp[i] = make([]int, columns)
	}
	dp[0][0] = grid[0][0]
	for i := 1; i &lt; rows; i++ {
		dp[i][0] = dp[i-1][0] + grid[i][0]
	}
	for j := 1; j &lt; columns; j++ {
		dp[0][j] = dp[0][j-1] + grid[0][j]
	}
	for i := 1; i &lt; rows; i++ {
		for j := 1; j &lt; columns; j++ {
			dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
		}
	}
	return dp[rows-1][columns-1]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-8", "code-example-tab-8-cpp")})()</script>
<h2 id="100"><a class="header" href="#100">100</a></h2>
<p><code>剑指 Offer II 100. 三角形中最小路径之和</code></p>
<p>一个三角形的矩阵，从上往下找到最小路径之和</p>
<p>下标移动的时候只能移动到<code>i</code>以及<code>i+1</code></p>
<div><select onchange="changeCodeExample('code-example-tab-9', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-9-cpp">cpp</option><option value="code-example-tab-9-go">go</option></select></div>
<div id="code-example-tab-9-cpp" class="code-example-tab-9"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int min(int x, int y) { return (x &lt; y) ? x : y; }
<em></em>
int minimumTotal(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;triangle) {
  int n = triangle.size();
  std::vector&lt;std::vector&lt;int&gt;&gt; f(n, std::vector&lt;int&gt;(n, 0));
  f[0][0] = triangle[0][0];
  for (int i = 1; i &lt; n; ++i) {
    f[i][0] = f[i - 1][0] + triangle[i][0];
    for (int j = 1; j &lt; i; ++j) {
      f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];
    }
    f[i][i] = f[i - 1][i - 1] + triangle[i][i];
  }
  int ans = INT_MAX;
  for (int i = 0; i &lt; n; ++i) {
    ans = min(ans, f[n - 1][i]);
  }
  return ans;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; triangle = {
      {2}, {3, 4}, {6, 5, 7}, {4, 1, 8, 3}};
  std::cout &lt;&lt; &quot;Minimum total path sum: &quot; &lt;&lt; minimumTotal(triangle)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-9-go" class="code-example-tab-9"><pre><code class="language-go">package main
<em></em>
import &quot;math&quot;
<em></em>
func minimumTotal(triangle [][]int) int {
	n := len(triangle)
	f := make([][]int, n)
	for i := 0; i &lt; n; i++ {
		f[i] = make([]int, n)
	}
	f[0][0] = triangle[0][0]
	for i := 1; i &lt; n; i++ {
		f[i][0] = f[i-1][0] + triangle[i][0]
		for j := 1; j &lt; i; j++ {
			f[i][j] = min(f[i-1][j-1], f[i-1][j]) + triangle[i][j]
		}
		f[i][i] = f[i-1][i-1] + triangle[i][i]
	}
	ans := math.MaxInt32
	for i := 0; i &lt; n; i++ {
		ans = min(ans, f[n-1][i])
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-9", "code-example-tab-9-cpp")})()</script>
<h2 id="101"><a class="header" href="#101">101</a></h2>
<p><code>剑指 Offer II 101. 分割等和子集</code></p>
<p>给定一个非空的正整数数组 nums ，请判断能否将这些数字分成元素和相等的两部分。</p>
<div><select onchange="changeCodeExample('code-example-tab-10', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-10-cpp">cpp</option><option value="code-example-tab-10-go">go</option></select></div>
<div id="code-example-tab-10-cpp" class="code-example-tab-10"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
<em></em>
bool canPartition(std::vector&lt;int&gt; &amp;nums) {
  int n = nums.size();
  if (n &lt; 2) {
    return false;
  }
<em></em>
  int sum = std::accumulate(nums.begin(), nums.end(), 0);
  int maxNum = *std::max_element(nums.begin(), nums.end());
  if (sum % 2 != 0) {
    return false;
  }
<em></em>
  int target = sum / 2;
  if (maxNum &gt; target) {
    return false;
  }
<em></em>
  std::vector&lt;std::vector&lt;bool&gt;&gt; dp(n, std::vector&lt;bool&gt;(target + 1, false));
  for (int i = 0; i &lt; n; ++i) {
    dp[i][0] = true;
  }
  dp[0][nums[0]] = true;
  for (int i = 1; i &lt; n; ++i) {
    int v = nums[i];
    for (int j = 1; j &lt;= target; ++j) {
      if (j &gt;= v) {
        dp[i][j] = dp[i - 1][j] || dp[i - 1][j - v];
      } else {
        dp[i][j] = dp[i - 1][j];
      }
    }
  }
  return dp[n - 1][target];
}
<em></em>
int main() {
  std::vector&lt;int&gt; nums = {1, 5, 11, 5};
  std::cout &lt;&lt; &quot;Can partition: &quot; &lt;&lt; (canPartition(nums) ? &quot;true&quot; : &quot;false&quot;)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-10-go" class="code-example-tab-10"><pre><code class="language-go">package main
<em></em>
func canPartition(nums []int) bool {
	n := len(nums)
	if n &lt; 2 {
		return false
	}
<em></em>
	sum, max := 0, 0
	for _, v := range nums {
		sum += v
		if v &gt; max {
			max = v
		}
	}
	if sum%2 != 0 {
		return false
	}
<em></em>
	target := sum / 2
	if max &gt; target {
		return false
	}
<em></em>
	dp := make([][]bool, n)
	for i := range dp {
		dp[i] = make([]bool, target+1)
	}
	for i := 0; i &lt; n; i++ {
		dp[i][0] = true
	}
	dp[0][nums[0]] = true
	for i := 1; i &lt; n; i++ {
		v := nums[i]
		for j := 1; j &lt;= target; j++ {
			if j &gt;= v {
				dp[i][j] = dp[i-1][j] || dp[i-1][j-v]
			} else {
				dp[i][j] = dp[i-1][j]
			}
		}
	}
	return dp[n-1][target]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-10", "code-example-tab-10-cpp")})()</script>
<h2 id="102"><a class="header" href="#102">102</a></h2>
<p><code>剑指 Offer II 102. 加减的目标值</code></p>
<p>给定一个数组以及target值，提供正负符号使得数组中的和等于目标值</p>
<div><select onchange="changeCodeExample('code-example-tab-11', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-11-cpp">cpp</option><option value="code-example-tab-11-go">go</option></select></div>
<div id="code-example-tab-11-cpp" class="code-example-tab-11"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
void backtrack(const std::vector&lt;int&gt; &amp;nums, int target, int index, int sum,
               int &amp;count) {
  if (index == nums.size()) {
    if (sum == target) {
      count++;
    }
    return;
  }
  backtrack(nums, target, index + 1, sum + nums[index], count);
  backtrack(nums, target, index + 1, sum - nums[index], count);
}
<em></em>
int findTargetSumWays(const std::vector&lt;int&gt; &amp;nums, int target) {
  int count = 0;
  backtrack(nums, target, 0, 0, count);
  return count;
}
<em></em>
int main() {
  std::vector&lt;int&gt; nums = {1, 1, 1, 1, 1};
  int target = 3;
  std::cout &lt;&lt; &quot;Number of ways to reach target sum: &quot;
            &lt;&lt; findTargetSumWays(nums, target) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-11-go" class="code-example-tab-11"><pre><code class="language-go">package main
<em></em>
func findTargetSumWays(nums []int, target int) (count int) {
	var backtrack func(int, int)
	backtrack = func(index, sum int) {
		if index == len(nums) {
			if sum == target {
				count++
			}
			return
		}
		backtrack(index+1, sum+nums[index])
		backtrack(index+1, sum-nums[index])
	}
	backtrack(0, 0)
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-11", "code-example-tab-11-cpp")})()</script>
<h2 id="103"><a class="header" href="#103">103</a></h2>
<p>剑指 Offer II 103. 最少的硬币数目</p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>每种硬币的数量是无限的。</p>
<div><select onchange="changeCodeExample('code-example-tab-12', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-12-cpp">cpp</option><option value="code-example-tab-12-go">go</option></select></div>
<div id="code-example-tab-12-cpp" class="code-example-tab-12"><pre><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int min(int a, int b) { return (a &lt; b) ? a : b; }
<em></em>
int coinChange(const std::vector&lt;int&gt; &amp;nums, int target) {
  std::vector&lt;int&gt; dp(target + 1, INT_MAX);
  dp[0] = 0;
  for (int num : nums) {
    for (int i = 0; i &lt;= target - num; ++i) {
      if (dp[i] == INT_MAX) {
        continue;
      }
      dp[i + num] = min(dp[i + num], dp[i] + 1);
    }
  }
  return dp[target] == INT_MAX ? -1 : dp[target];
}
<em></em>
int main() {
  std::vector&lt;int&gt; nums = {1, 2, 5};
  int target = 11;
  std::cout &lt;&lt; &quot;Minimum coins needed: &quot; &lt;&lt; coinChange(nums, target)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-12-go" class="code-example-tab-12"><pre><code class="language-go">package main
<em></em>
import &quot;math&quot;
<em></em>
func coinChange(nums []int, target int) int {
	dp := make([]int, target+1)
	for i := 1; i &lt;= target; i++ {
		dp[i] = math.MaxInt32
	}
	for _, num := range nums {
		for i := 0; i &lt;= target-num; i++ {
			if dp[i] == math.MaxInt32 {
				continue
			}
			dp[i+num] = min(dp[i+num], dp[i]+1)
		}
	}
	if dp[target] == math.MaxInt32 {
		return -1
	}
	return dp[target]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-12", "code-example-tab-12-cpp")})()</script>
<h2 id="104"><a class="header" href="#104">104</a></h2>
<p>剑指 Offer II 104. 排列的数目</p>
<p>给定一个由 不同 正整数组成的数组 nums ，和一个目标整数 target 。请从 nums 中找出并返回总和为 target 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p>
<div><select onchange="changeCodeExample('code-example-tab-13', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-13-cpp">cpp</option><option value="code-example-tab-13-go">go</option></select></div>
<div id="code-example-tab-13-cpp" class="code-example-tab-13"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int combinationSum4(const std::vector&lt;int&gt; &amp;nums, int target) {
  std::vector&lt;int&gt; dp(target + 1, 0);
  dp[0] = 1;
  for (int i = 1; i &lt;= target; ++i) {
    for (int num : nums) {
      if (num &lt;= i) {
        dp[i] += dp[i - num];
      }
    }
  }
  return dp[target];
}
<em></em>
int main() {
  std::vector&lt;int&gt; nums = {1, 2, 3};
  int target = 4;
  std::cout &lt;&lt; &quot;Number of combinations: &quot; &lt;&lt; combinationSum4(nums, target)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-13-go" class="code-example-tab-13"><pre><code class="language-go">package main
<em></em>
func combinationSum4(nums []int, target int) int {
	dp := make([]int, target+1)
	dp[0] = 1
	for i := 1; i &lt;= target; i++ {
		for _, num := range nums {
			if num &lt;= i {
				dp[i] += dp[i-num]
			}
		}
	}
	return dp[target]
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-13", "code-example-tab-13-cpp")})()</script>
<h2 id="105"><a class="header" href="#105">105</a></h2>
<p><code>剑指 Offer II 105. 岛屿的最大面积</code></p>
<p>01二维矩阵，全1代表陆地，找到岛屿的最大面积</p>
<div><select onchange="changeCodeExample('code-example-tab-14', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-14-cpp">cpp</option><option value="code-example-tab-14-go">go</option></select></div>
<div id="code-example-tab-14-cpp" class="code-example-tab-14"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int getArea(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;grid,
            std::vector&lt;std::vector&lt;bool&gt;&gt; &amp;visited, int i, int j) {
  int m = grid.size(), n = grid[0].size();
  if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] == 0 || visited[i][j]) {
    return 0;
  }
  visited[i][j] = true;
  return getArea(grid, visited, i - 1, j) + getArea(grid, visited, i + 1, j) +
         getArea(grid, visited, i, j - 1) + getArea(grid, visited, i, j + 1) +
         1;
}
<em></em>
int maxAreaOfIsland(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;grid) {
  int m = grid.size(), n = grid[0].size();
  std::vector&lt;std::vector&lt;bool&gt;&gt; visited(m, std::vector&lt;bool&gt;(n, false));
  int ans = 0;
  for (int i = 0; i &lt; m; ++i) {
    for (int j = 0; j &lt; n; ++j) {
      int area = getArea(grid, visited, i, j);
      if (area &gt; ans) {
        ans = area;
      }
    }
  }
  return ans;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; grid = {
      {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
      {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},
      {0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}};
  std::cout &lt;&lt; &quot;Maximum area of island: &quot; &lt;&lt; maxAreaOfIsland(grid) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-14-go" class="code-example-tab-14"><pre><code class="language-go">package main
<em></em>
func maxAreaOfIsland(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	visited := make([][]bool, m)
	for i := 0; i &lt; m; i++ {
		visited[i] = make([]bool, n)
	}
	var getArea func(int, int) int
	getArea = func(i, j int) int {
		if i &lt; 0 || i == m || j &lt; 0 || j == n {
			return 0
		}
		if grid[i][j] == 0 || visited[i][j] {
			return 0
		}
		visited[i][j] = true
		return getArea(i-1, j) + getArea(i+1, j) + getArea(i, j-1) + getArea(i, j+1) + 1
	}
	ans := 0
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			area := getArea(i, j)
			if area &gt; ans {
				ans = area
			}
		}
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-14", "code-example-tab-14-cpp")})()</script>
<h2 id="106"><a class="header" href="#106">106</a></h2>
<p><code>剑指 Offer II 106. 二分图</code></p>
<p>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p>
<p>如果图是二分图，返回 true ；否则，返回 false 。</p>
<div><select onchange="changeCodeExample('code-example-tab-15', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-15-cpp">cpp</option><option value="code-example-tab-15-go">go</option></select></div>
<div id="code-example-tab-15-cpp" class="code-example-tab-15"><pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
const int UNCOLOR = 0, RED = 1, GREEN = 2;
<em></em>
bool isBipartite(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;graph) {
  int n = graph.size();
  std::vector&lt;int&gt; state(n, UNCOLOR);
  bool valid = true;
<em></em>
  std::function&lt;void(int, int)&gt; dfs = [&amp;](int idx, int color) -&gt; void {
    int necolor = (color == RED) ? GREEN : RED;
    state[idx] = color;
<em></em>
    for (int ne : graph[idx]) {
      if (state[ne] == UNCOLOR) {
        dfs(ne, necolor);
      } else {
        valid = (necolor == state[ne]);
      }
<em></em>
      if (!valid) {
        return;
      }
    }
  };
<em></em>
  for (int i = 0; i &lt; n &amp;&amp; valid; ++i) {
    if (state[i] == UNCOLOR) {
      dfs(i, RED);
    }
  }
  return valid;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; graph = {{1, 3}, {0, 2}, {1, 3}, {0, 2}};
  std::cout &lt;&lt; &quot;Is bipartite: &quot; &lt;&lt; (isBipartite(graph) ? &quot;true&quot; : &quot;false&quot;)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-15-go" class="code-example-tab-15"><pre><code class="language-go">package main
<em></em>
var (
	UNCOLOR, RED, GREEN = 0, 1, 2
)
<em></em>
func isBipartite(graph [][]int) bool {
	n := len(graph)
<em></em>
	state := make([]int, n)
	valid := true
<em></em>
	var dfs func(idx, color int)
	dfs = func(idx, color int) {
		necolor := RED
		if color == RED {
			necolor = GREEN
		}
		state[idx] = color
<em></em>
		for _, ne := range graph[idx] {
			if state[ne] == UNCOLOR {
				dfs(ne, necolor)
			} else {
				valid = necolor == state[ne]
			}
<em></em>
			if !valid {
				return
			}
		}
	}
<em></em>
	for i := 0; i &lt; n &amp;&amp; valid; i++ {
		if state[i] == UNCOLOR {
			dfs(i, RED)
		}
	}
	return valid
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-15", "code-example-tab-15-cpp")})()</script>
<h2 id="107"><a class="header" href="#107">107</a></h2>
<p><code>剑指 Offer II 107. 矩阵中的距离</code></p>
<p>一个01矩阵，找到每个元素距离其最近0的距离长度，结果用二维矩阵表达</p>
<div><select onchange="changeCodeExample('code-example-tab-16', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-16-cpp">cpp</option><option value="code-example-tab-16-go">go</option></select></div>
<div id="code-example-tab-16-cpp" class="code-example-tab-16"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
<em></em>
std::vector&lt;std::vector&lt;int&gt;&gt; updateMatrix(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;mat) {
  int m = mat.size();
  int n = mat[0].size();
  std::vector&lt;std::vector&lt;int&gt;&gt; res(m, std::vector&lt;int&gt;(n, 0));
  std::vector&lt;int&gt; dx = {1, 0, -1, 0};
  std::vector&lt;int&gt; dy = {0, -1, 0, 1};
  std::queue&lt;std::pair&lt;int, int&gt;&gt; queue;
<em></em>
  for (int i = 0; i &lt; m; ++i) {
    for (int j = 0; j &lt; n; ++j) {
      if (mat[i][j] == 0) {
        queue.push({i, j});
      }
    }
  }
<em></em>
  while (!queue.empty()) {
    int x = queue.front().first;
    int y = queue.front().second;
    queue.pop();
    for (int k = 0; k &lt; 4; ++k) {
      int nx = x + dx[k];
      int ny = y + dy[k];
      if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; mat[nx][ny] == 1) {
        if (res[nx][ny] == 0 || res[x][y] + 1 &lt; res[nx][ny]) {
          res[nx][ny] = res[x][y] + 1;
          queue.push({nx, ny});
        }
      }
    }
  }
<em></em>
  return res;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; mat = {{0, 0, 0}, {0, 1, 0}, {1, 1, 1}};
  std::vector&lt;std::vector&lt;int&gt;&gt; result = updateMatrix(mat);
  for (const auto &amp;row : result) {
    for (int val : row) {
      std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;
  }
  return 0;
}
</code></pre></div><div id="code-example-tab-16-go" class="code-example-tab-16"><pre><code class="language-go">package main
<em></em>
func updateMatrix(mat [][]int) [][]int {
	m := len(mat)
	n := len(mat[0])
	res := make([][]int, m)
	for i := range res {
		res[i] = make([]int, n)
	}
	dx := []int{1, 0, -1, 0}
	dy := []int{0, -1, 0, 1}
	var queue [][]int
	for i := 0; i &lt; m; i++ {
		for j := 0; j &lt; n; j++ {
			if mat[i][j] == 0 {
				queue = append(queue, []int{i, j})
			}
		}
	}
	for len(queue) &gt; 0 {
		x := queue[0][0]
		y := queue[0][1]
		queue = queue[1:]
		for k := 0; k &lt; 4; k++ {
			nx := x + dx[k]
			ny := y + dy[k]
			if nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; mat[nx][ny] == 1 {
				if res[nx][ny] == 0 || res[x][y]+1 &lt; res[nx][ny] {
					res[nx][ny] = res[x][y] + 1
					queue = append(queue, []int{nx, ny})
				}
			}
		}
	}
	return res
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-16", "code-example-tab-16-cpp")})()</script>
<h2 id="108"><a class="header" href="#108">108</a></h2>
<p><code>剑指 Offer II 108. 单词演变</code></p>
<p>将单词从begin转换成end需要的最小步骤，并且每次的转换中间节点要在wordList中出现</p>
<div><select onchange="changeCodeExample('code-example-tab-17', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-17-cpp">cpp</option><option value="code-example-tab-17-go">go</option></select></div>
<div id="code-example-tab-17-cpp" class="code-example-tab-17"><pre><code class="language-cpp">#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
int ladderLength(const std::string &amp;beginWord, const std::string &amp;endWord,
                 std::vector&lt;std::string&gt; &amp;wordList) {
  std::unordered_map&lt;std::string, int&gt; wordId;
  std::vector&lt;std::vector&lt;int&gt;&gt; graph;
  int idCounter = 0;
<em></em>
  auto addWord = [&amp;](std::string word) -&gt; int {
    if (wordId.find(word) == wordId.end()) {
      wordId[word] = idCounter++;
      graph.push_back({});
    }
    return wordId[word];
  };
<em></em>
  auto addEdge = [&amp;](std::string word) -&gt; int {
    int id1 = addWord(word);
    std::string s = word;
    for (size_t i = 0; i &lt; s.size(); ++i) {
      char originalChar = s[i];
      s[i] = &#39;*&#39;;
      int id2 = addWord(s);
      graph[id1].push_back(id2);
      graph[id2].push_back(id1);
      s[i] = originalChar;
    }
    return id1;
  };
<em></em>
  for (const auto &amp;word : wordList) {
    addEdge(word);
  }
  int beginId = addEdge(beginWord);
  if (wordId.find(endWord) == wordId.end()) {
    return 0;
  }
  int endId = wordId[endWord];
<em></em>
  const int inf = INT_MAX;
  std::vector&lt;int&gt; dist(wordId.size(), inf);
  dist[beginId] = 0;
  std::queue&lt;int&gt; queue;
  queue.push(beginId);
<em></em>
  while (!queue.empty()) {
    int v = queue.front();
    queue.pop();
    if (v == endId) {
      return dist[endId] / 2 + 1;
    }
    for (int w : graph[v]) {
      if (dist[w] == inf) {
        dist[w] = dist[v] + 1;
        queue.push(w);
      }
    }
  }
  return 0;
}
<em></em>
int main() {
  std::vector&lt;std::string&gt; wordList = {&quot;hot&quot;, &quot;dot&quot;, &quot;dog&quot;,
                                       &quot;lot&quot;, &quot;log&quot;, &quot;cog&quot;};
  std::string beginWord = &quot;hit&quot;;
  std::string endWord = &quot;cog&quot;;
  std::cout &lt;&lt; &quot;Ladder length: &quot; &lt;&lt; ladderLength(beginWord, endWord, wordList)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-17-go" class="code-example-tab-17"><pre><code class="language-go">package main
<em></em>
import &quot;math&quot;
<em></em>
func ladderLength(beginWord string, endWord string, wordList []string) int {
	wordId := map[string]int{}
	graph := [][]int{}
	addWord := func(word string) int {
		id, has := wordId[word]
		if !has {
			id = len(wordId)
			wordId[word] = id
			graph = append(graph, []int{})
		}
		return id
	}
	addEdge := func(word string) int {
		id1 := addWord(word)
		s := []byte(word)
		for i, b := range s {
			s[i] = &#39;*&#39;
			id2 := addWord(string(s))
			graph[id1] = append(graph[id1], id2)
			graph[id2] = append(graph[id2], id1)
			s[i] = b
		}
		return id1
	}
<em></em>
	for _, word := range wordList {
		addEdge(word)
	}
	beginId := addEdge(beginWord)
	endId, has := wordId[endWord]
	if !has {
		return 0
	}
<em></em>
	const inf int = math.MaxInt64
	dist := make([]int, len(wordId))
	for i := range dist {
		dist[i] = inf
	}
	dist[beginId] = 0
	queue := []int{beginId}
	for len(queue) &gt; 0 {
		v := queue[0]
		queue = queue[1:]
		if v == endId {
			return dist[endId]/2 + 1
		}
		for _, w := range graph[v] {
			if dist[w] == inf {
				dist[w] = dist[v] + 1
				queue = append(queue, w)
			}
		}
	}
	return 0
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-17", "code-example-tab-17-cpp")})()</script>
<h2 id="109"><a class="header" href="#109">109</a></h2>
<p><code>剑指 Offer II 109. 开密码锁</code></p>
<p>四个环形波轮组成的锁，找到转到目标值target的最小转动次数，另外不能转动到deadends列表中的数据</p>
<div><select onchange="changeCodeExample('code-example-tab-18', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-18-cpp">cpp</option><option value="code-example-tab-18-go">go</option></select></div>
<div id="code-example-tab-18-cpp" class="code-example-tab-18"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;
<em></em>
int openLock(std::vector&lt;std::string&gt; &amp;deadends, std::string target) {
  if (target == &quot;0000&quot;) {
    return 0;
  }
<em></em>
  std::unordered_set&lt;std::string&gt; deadendsSet(deadends.begin(), deadends.end());
  if (deadendsSet.count(target) || deadendsSet.count(&quot;0000&quot;)) {
    return -1;
  }
<em></em>
  std::unordered_set&lt;std::string&gt; visit;
<em></em>
  auto getnei = [](std::string state) -&gt; std::vector&lt;std::string&gt; {
    std::vector&lt;std::string&gt; res;
    std::string s = state;
    for (int i = 0; i &lt; 4; ++i) {
      char ch = s[i];
      s[i] = ch + 1;
      if (s[i] &gt; &#39;9&#39;) {
        s[i] = &#39;0&#39;;
      }
      res.push_back(s);
<em></em>
      s[i] = ch - 1;
      if (s[i] &lt; &#39;0&#39;) {
        s[i] = &#39;9&#39;;
      }
      res.push_back(s);
<em></em>
      s[i] = ch;
    }
    return res;
  };
<em></em>
  std::queue&lt;std::string&gt; queue;
  queue.push(&quot;0000&quot;);
  int step = 0;
  while (!queue.empty()) {
    int size = queue.size();
    for (int i = 0; i &lt; size; ++i) {
      std::string state = queue.front();
      queue.pop();
      for (const auto &amp;ne : getnei(state)) {
        if (!visit.count(ne) &amp;&amp; !deadendsSet.count(ne)) {
          if (ne == target) {
            return step + 1;
          }
          visit.insert(ne);
          queue.push(ne);
        }
      }
    }
    ++step;
  }
  return -1;
}
<em></em>
int main() {
  std::vector&lt;std::string&gt; deadends = {&quot;0201&quot;, &quot;0101&quot;, &quot;0102&quot;, &quot;1212&quot;, &quot;2002&quot;};
  std::string target = &quot;0202&quot;;
  std::cout &lt;&lt; &quot;Minimum turns to open lock: &quot; &lt;&lt; openLock(deadends, target)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-18-go" class="code-example-tab-18"><pre><code class="language-go">package main
<em></em>
func openLock(deadends []string, target string) int {
	if target == &quot;0000&quot; {
		return 0
	}
<em></em>
	deadendsSet := map[string]bool{}
	for _, item := range deadends {
		deadendsSet[item] = true
	}
	if deadendsSet[target] || deadendsSet[&quot;0000&quot;] {
		return -1
	}
<em></em>
	visit := map[string]bool{}
<em></em>
	getnei := func(state string) []string {
		res := []string{}
		s := []byte(state)
		for i, ch := range s {
			s[i] = ch + 1
			if s[i] &gt; &#39;9&#39; {
				s[i] = &#39;0&#39;
			}
			res = append(res, string(s))
<em></em>
			s[i] = ch - 1
			if s[i] &lt; &#39;0&#39; {
				s[i] = &#39;9&#39;
			}
			res = append(res, string(s))
<em></em>
			s[i] = ch
		}
		return res
	}
<em></em>
	queue := []string{&quot;0000&quot;}
	step := 0
	for len(queue) &gt; 0 {
		newqueue := []string{}
		for _, state := range queue {
			for _, ne := range getnei(state) {
				if !visit[ne] &amp;&amp; !deadendsSet[ne] {
					if ne == target {
						return step + 1
					}
					visit[ne] = true
					newqueue = append(newqueue, ne)
				}
			}
		}
		queue = newqueue
		step++
	}
	return -1
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-18", "code-example-tab-18-cpp")})()</script>
<h2 id="110"><a class="header" href="#110">110</a></h2>
<p><code>剑指 Offer II 110. 所有路径</code></p>
<p>给定一个邻接矩阵结构，用于表示一个有向有环图，找到其中的所有的从0到n-1节点的路径</p>
<div><select onchange="changeCodeExample('code-example-tab-19', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-19-cpp">cpp</option><option value="code-example-tab-19-go">go</option></select></div>
<div id="code-example-tab-19-cpp" class="code-example-tab-19"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
void dfs(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;graph, std::vector&lt;int&gt; &amp;stk,
         std::vector&lt;std::vector&lt;int&gt;&gt; &amp;ans, int x) {
  if (x == graph.size() - 1) {
    ans.push_back(stk);
    return;
  }
  for (int y : graph[x]) {
    stk.push_back(y);
    dfs(graph, stk, ans, y);
    stk.pop_back();
  }
}
<em></em>
std::vector&lt;std::vector&lt;int&gt;&gt;
allPathsSourceTarget(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;graph) {
  std::vector&lt;std::vector&lt;int&gt;&gt; ans;
  std::vector&lt;int&gt; stk = {0};
  dfs(graph, stk, ans, 0);
  return ans;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; graph = {{1, 2}, {3}, {3}, {}};
  std::vector&lt;std::vector&lt;int&gt;&gt; result = allPathsSourceTarget(graph);
  for (const auto &amp;path : result) {
    for (int node : path) {
      std::cout &lt;&lt; node &lt;&lt; &quot; &quot;;
    }
    std::cout &lt;&lt; std::endl;
  }
  return 0;
}
</code></pre></div><div id="code-example-tab-19-go" class="code-example-tab-19"><pre><code class="language-go">package main
<em></em>
func allPathsSourceTarget(graph [][]int) (ans [][]int) {
	stk := []int{0}
	var dfs func(int)
	dfs = func(x int) {
		if x == len(graph)-1 {
			ans = append(ans, append([]int{}, stk...))
			return
		}
		for _, y := range graph[x] {
			stk = append(stk, y)
			dfs(y)
			stk = stk[:len(stk)-1]
		}
	}
	dfs(0)
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-19", "code-example-tab-19-cpp")})()</script>
<h2 id="111"><a class="header" href="#111">111</a></h2>
<p><code>剑指 Offer II 111. 计算除法</code></p>
<p>给定一些已知变量除法获取到的值，提供数据查询结果</p>
<div><select onchange="changeCodeExample('code-example-tab-20', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-20-cpp">cpp</option><option value="code-example-tab-20-go">go</option></select></div>
<div id="code-example-tab-20-cpp" class="code-example-tab-20"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
struct Edge {
  int to;
  double weight;
};
<em></em>
std::vector&lt;double&gt;
calcEquation(const std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;equations,
             const std::vector&lt;double&gt; &amp;values,
             const std::vector&lt;std::vector&lt;std::string&gt;&gt; &amp;queries) {
  std::unordered_map&lt;std::string, int&gt; id;
  int idCounter = 0;
<em></em>
  for (const auto &amp;eq : equations) {
    const std::string &amp;a = eq[0];
    const std::string &amp;b = eq[1];
    if (id.find(a) == id.end()) {
      id[a] = idCounter++;
    }
    if (id.find(b) == id.end()) {
      id[b] = idCounter++;
    }
  }
<em></em>
  std::vector&lt;std::vector&lt;Edge&gt;&gt; graph(idCounter);
  for (size_t i = 0; i &lt; equations.size(); ++i) {
    int v = id[equations[i][0]];
    int w = id[equations[i][1]];
    graph[v].push_back({w, values[i]});
    graph[w].push_back({v, 1.0 / values[i]});
  }
<em></em>
  auto bfs = [&amp;](int start, int end) -&gt; double {
    std::vector&lt;double&gt; ratios(idCounter, 0.0);
    ratios[start] = 1.0;
    std::queue&lt;int&gt; queue;
    queue.push(start);
<em></em>
    while (!queue.empty()) {
      int v = queue.front();
      queue.pop();
      if (v == end) {
        return ratios[v];
      }
      for (const auto &amp;e : graph[v]) {
        if (ratios[e.to] == 0.0) {
          ratios[e.to] = ratios[v] * e.weight;
          queue.push(e.to);
        }
      }
    }
    return -1.0;
  };
<em></em>
  std::vector&lt;double&gt; ans(queries.size());
  for (size_t i = 0; i &lt; queries.size(); ++i) {
    const std::string &amp;startStr = queries[i][0];
    const std::string &amp;endStr = queries[i][1];
    if (id.find(startStr) == id.end() || id.find(endStr) == id.end()) {
      ans[i] = -1.0;
    } else {
      ans[i] = bfs(id[startStr], id[endStr]);
    }
  }
  return ans;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;std::string&gt;&gt; equations = {{&quot;a&quot;, &quot;b&quot;}, {&quot;b&quot;, &quot;c&quot;}};
  std::vector&lt;double&gt; values = {2.0, 3.0};
  std::vector&lt;std::vector&lt;std::string&gt;&gt; queries = {
      {&quot;a&quot;, &quot;c&quot;}, {&quot;b&quot;, &quot;a&quot;}, {&quot;a&quot;, &quot;e&quot;}, {&quot;a&quot;, &quot;a&quot;}, {&quot;x&quot;, &quot;x&quot;}};
  std::vector&lt;double&gt; result = calcEquation(equations, values, queries);
  for (double val : result) {
    std::cout &lt;&lt; val &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-20-go" class="code-example-tab-20"><pre><code class="language-go">package main
<em></em>
func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {
	// 给方程组中的每个变量编号
	id := map[string]int{}
	for _, eq := range equations {
		a, b := eq[0], eq[1]
		if _, has := id[a]; !has {
			id[a] = len(id)
		}
		if _, has := id[b]; !has {
			id[b] = len(id)
		}
	}
<em></em>
	// 建图
	type edge struct {
		to     int
		weight float64
	}
	graph := make([][]edge, len(id))
	for i, eq := range equations {
		v, w := id[eq[0]], id[eq[1]]
		graph[v] = append(graph[v], edge{w, values[i]})
		graph[w] = append(graph[w], edge{v, 1 / values[i]})
	}
<em></em>
	bfs := func(start, end int) float64 {
		ratios := make([]float64, len(graph))
		ratios[start] = 1
		queue := []int{start}
		for len(queue) &gt; 0 {
			v := queue[0]
			queue = queue[1:]
			if v == end {
				return ratios[v]
			}
			for _, e := range graph[v] {
				if w := e.to; ratios[w] == 0 {
					ratios[w] = ratios[v] * e.weight
					queue = append(queue, w)
				}
			}
		}
		return -1
	}
<em></em>
	ans := make([]float64, len(queries))
	for i, q := range queries {
		start, hasS := id[q[0]]
		end, hasE := id[q[1]]
		if !hasS || !hasE {
			ans[i] = -1
		} else {
			ans[i] = bfs(start, end)
		}
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-20", "code-example-tab-20-cpp")})()</script>
<h2 id="112"><a class="header" href="#112">112</a></h2>
<p><code>剑指 Offer II 112. 最长递增路径</code></p>
<p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
<div><select onchange="changeCodeExample('code-example-tab-21', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-21-cpp">cpp</option><option value="code-example-tab-21-go">go</option></select></div>
<div id="code-example-tab-21-cpp" class="code-example-tab-21"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
<em></em>
std::vector&lt;std::pair&lt;int, int&gt;&gt; dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
int rows, columns;
<em></em>
int longestIncreasingPath(std::vector&lt;std::vector&lt;int&gt;&gt; &amp;matrix) {
  if (matrix.empty() || matrix[0].empty()) {
    return 0;
  }
  rows = matrix.size();
  columns = matrix[0].size();
  std::vector&lt;std::vector&lt;int&gt;&gt; outdegrees(rows, std::vector&lt;int&gt;(columns, 0));
<em></em>
  for (int i = 0; i &lt; rows; ++i) {
    for (int j = 0; j &lt; columns; ++j) {
      for (const auto &amp;dir : dirs) {
        int newRow = i + dir.first;
        int newColumn = j + dir.second;
        if (newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp;
            newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) {
          outdegrees[i][j]++;
        }
      }
    }
  }
<em></em>
  std::queue&lt;std::pair&lt;int, int&gt;&gt; queue;
  for (int i = 0; i &lt; rows; ++i) {
    for (int j = 0; j &lt; columns; ++j) {
      if (outdegrees[i][j] == 0) {
        queue.push({i, j});
      }
    }
  }
<em></em>
  int ans = 0;
  while (!queue.empty()) {
    ans++;
    int size = queue.size();
    for (int i = 0; i &lt; size; ++i) {
      auto cell = queue.front();
      queue.pop();
      int row = cell.first;
      int column = cell.second;
      for (const auto &amp;dir : dirs) {
        int newRow = row + dir.first;
        int newColumn = column + dir.second;
        if (newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp;
            newColumn &lt; columns &amp;&amp;
            matrix[newRow][newColumn] &lt; matrix[row][column]) {
          outdegrees[newRow][newColumn]--;
          if (outdegrees[newRow][newColumn] == 0) {
            queue.push({newRow, newColumn});
          }
        }
      }
    }
  }
  return ans;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {{9, 9, 4}, {6, 6, 8}, {2, 1, 1}};
  std::cout &lt;&lt; &quot;Longest increasing path: &quot; &lt;&lt; longestIncreasingPath(matrix)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-21-go" class="code-example-tab-21"><pre><code class="language-go">package main
<em></em>
var (
	dirs = [][2]int{
		{-1, 0},
		{1, 0},
		{0, -1},
		{0, 1},
	}
	rows, columns int
)
<em></em>
func longestIncreasingPath(matrix [][]int) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}
	rows, columns = len(matrix), len(matrix[0])
	outdegrees := make([][]int, rows)
	for i := 0; i &lt; rows; i++ {
		outdegrees[i] = make([]int, columns)
	}
	for i := 0; i &lt; rows; i++ {
		for j := 0; j &lt; columns; j++ {
			for _, dir := range dirs {
				newRow, newColumn := i+dir[0], j+dir[1]
				if newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j] {
					outdegrees[i][j]++
				}
			}
		}
	}
<em></em>
	queue := [][]int{}
	for i := 0; i &lt; rows; i++ {
		for j := 0; j &lt; columns; j++ {
			if outdegrees[i][j] == 0 {
				queue = append(queue, []int{i, j})
			}
		}
	}
	ans := 0
	for len(queue) != 0 {
		ans++
		size := len(queue)
		for i := 0; i &lt; size; i++ {
			cell := queue[0]
			queue = queue[1:]
			row, column := cell[0], cell[1]
			for _, dir := range dirs {
				newRow, newColumn := row+dir[0], column+dir[1]
				if newRow &gt;= 0 &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= 0 &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column] {
					outdegrees[newRow][newColumn]--
					if outdegrees[newRow][newColumn] == 0 {
						queue = append(queue, []int{newRow, newColumn})
					}
				}
			}
		}
	}
	return ans
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-21", "code-example-tab-21-cpp")})()</script>
<h2 id="113"><a class="header" href="#113">113</a></h2>
<p><code>剑指 Offer II 113. 课程顺序</code></p>
<p>总共n门课，并且有一些先后依赖顺序，返回要完成所有课程所需要的一个正确的课程顺序</p>
<div><select onchange="changeCodeExample('code-example-tab-22', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-22-cpp">cpp</option><option value="code-example-tab-22-go">go</option></select></div>
<div id="code-example-tab-22-cpp" class="code-example-tab-22"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
<em></em>
std::vector&lt;int&gt; findOrder(int numCourses,
                           std::vector&lt;std::vector&lt;int&gt;&gt; &amp;prerequisites) {
  std::vector&lt;std::vector&lt;int&gt;&gt; edges(numCourses);
  std::vector&lt;int&gt; indeg(numCourses, 0);
  std::vector&lt;int&gt; result;
<em></em>
  for (const auto &amp;info : prerequisites) {
    edges[info[1]].push_back(info[0]);
    indeg[info[0]]++;
  }
<em></em>
  std::queue&lt;int&gt; q;
  for (int i = 0; i &lt; numCourses; ++i) {
    if (indeg[i] == 0) {
      q.push(i);
    }
  }
<em></em>
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    result.push_back(u);
    for (int v : edges[u]) {
      indeg[v]--;
      if (indeg[v] == 0) {
        q.push(v);
      }
    }
  }
<em></em>
  if (result.size() != numCourses) {
    return {};
  }
  return result;
}
<em></em>
int main() {
  int numCourses = 4;
  std::vector&lt;std::vector&lt;int&gt;&gt; prerequisites = {
      {1, 0}, {2, 0}, {3, 1}, {3, 2}};
  std::vector&lt;int&gt; order = findOrder(numCourses, prerequisites);
  for (int course : order) {
    std::cout &lt;&lt; course &lt;&lt; &quot; &quot;;
  }
  std::cout &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-22-go" class="code-example-tab-22"><pre><code class="language-go">package main
<em></em>
func findOrder(numCourses int, prerequisites [][]int) []int {
	var (
		edges  = make([][]int, numCourses)
		indeg  = make([]int, numCourses)
		result []int
	)
<em></em>
	for _, info := range prerequisites {
		edges[info[1]] = append(edges[info[1]], info[0])
		indeg[info[0]]++
	}
<em></em>
	q := []int{}
	for i := 0; i &lt; numCourses; i++ {
		if indeg[i] == 0 {
			q = append(q, i)
		}
	}
<em></em>
	for len(q) &gt; 0 {
		u := q[0]
		q = q[1:]
		result = append(result, u)
		for _, v := range edges[u] {
			indeg[v]--
			if indeg[v] == 0 {
				q = append(q, v)
			}
		}
	}
	if len(result) != numCourses {
		return []int{}
	}
	return result
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-22", "code-example-tab-22-cpp")})()</script>
<h2 id="114"><a class="header" href="#114">114</a></h2>
<p><code>剑指 Offer II 114. 外星文字典</code></p>
<p>通过已知的满足特定顺序的字符串数组，来推导出这个而特定的顺序</p>
<div><select onchange="changeCodeExample('code-example-tab-23', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-23-cpp">cpp</option><option value="code-example-tab-23-go">go</option></select></div>
<div id="code-example-tab-23-cpp" class="code-example-tab-23"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
<em></em>
std::string alienOrder(const std::vector&lt;std::string&gt; &amp;words) {
  std::unordered_map&lt;char, std::vector&lt;char&gt;&gt; g;
  std::unordered_map&lt;char, int&gt; inDeg;
  for (char c : words[0]) {
    inDeg[c] = 0;
  }
<em></em>
  for (size_t i = 1; i &lt; words.size(); ++i) {
    const std::string &amp;s = words[i - 1];
    const std::string &amp;t = words[i];
    for (char c : t) {
      inDeg[c] += 0;
    }
    for (size_t j = 0; j &lt; s.size() &amp;&amp; j &lt; t.size(); ++j) {
      if (s[j] != t[j]) {
        g[s[j]].push_back(t[j]);
        inDeg[t[j]]++;
        break;
      }
    }
    if (s.size() &gt; t.size() &amp;&amp; s.substr(0, t.size()) == t) {
      return &quot;&quot;;
    }
  }
<em></em>
  std::string order;
  std::queue&lt;char&gt; q;
  for (const auto &amp;[u, d] : inDeg) {
    if (d == 0) {
      q.push(u);
    }
  }
<em></em>
  while (!q.empty()) {
    char u = q.front();
    q.pop();
    order.push_back(u);
    for (char v : g[u]) {
      if (--inDeg[v] == 0) {
        q.push(v);
      }
    }
  }
<em></em>
  if (order.size() != inDeg.size()) {
    return &quot;&quot;;
  }
  return order;
}
<em></em>
int main() {
  std::vector&lt;std::string&gt; words = {&quot;wrt&quot;, &quot;wrf&quot;, &quot;er&quot;, &quot;ett&quot;, &quot;rftt&quot;};
  std::string result = alienOrder(words);
  std::cout &lt;&lt; &quot;Alien dictionary order: &quot; &lt;&lt; result &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-23-go" class="code-example-tab-23"><pre><code class="language-go">package main
<em></em>
func alienOrder(words []string) string {
	g := map[byte][]byte{}
	inDeg := map[byte]int{}
	for _, c := range words[0] {
		inDeg[byte(c)] = 0
	}
next:
	for i := 1; i &lt; len(words); i++ {
		s, t := words[i-1], words[i]
		for _, c := range t {
			inDeg[byte(c)] += 0
		}
		for j := 0; j &lt; len(s) &amp;&amp; j &lt; len(t); j++ {
			if s[j] != t[j] {
				g[s[j]] = append(g[s[j]], t[j])
				inDeg[t[j]]++
				continue next
			}
		}
		if len(s) &gt; len(t) {
			return &quot;&quot;
		}
	}
<em></em>
	order := make([]byte, len(inDeg))
	q := order[:0]
	for u, d := range inDeg {
		if d == 0 {
			q = append(q, u)
		}
	}
	for len(q) &gt; 0 {
		u := q[0]
		q = q[1:]
		for _, v := range g[u] {
			if inDeg[v]--; inDeg[v] == 0 {
				q = append(q, v)
			}
		}
	}
	if cap(q) == 0 {
		return string(order)
	}
	return &quot;&quot;
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-23", "code-example-tab-23-cpp")})()</script>
<h2 id="115"><a class="header" href="#115">115</a></h2>
<p><code>剑指 Offer II 115. 重建序列</code></p>
<p>https://leetcode.cn/problems/ur2n8P/?favorite=e8X3pBZi</p>
<div><select onchange="changeCodeExample('code-example-tab-24', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-24-cpp">cpp</option><option value="code-example-tab-24-go">go</option></select></div>
<div id="code-example-tab-24-cpp" class="code-example-tab-24"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
<em></em>
bool sequenceReconstruction(const std::vector&lt;int&gt; &amp;nums,
                            const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;sequences) {
  int n = nums.size();
  std::vector&lt;std::vector&lt;int&gt;&gt; g(n + 1);
  std::vector&lt;int&gt; inDeg(n + 1, 0);
<em></em>
  for (const auto &amp;sequence : sequences) {
    for (size_t i = 1; i &lt; sequence.size(); ++i) {
      int x = sequence[i - 1];
      int y = sequence[i];
      g[x].push_back(y);
      inDeg[y]++;
    }
  }
<em></em>
  std::queue&lt;int&gt; q;
  for (int i = 1; i &lt;= n; ++i) {
    if (inDeg[i] == 0) {
      q.push(i);
    }
  }
<em></em>
  while (!q.empty()) {
    if (q.size() &gt; 1) {
      return false;
    }
    int x = q.front();
    q.pop();
    for (int y : g[x]) {
      if (--inDeg[y] == 0) {
        q.push(y);
      }
    }
  }
<em></em>
  return true;
}
<em></em>
int main() {
  std::vector&lt;int&gt; nums = {1, 2, 3};
  std::vector&lt;std::vector&lt;int&gt;&gt; sequences = {{1, 2}, {1, 3}};
  std::cout &lt;&lt; &quot;Can reconstruct sequence: &quot;
            &lt;&lt; (sequenceReconstruction(nums, sequences) ? &quot;true&quot; : &quot;false&quot;)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-24-go" class="code-example-tab-24"><pre><code class="language-go">package main
<em></em>
func sequenceReconstruction(nums []int, sequences [][]int) bool {
	n := len(nums)
	g := make([][]int, n+1)
	inDeg := make([]int, n+1)
	for _, sequence := range sequences {
		for i := 1; i &lt; len(sequence); i++ {
			x, y := sequence[i-1], sequence[i]
			g[x] = append(g[x], y)
			inDeg[y]++
		}
	}
<em></em>
	q := []int{}
	for i := 1; i &lt;= n; i++ {
		if inDeg[i] == 0 {
			q = append(q, i)
		}
	}
	for len(q) &gt; 0 {
		if len(q) &gt; 1 {
			return false
		}
		x := q[0]
		q = q[1:]
		for _, y := range g[x] {
			if inDeg[y]--; inDeg[y] == 0 {
				q = append(q, y)
			}
		}
	}
	return true
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-24", "code-example-tab-24-cpp")})()</script>
<h2 id="116"><a class="header" href="#116">116</a></h2>
<p><code>剑指 Offer II 116. 省份数量</code></p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<div><select onchange="changeCodeExample('code-example-tab-25', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-25-cpp">cpp</option><option value="code-example-tab-25-go">go</option></select></div>
<div id="code-example-tab-25-cpp" class="code-example-tab-25"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int find(std::vector&lt;int&gt; &amp;parent, int x) {
  if (parent[x] != x) {
    parent[x] = find(parent, parent[x]);
  }
  return parent[x];
}
<em></em>
void unionSets(std::vector&lt;int&gt; &amp;parent, int from, int to) {
  parent[find(parent, from)] = find(parent, to);
}
<em></em>
int findCircleNum(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;isConnected) {
  int n = isConnected.size();
  std::vector&lt;int&gt; parent(n);
  for (int i = 0; i &lt; n; ++i) {
    parent[i] = i;
  }
<em></em>
  for (int i = 0; i &lt; n; ++i) {
    for (int j = i + 1; j &lt; n; ++j) {
      if (isConnected[i][j] == 1) {
        unionSets(parent, i, j);
      }
    }
  }
<em></em>
  int ans = 0;
  for (int i = 0; i &lt; n; ++i) {
    if (parent[i] == i) {
      ++ans;
    }
  }
  return ans;
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; isConnected = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
  std::cout &lt;&lt; &quot;Number of provinces: &quot; &lt;&lt; findCircleNum(isConnected)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-25-go" class="code-example-tab-25"><pre><code class="language-go">package main
<em></em>
func findCircleNum(isConnected [][]int) (ans int) {
	n := len(isConnected)
	parent := make([]int, n)
	for i := range parent {
		parent[i] = i
	}
	var find func(int) int
	find = func(x int) int {
		if parent[x] != x {
			parent[x] = find(parent[x])
		}
		return parent[x]
	}
	union := func(from, to int) {
		parent[find(from)] = find(to)
	}
<em></em>
	for i, row := range isConnected {
		for j := i + 1; j &lt; n; j++ {
			if row[j] == 1 {
				union(i, j)
			}
		}
	}
	for i, p := range parent {
		if i == p {
			ans++
		}
	}
	return
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-25", "code-example-tab-25-cpp")})()</script>
<h2 id="117"><a class="header" href="#117">117</a></h2>
<p><code>剑指 Offer II 117. 相似的字符串</code></p>
<p>寻找一个字符串数组中，有多少个分组，这些分组里面都是同一种字母异位词。</p>
<div><select onchange="changeCodeExample('code-example-tab-26', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-26-cpp">cpp</option><option value="code-example-tab-26-go">go</option></select></div>
<div id="code-example-tab-26-cpp" class="code-example-tab-26"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
<em></em>
class UnionFind {
public:
  UnionFind(int n) : parent(n), size(n, 1), setCount(n) {
    for (int i = 0; i &lt; n; ++i) {
      parent[i] = i;
    }
  }
<em></em>
  int find(int x) {
    if (parent[x] != x) {
      parent[x] = find(parent[x]);
    }
    return parent[x];
  }
<em></em>
  void unionSets(int x, int y) {
    int fx = find(x), fy = find(y);
    if (fx == fy)
      return;
    if (size[fx] &lt; size[fy])
      std::swap(fx, fy);
    size[fx] += size[fy];
    parent[fy] = fx;
    --setCount;
  }
<em></em>
  bool inSameSet(int x, int y) { return find(x) == find(y); }
<em></em>
  int getSetCount() const { return setCount; }
<em></em>
private:
  std::vector&lt;int&gt; parent;
  std::vector&lt;int&gt; size;
  int setCount;
};
<em></em>
bool isSimilar(const std::string &amp;s, const std::string &amp;t) {
  int diff = 0;
  for (size_t i = 0; i &lt; s.size(); ++i) {
    if (s[i] != t[i]) {
      ++diff;
      if (diff &gt; 2) {
        return false;
      }
    }
  }
  return true;
}
<em></em>
int numSimilarGroups(const std::vector&lt;std::string&gt; &amp;strs) {
  int n = strs.size();
  UnionFind uf(n);
  for (int i = 0; i &lt; n; ++i) {
    for (int j = i + 1; j &lt; n; ++j) {
      if (!uf.inSameSet(i, j) &amp;&amp; isSimilar(strs[i], strs[j])) {
        uf.unionSets(i, j);
      }
    }
  }
  return uf.getSetCount();
}
<em></em>
int main() {
  std::vector&lt;std::string&gt; strs = {&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;, &quot;star&quot;};
  std::cout &lt;&lt; &quot;Number of similar groups: &quot; &lt;&lt; numSimilarGroups(strs)
            &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-26-go" class="code-example-tab-26"><pre><code class="language-go">package main
<em></em>
type unionFind struct {
	parent, size []int
	setCount     int // 当前连通分量数目
}
<em></em>
func newUnionFind(n int) *unionFind {
	parent := make([]int, n)
	size := make([]int, n)
	for i := range parent {
		parent[i] = i
		size[i] = 1
	}
	return &amp;unionFind{parent, size, n}
}
<em></em>
func (uf *unionFind) find(x int) int {
	if uf.parent[x] != x {
		uf.parent[x] = uf.find(uf.parent[x])
	}
	return uf.parent[x]
}
<em></em>
func (uf *unionFind) union(x, y int) {
	fx, fy := uf.find(x), uf.find(y)
	if fx == fy {
		return
	}
	if uf.size[fx] &lt; uf.size[fy] {
		fx, fy = fy, fx
	}
	uf.size[fx] += uf.size[fy]
	uf.parent[fy] = fx
	uf.setCount--
}
<em></em>
func (uf *unionFind) inSameSet(x, y int) bool {
	return uf.find(x) == uf.find(y)
}
<em></em>
func isSimilar(s, t string) bool {
	diff := 0
	for i := range s {
		if s[i] != t[i] {
			diff++
			if diff &gt; 2 {
				return false
			}
		}
	}
	return true
}
<em></em>
func numSimilarGroups(strs []string) int {
	n := len(strs)
	uf := newUnionFind(n)
	for i, s := range strs {
		for j := i + 1; j &lt; n; j++ {
			if !uf.inSameSet(i, j) &amp;&amp; isSimilar(s, strs[j]) {
				uf.union(i, j)
			}
		}
	}
	return uf.setCount
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-26", "code-example-tab-26-cpp")})()</script>
<h2 id="118"><a class="header" href="#118">118</a></h2>
<p><code>剑指 Offer II 118. 多余的边</code></p>
<p>给定一个无向图，找到找出一条可以删除的边，使其变为树</p>
<div><select onchange="changeCodeExample('code-example-tab-27', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-27-cpp">cpp</option><option value="code-example-tab-27-go">go</option></select></div>
<div id="code-example-tab-27-cpp" class="code-example-tab-27"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
<em></em>
int find(std::vector&lt;int&gt; &amp;parent, int x) {
  if (parent[x] != x) {
    parent[x] = find(parent, parent[x]);
  }
  return parent[x];
}
<em></em>
bool unionSets(std::vector&lt;int&gt; &amp;parent, int from, int to) {
  int x = find(parent, from);
  int y = find(parent, to);
  if (x == y) {
    return false;
  }
  parent[x] = y;
  return true;
}
<em></em>
std::vector&lt;int&gt;
findRedundantConnection(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;edges) {
  std::vector&lt;int&gt; parent(edges.size() + 1);
  for (size_t i = 0; i &lt; parent.size(); ++i) {
    parent[i] = i;
  }
<em></em>
  for (const auto &amp;edge : edges) {
    if (!unionSets(parent, edge[0], edge[1])) {
      return edge;
    }
  }
  return {};
}
<em></em>
int main() {
  std::vector&lt;std::vector&lt;int&gt;&gt; edges = {{1, 2}, {1, 3}, {2, 3}};
  std::vector&lt;int&gt; result = findRedundantConnection(edges);
  std::cout &lt;&lt; &quot;Redundant connection: [&quot; &lt;&lt; result[0] &lt;&lt; &quot;, &quot; &lt;&lt; result[1]
            &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-27-go" class="code-example-tab-27"><pre><code class="language-go">package main
<em></em>
func findRedundantConnection(edges [][]int) []int {
	parent := make([]int, len(edges)+1)
	for i := range parent {
		parent[i] = i
	}
	var find func(int) int
	find = func(x int) int {
		if parent[x] != x {
			parent[x] = find(parent[x])
		}
		return parent[x]
	}
	union := func(from, to int) bool {
		x, y := find(from), find(to)
		if x == y {
			return false
		}
		parent[x] = y
		return true
	}
	for _, e := range edges {
		if !union(e[0], e[1]) {
			return e
		}
	}
	return nil
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-27", "code-example-tab-27-cpp")})()</script>
<h2 id="119"><a class="header" href="#119">119</a></h2>
<p><code>剑指 Offer II 119. 最长连续序列</code></p>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>要求时间复杂度为O(n)</p>
<div><select onchange="changeCodeExample('code-example-tab-28', event.target.value)" value="cpp" class="code-example" autocomplete="off"><option value="code-example-tab-28-cpp">cpp</option><option value="code-example-tab-28-go">go</option></select></div>
<div id="code-example-tab-28-cpp" class="code-example-tab-28"><pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;
<em></em>
int longestConsecutive(const std::vector&lt;int&gt; &amp;nums) {
  std::unordered_set&lt;int&gt; numSet(nums.begin(), nums.end());
  int longestStreak = 0;
<em></em>
  for (int num : numSet) {
    if (numSet.find(num - 1) == numSet.end()) {
      int currentNum = num;
      int currentStreak = 1;
<em></em>
      while (numSet.find(currentNum + 1) != numSet.end()) {
        currentNum++;
        currentStreak++;
      }
<em></em>
      longestStreak = std::max(longestStreak, currentStreak);
    }
  }
<em></em>
  return longestStreak;
}
<em></em>
int main() {
  std::vector&lt;int&gt; nums = {100, 4, 200, 1, 3, 2};
  std::cout &lt;&lt; &quot;Longest consecutive sequence length: &quot;
            &lt;&lt; longestConsecutive(nums) &lt;&lt; std::endl;
  return 0;
}
</code></pre></div><div id="code-example-tab-28-go" class="code-example-tab-28"><pre><code class="language-go">package main
<em></em>
func longestConsecutive(nums []int) int {
	numSet := map[int]bool{}
	for _, num := range nums {
		numSet[num] = true
	}
	longestStreak := 0
	for num := range numSet {
		if !numSet[num-1] {
			currentNum := num
			currentStreak := 1
			for numSet[currentNum+1] {
				currentNum++
				currentStreak++
			}
			if longestStreak &lt; currentStreak {
				longestStreak = currentStreak
			}
		}
	}
	return longestStreak
}
</code></pre></div><script>(()=>{changeCodeExample("code-example-tab-28", "code-example-tab-28-cpp")})()</script>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="../../数据结构与算法/题库/剑指offer3.html" class="mobile-nav-chapters previous"
                            title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next prefetch" href="../../数据结构与算法/短链系统设计.html" class="mobile-nav-chapters next"
                            title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="../../数据结构与算法/题库/剑指offer3.html" class="nav-chapters previous" title="Previous chapter"
                    aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next prefetch" href="../../数据结构与算法/短链系统设计.html" class="nav-chapters next" title="Next chapter"
                    aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../.././theme/style.js"></script>
        <script src="../../clarity.js"></script>
        <script src="../.././theme/highlight.js"></script>


    </div>
</body>

</html>