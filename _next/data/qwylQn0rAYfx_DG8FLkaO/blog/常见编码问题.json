{"pageProps":{"post":{"mdxSource":"<h2>内存泄漏实例</h2>\n<p>1、</p>\n<pre><code class=\"hljs language-go\">package main\n\n<span class=\"hljs-keyword\">import</span> (\n    <span class=\"hljs-string\">&quot;fmt&quot;</span>\n    <span class=\"hljs-string\">&quot;io/ioutil&quot;</span>\n    <span class=\"hljs-string\">&quot;net/http&quot;</span>\n    <span class=\"hljs-string\">&quot;runtime&quot;</span>\n)\n\nfunc <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    num := <span class=\"hljs-number\">6</span>\n    <span class=\"hljs-keyword\">for</span> index := <span class=\"hljs-number\">0</span>; index &lt; num; index++ {\n        resp, _ := http.<span class=\"hljs-title class_\">Get</span>(<span class=\"hljs-string\">&quot;https://www.baidu.com&quot;</span>)\n        _, _ = ioutil.<span class=\"hljs-title class_\">ReadAll</span>(resp.<span class=\"hljs-property\">Body</span>)\n    }\n    fmt.<span class=\"hljs-title class_\">Printf</span>(<span class=\"hljs-string\">&quot;此时goroutine个数= %d\\n&quot;</span>, runtime.<span class=\"hljs-title class_\">NumGoroutine</span>())\n}\n</code></pre><blockquote>\n<p>注意，如果从单元测试中进行测试，那么就是4个，因为单元测试函数入口也会算一个😹</p>\n</blockquote>\n<ul>\n<li>虽然执行了 6 次循环，而且每次都没有执行 Body.Close() ,就是因为执行了ioutil.ReadAll()把内容都读出来了，连接得以复用，因此只泄漏了一个读goroutine和一个写goroutine，最后加上main goroutine，所以答案就是3个goroutine。</li>\n<li>从另外一个角度说，正常情况下我们的代码都会执行 ioutil.ReadAll()，但如果此时忘了 resp.Body.Close()，确实会导致泄漏。但如果你调用的域名一直是同一个的话，那么只会泄漏一个 读goroutine 和一个写goroutine，这就是为什么代码明明不规范但却看不到明显内存泄漏的原因。</li>\n</ul>\n<p>2、</p>\n<pre><code class=\"hljs language-go\">func <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\"></span>) {\n    pub := <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\">start int</span>) {\n        <span class=\"hljs-keyword\">for</span> j := start; j &lt; count; j += concurrency {\n            select {\n            <span class=\"hljs-keyword\">case</span> subscribers[j] &lt;- <span class=\"hljs-attr\">msg</span>:\n        <span class=\"hljs-keyword\">case</span> &lt;-time.After(time.Millisecond * 5):\n            case &lt;-b.exit:\n                return\n            }\n        }\n    }\n    \n    for i := 0; i &lt; concurrency; i++ {\n        go pub(i)\n    }\n}\n</code></pre><p>被遗弃的time.After定时任务还是在时间堆里面，定时任务未到期之前，是不会被gc清理的，所以这就是会造成内存泄漏的原因</p>\n<p><code>time.After</code>虽然调用的是<code>timer</code>定时器，但是他没有使用<code>time.Reset()</code> 方法再次激活定时器，所以每一次都是新创建的实例，才会造成的内存泄漏，我们添加上<code>time.Reset</code>每次重新激活定时器，即可完成解决问题。</p>\n<pre><code class=\"hljs language-go\">func <span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-params\">msg interface{}, subscribers []chan interface{}</span>) {\n    count := <span class=\"hljs-number\">100</span>\n    concurrency := <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-comment\">//采用Timer 而不是使用time.After 原因：time.After会产生内存泄漏 在计时器触发之前，垃圾回收器不会回收Timer</span>\n    pub := <span class=\"hljs-title function_\">func</span>(<span class=\"hljs-params\">start int</span>) {\n        idleDuration := <span class=\"hljs-number\">5</span> * time.<span class=\"hljs-property\">Millisecond</span>\n        idleTimeout := time.<span class=\"hljs-title class_\">NewTimer</span>(idleDuration)\n        defer idleTimeout.<span class=\"hljs-title class_\">Stop</span>()\n        <span class=\"hljs-keyword\">for</span> j := start; j &lt; count; j += concurrency {\n        <span class=\"hljs-comment\">// 如果明确time已经expired，并且t.C已经读取过值，那么可以直接使用Reset；如果程序之前没有从t.C中读取过值，这时需要首先调用Stop()，如果返回true，说明timer还没有expire，stop成功删除timer，可直接reset；如果返回false，说明stop前已经expire，需要显式drain channel。</span>\n            <span class=\"hljs-keyword\">if</span> !idleTimeout.<span class=\"hljs-title class_\">Stop</span>() {\n                select {\n                <span class=\"hljs-keyword\">case</span> &lt;-idleTimeout.C:\n                // 避免hang住 有可能已经被读取过了\n                default:\n                }\n            }\n        \n        // 它的返回值不代表重设定时器成功或失败，而是在表达定时器在重设前的状态：-   当Timer已经停止或者超时，返回false。, -   当定时器未超时时，返回true。\nidleTimeout.Reset(idleDuration)\n            select {\n            case subscribers[j] &lt;- msg:\n            case &lt;-idleTimeout.C:\n            }\n        }\n    }\n    for i := 0; i &lt; concurrency; i++ {\n        go pub(i)\n    }\n}\n</code></pre>","frontMatter":{"readingTime":{"text":"4 min read","minutes":3.87,"time":232200,"words":774},"slug":"常见编码问题","fileName":"常见编码问题.md","title":"golang编程中常见的问题","date":"2022-10-10T00:00:00.000Z","tags":["Golang"],"draft":false,"summary":"golang编程中常见的问题"}},"prev":{"title":"操作系统性能分析工具","date":"2022-10-10T00:00:00.000Z","tags":["操作系统"],"draft":false,"summary":"操作系统性能分析工具","slug":"操作系统性能分析工具"},"next":{"title":"golang命令工具","date":"2022-10-10T00:00:00.000Z","tags":["Golang"],"draft":false,"summary":"golang命令工具","slug":"go命令工具"}},"__N_SSG":true}