<!DOCTYPE html><html lang="zh-CN"><head><meta name="viewport" content="width=device-width"/><title>golang编程中常见的问题</title><meta name="robots" content="follow, index"/><meta charSet="UTF-8"/><meta name="description" content="golang编程中常见的问题"/><meta property="og:type"/><meta property="og:title" content="golang编程中常见的问题"/><meta property="og:description" content="golang编程中常见的问题"/><meta property="og:url" content="https://wwqdrh.github.io/undefined"/><meta name="keywords" content="wwqdrh技术博客"/><meta property="og:locale" content="zh-CN"/><meta property="og:image" content="https://wwqdrh.github.io"/><meta name="twitter:title" content="golang编程中常见的问题"/><meta name="twitter:description" content="golang编程中常见的问题"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image" content="https://wwqdrh.github.io"/><link rel="stylesheet" href="/assets/mdrender/editor-render.css"/><meta name="next-head-count" content="17"/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" sizes="192x192" href="/apple-touch-icon.png"/><link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/feed"/><script src="/assets/analizy/clarity.js"></script><link rel="preload" href="/_next/static/media/d83e92f0af8b17e4-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/e52907b750a6f61e-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/ed42d1b51efd45f6-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/9031250013752d4b-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/fba9d678ff638e59-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/eb9adf802b0a60eb-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/81b352a4d7a000ae-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/41b9b3ece820718f-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/d587d1c112526568-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/869c7de7c781f904.css" as="style"/><link rel="stylesheet" href="/_next/static/css/869c7de7c781f904.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-6ef43a8d4a395f49.js" defer=""></script><script src="/_next/static/chunks/framework-fbe37f60a09a330b.js" defer=""></script><script src="/_next/static/chunks/main-082d90b1269d95f6.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ebc472ae118a2be0.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5B...slug%5D-222bf60d0a2bf3df.js" defer=""></script><script src="/_next/static/qwylQn0rAYfx_DG8FLkaO/_buildManifest.js" defer=""></script><script src="/_next/static/qwylQn0rAYfx_DG8FLkaO/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css-global c86wz">body{margin:0;padding:0;color:hsl(0, 0%, 9.0%);background-color:hsl(0, 0%, 97.3%);font-family:'__pretendard_6bb8e5','__pretendard_Fallback_6bb8e5';}*{-webkit-print-color-scheme:light;color-scheme:light;box-sizing:border-box;}h1,h2,h3,h4,h5,h6{margin:0;font-weight:inherit;font-style:inherit;}a{all:unset;cursor:pointer;}ul{padding:0;}button{all:unset;cursor:pointer;}input{all:unset;box-sizing:border-box;}textarea{border:none;background-color:transparent;font-family:inherit;padding:0;outline:none;resize:none;color:inherit;}hr{width:100%;border:none;margin:0;border-top:1px solid hsl(0, 0%, 88.7%);}</style><style data-emotion="css 1q70a33">.css-1q70a33{z-index:30;position:-webkit-sticky;position:sticky;top:0;background-color:hsl(0, 0%, 97.3%);box-shadow:0 1px 2px 0 rgba(0, 0, 0, 0.05);}.css-1q70a33 .container{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;width:100%;height:3rem;margin:0 auto;}@media (min-width: 768px){.css-1q70a33 .container[data-full-width="true"]{padding-left:6rem;padding-right:6rem;}}.css-1q70a33 .container .nav{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:0.75rem;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}.css-1q70a33 .container .mid{padding-top:0.5rem;padding-bottom:0.5rem;padding-left:1.25rem;padding-right:1.25rem;border-radius:1rem;outline-style:none;width:50%;background-color:hsl(0, 0%, 93.0%);}</style><div class="py-2 css-1q70a33"><div data-full-width="false" class="container"><a aria-label="wwqdrh" class="css-0" href="/">wwqdrh</a><input class="mid" type="text" placeholder="Search Keyword..." value=""/><div class="nav"><style data-emotion="css 1nw6zn9">.css-1nw6zn9{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}.css-1nw6zn9 ul{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}.css-1nw6zn9 ul li{display:block;margin-left:1rem;color:hsl(0, 0%, 43.5%);}</style><div class="css-1nw6zn9"><ul><li><a target="_blank" href="https://space.bilibili.com/538676331">B站</a></li></ul></div><style data-emotion="css 1h5x3dy">.css-1h5x3dy{cursor:pointer;}</style><div class="css-1h5x3dy"><style data-emotion="css p95608">.css-p95608{font-family:'__Noto_Color_Emoji_be1378','__Noto_Color_Emoji_Fallback_be1378',Apple Color Emoji;font-weight:400;font-style:normal;}</style><span class="css-p95608">☀️</span></div></div></div></div><style data-emotion="css lomkhl">.css-lomkhl{margin:0 auto;width:100%;padding:0 3rem;}</style><main class="css-lomkhl"><div class="divide-y bg-white dark:bg-gray-700 p-6 shadow-lg rounded-lg mt-3 divide-gray-200 dark:divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0"><div class="max-w-none pt-10 pb-8 prose dark:prose-dark"><div><h2>内存泄漏实例</h2>
<p>1、</p>
<pre><code class="hljs language-go">package main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">&quot;fmt&quot;</span>
    <span class="hljs-string">&quot;io/ioutil&quot;</span>
    <span class="hljs-string">&quot;net/http&quot;</span>
    <span class="hljs-string">&quot;runtime&quot;</span>
)

func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    num := <span class="hljs-number">6</span>
    <span class="hljs-keyword">for</span> index := <span class="hljs-number">0</span>; index &lt; num; index++ {
        resp, _ := http.<span class="hljs-title class_">Get</span>(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)
        _, _ = ioutil.<span class="hljs-title class_">ReadAll</span>(resp.<span class="hljs-property">Body</span>)
    }
    fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">&quot;此时goroutine个数= %d\n&quot;</span>, runtime.<span class="hljs-title class_">NumGoroutine</span>())
}
</code></pre><blockquote>
<p>注意，如果从单元测试中进行测试，那么就是4个，因为单元测试函数入口也会算一个😹</p>
</blockquote>
<ul>
<li>虽然执行了 6 次循环，而且每次都没有执行 Body.Close() ,就是因为执行了ioutil.ReadAll()把内容都读出来了，连接得以复用，因此只泄漏了一个读goroutine和一个写goroutine，最后加上main goroutine，所以答案就是3个goroutine。</li>
<li>从另外一个角度说，正常情况下我们的代码都会执行 ioutil.ReadAll()，但如果此时忘了 resp.Body.Close()，确实会导致泄漏。但如果你调用的域名一直是同一个的话，那么只会泄漏一个 读goroutine 和一个写goroutine，这就是为什么代码明明不规范但却看不到明显内存泄漏的原因。</li>
</ul>
<p>2、</p>
<pre><code class="hljs language-go">func <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    pub := <span class="hljs-title function_">func</span>(<span class="hljs-params">start int</span>) {
        <span class="hljs-keyword">for</span> j := start; j &lt; count; j += concurrency {
            select {
            <span class="hljs-keyword">case</span> subscribers[j] &lt;- <span class="hljs-attr">msg</span>:
        <span class="hljs-keyword">case</span> &lt;-time.After(time.Millisecond * 5):
            case &lt;-b.exit:
                return
            }
        }
    }
    
    for i := 0; i &lt; concurrency; i++ {
        go pub(i)
    }
}
</code></pre><p>被遗弃的time.After定时任务还是在时间堆里面，定时任务未到期之前，是不会被gc清理的，所以这就是会造成内存泄漏的原因</p>
<p><code>time.After</code>虽然调用的是<code>timer</code>定时器，但是他没有使用<code>time.Reset()</code> 方法再次激活定时器，所以每一次都是新创建的实例，才会造成的内存泄漏，我们添加上<code>time.Reset</code>每次重新激活定时器，即可完成解决问题。</p>
<pre><code class="hljs language-go">func <span class="hljs-title function_">fn2</span>(<span class="hljs-params">msg interface{}, subscribers []chan interface{}</span>) {
    count := <span class="hljs-number">100</span>
    concurrency := <span class="hljs-number">1</span>

    <span class="hljs-comment">//采用Timer 而不是使用time.After 原因：time.After会产生内存泄漏 在计时器触发之前，垃圾回收器不会回收Timer</span>
    pub := <span class="hljs-title function_">func</span>(<span class="hljs-params">start int</span>) {
        idleDuration := <span class="hljs-number">5</span> * time.<span class="hljs-property">Millisecond</span>
        idleTimeout := time.<span class="hljs-title class_">NewTimer</span>(idleDuration)
        defer idleTimeout.<span class="hljs-title class_">Stop</span>()
        <span class="hljs-keyword">for</span> j := start; j &lt; count; j += concurrency {
        <span class="hljs-comment">// 如果明确time已经expired，并且t.C已经读取过值，那么可以直接使用Reset；如果程序之前没有从t.C中读取过值，这时需要首先调用Stop()，如果返回true，说明timer还没有expire，stop成功删除timer，可直接reset；如果返回false，说明stop前已经expire，需要显式drain channel。</span>
            <span class="hljs-keyword">if</span> !idleTimeout.<span class="hljs-title class_">Stop</span>() {
                select {
                <span class="hljs-keyword">case</span> &lt;-idleTimeout.C:
                // 避免hang住 有可能已经被读取过了
                default:
                }
            }
        
        // 它的返回值不代表重设定时器成功或失败，而是在表达定时器在重设前的状态：-   当Timer已经停止或者超时，返回false。, -   当定时器未超时时，返回true。
idleTimeout.Reset(idleDuration)
            select {
            case subscribers[j] &lt;- msg:
            case &lt;-idleTimeout.C:
            }
        }
    }
    for i := 0; i &lt; concurrency; i++ {
        go pub(i)
    }
}
</code></pre></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"mdxSource":"\u003ch2\u003e内存泄漏实例\u003c/h2\u003e\n\u003cp\u003e1、\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003epackage main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;fmt\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;io/ioutil\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;net/http\u0026quot;\u003c/span\u003e\n    \u003cspan class=\"hljs-string\"\u003e\u0026quot;runtime\u0026quot;\u003c/span\u003e\n)\n\nfunc \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    num := \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e index := \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; index \u0026lt; num; index++ {\n        resp, _ := http.\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;https://www.baidu.com\u0026quot;\u003c/span\u003e)\n        _, _ = ioutil.\u003cspan class=\"hljs-title class_\"\u003eReadAll\u003c/span\u003e(resp.\u003cspan class=\"hljs-property\"\u003eBody\u003c/span\u003e)\n    }\n    fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;此时goroutine个数= %d\\n\u0026quot;\u003c/span\u003e, runtime.\u003cspan class=\"hljs-title class_\"\u003eNumGoroutine\u003c/span\u003e())\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e注意，如果从单元测试中进行测试，那么就是4个，因为单元测试函数入口也会算一个😹\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e虽然执行了 6 次循环，而且每次都没有执行 Body.Close() ,就是因为执行了ioutil.ReadAll()把内容都读出来了，连接得以复用，因此只泄漏了一个读goroutine和一个写goroutine，最后加上main goroutine，所以答案就是3个goroutine。\u003c/li\u003e\n\u003cli\u003e从另外一个角度说，正常情况下我们的代码都会执行 ioutil.ReadAll()，但如果此时忘了 resp.Body.Close()，确实会导致泄漏。但如果你调用的域名一直是同一个的话，那么只会泄漏一个 读goroutine 和一个写goroutine，这就是为什么代码明明不规范但却看不到明显内存泄漏的原因。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e2、\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    pub := \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estart int\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j := start; j \u0026lt; count; j += concurrency {\n            select {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e subscribers[j] \u0026lt;- \u003cspan class=\"hljs-attr\"\u003emsg\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u0026lt;-time.After(time.Millisecond * 5):\n            case \u0026lt;-b.exit:\n                return\n            }\n        }\n    }\n    \n    for i := 0; i \u0026lt; concurrency; i++ {\n        go pub(i)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e被遗弃的time.After定时任务还是在时间堆里面，定时任务未到期之前，是不会被gc清理的，所以这就是会造成内存泄漏的原因\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etime.After\u003c/code\u003e虽然调用的是\u003ccode\u003etimer\u003c/code\u003e定时器，但是他没有使用\u003ccode\u003etime.Reset()\u003c/code\u003e 方法再次激活定时器，所以每一次都是新创建的实例，才会造成的内存泄漏，我们添加上\u003ccode\u003etime.Reset\u003c/code\u003e每次重新激活定时器，即可完成解决问题。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emsg interface{}, subscribers []chan interface{}\u003c/span\u003e) {\n    count := \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e\n    concurrency := \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e//采用Timer 而不是使用time.After 原因：time.After会产生内存泄漏 在计时器触发之前，垃圾回收器不会回收Timer\u003c/span\u003e\n    pub := \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estart int\u003c/span\u003e) {\n        idleDuration := \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e * time.\u003cspan class=\"hljs-property\"\u003eMillisecond\u003c/span\u003e\n        idleTimeout := time.\u003cspan class=\"hljs-title class_\"\u003eNewTimer\u003c/span\u003e(idleDuration)\n        defer idleTimeout.\u003cspan class=\"hljs-title class_\"\u003eStop\u003c/span\u003e()\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e j := start; j \u0026lt; count; j += concurrency {\n        \u003cspan class=\"hljs-comment\"\u003e// 如果明确time已经expired，并且t.C已经读取过值，那么可以直接使用Reset；如果程序之前没有从t.C中读取过值，这时需要首先调用Stop()，如果返回true，说明timer还没有expire，stop成功删除timer，可直接reset；如果返回false，说明stop前已经expire，需要显式drain channel。\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e !idleTimeout.\u003cspan class=\"hljs-title class_\"\u003eStop\u003c/span\u003e() {\n                select {\n                \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u0026lt;-idleTimeout.C:\n                // 避免hang住 有可能已经被读取过了\n                default:\n                }\n            }\n        \n        // 它的返回值不代表重设定时器成功或失败，而是在表达定时器在重设前的状态：-   当Timer已经停止或者超时，返回false。, -   当定时器未超时时，返回true。\nidleTimeout.Reset(idleDuration)\n            select {\n            case subscribers[j] \u0026lt;- msg:\n            case \u0026lt;-idleTimeout.C:\n            }\n        }\n    }\n    for i := 0; i \u0026lt; concurrency; i++ {\n        go pub(i)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e","frontMatter":{"readingTime":{"text":"4 min read","minutes":3.87,"time":232200,"words":774},"slug":"常见编码问题","fileName":"常见编码问题.md","title":"golang编程中常见的问题","date":"2022-10-10T00:00:00.000Z","tags":["Golang"],"draft":false,"summary":"golang编程中常见的问题"}},"prev":{"title":"操作系统性能分析工具","date":"2022-10-10T00:00:00.000Z","tags":["操作系统"],"draft":false,"summary":"操作系统性能分析工具","slug":"操作系统性能分析工具"},"next":{"title":"golang命令工具","date":"2022-10-10T00:00:00.000Z","tags":["Golang"],"draft":false,"summary":"golang命令工具","slug":"go命令工具"}},"__N_SSG":true},"page":"/blog/[...slug]","query":{"slug":["常见编码问题"]},"buildId":"qwylQn0rAYfx_DG8FLkaO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>